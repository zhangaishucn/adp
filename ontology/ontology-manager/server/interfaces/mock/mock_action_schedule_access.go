// Copyright The kweaver.ai Authors.
//
// Licensed under the Apache License, Version 2.0.
// See the LICENSE file in the project root for details.

// Code generated by MockGen. DO NOT EDIT.
// Source: ../interfaces/action_schedule_access.go

// Package mock_interfaces is a generated GoMock package.
package mock_interfaces

import (
	context "context"
	sql "database/sql"
	interfaces "ontology-manager/interfaces"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockActionScheduleAccess is a mock of ActionScheduleAccess interface.
type MockActionScheduleAccess struct {
	ctrl     *gomock.Controller
	recorder *MockActionScheduleAccessMockRecorder
}

// MockActionScheduleAccessMockRecorder is the mock recorder for MockActionScheduleAccess.
type MockActionScheduleAccessMockRecorder struct {
	mock *MockActionScheduleAccess
}

// NewMockActionScheduleAccess creates a new mock instance.
func NewMockActionScheduleAccess(ctrl *gomock.Controller) *MockActionScheduleAccess {
	mock := &MockActionScheduleAccess{ctrl: ctrl}
	mock.recorder = &MockActionScheduleAccessMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockActionScheduleAccess) EXPECT() *MockActionScheduleAccessMockRecorder {
	return m.recorder
}

// CreateSchedule mocks base method.
func (m *MockActionScheduleAccess) CreateSchedule(ctx context.Context, tx *sql.Tx, schedule *interfaces.ActionSchedule) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateSchedule", ctx, tx, schedule)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateSchedule indicates an expected call of CreateSchedule.
func (mr *MockActionScheduleAccessMockRecorder) CreateSchedule(ctx, tx, schedule interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSchedule", reflect.TypeOf((*MockActionScheduleAccess)(nil).CreateSchedule), ctx, tx, schedule)
}

// DeleteSchedules mocks base method.
func (m *MockActionScheduleAccess) DeleteSchedules(ctx context.Context, tx *sql.Tx, scheduleIDs []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteSchedules", ctx, tx, scheduleIDs)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteSchedules indicates an expected call of DeleteSchedules.
func (mr *MockActionScheduleAccessMockRecorder) DeleteSchedules(ctx, tx, scheduleIDs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSchedules", reflect.TypeOf((*MockActionScheduleAccess)(nil).DeleteSchedules), ctx, tx, scheduleIDs)
}

// GetDueSchedules mocks base method.
func (m *MockActionScheduleAccess) GetDueSchedules(ctx context.Context, now int64) ([]*interfaces.ActionSchedule, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDueSchedules", ctx, now)
	ret0, _ := ret[0].([]*interfaces.ActionSchedule)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetDueSchedules indicates an expected call of GetDueSchedules.
func (mr *MockActionScheduleAccessMockRecorder) GetDueSchedules(ctx, now interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDueSchedules", reflect.TypeOf((*MockActionScheduleAccess)(nil).GetDueSchedules), ctx, now)
}

// GetSchedule mocks base method.
func (m *MockActionScheduleAccess) GetSchedule(ctx context.Context, scheduleID string) (*interfaces.ActionSchedule, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSchedule", ctx, scheduleID)
	ret0, _ := ret[0].(*interfaces.ActionSchedule)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSchedule indicates an expected call of GetSchedule.
func (mr *MockActionScheduleAccessMockRecorder) GetSchedule(ctx, scheduleID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSchedule", reflect.TypeOf((*MockActionScheduleAccess)(nil).GetSchedule), ctx, scheduleID)
}

// GetSchedules mocks base method.
func (m *MockActionScheduleAccess) GetSchedules(ctx context.Context, scheduleIDs []string) (map[string]*interfaces.ActionSchedule, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSchedules", ctx, scheduleIDs)
	ret0, _ := ret[0].(map[string]*interfaces.ActionSchedule)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSchedules indicates an expected call of GetSchedules.
func (mr *MockActionScheduleAccessMockRecorder) GetSchedules(ctx, scheduleIDs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSchedules", reflect.TypeOf((*MockActionScheduleAccess)(nil).GetSchedules), ctx, scheduleIDs)
}

// GetSchedulesTotal mocks base method.
func (m *MockActionScheduleAccess) GetSchedulesTotal(ctx context.Context, queryParams interfaces.ActionScheduleQueryParams) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSchedulesTotal", ctx, queryParams)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSchedulesTotal indicates an expected call of GetSchedulesTotal.
func (mr *MockActionScheduleAccessMockRecorder) GetSchedulesTotal(ctx, queryParams interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSchedulesTotal", reflect.TypeOf((*MockActionScheduleAccess)(nil).GetSchedulesTotal), ctx, queryParams)
}

// ListSchedules mocks base method.
func (m *MockActionScheduleAccess) ListSchedules(ctx context.Context, queryParams interfaces.ActionScheduleQueryParams) ([]*interfaces.ActionSchedule, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListSchedules", ctx, queryParams)
	ret0, _ := ret[0].([]*interfaces.ActionSchedule)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSchedules indicates an expected call of ListSchedules.
func (mr *MockActionScheduleAccessMockRecorder) ListSchedules(ctx, queryParams interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSchedules", reflect.TypeOf((*MockActionScheduleAccess)(nil).ListSchedules), ctx, queryParams)
}

// ReleaseLock mocks base method.
func (m *MockActionScheduleAccess) ReleaseLock(ctx context.Context, scheduleID, podID string, lastRunTime, nextRunTime int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReleaseLock", ctx, scheduleID, podID, lastRunTime, nextRunTime)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReleaseLock indicates an expected call of ReleaseLock.
func (mr *MockActionScheduleAccessMockRecorder) ReleaseLock(ctx, scheduleID, podID, lastRunTime, nextRunTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReleaseLock", reflect.TypeOf((*MockActionScheduleAccess)(nil).ReleaseLock), ctx, scheduleID, podID, lastRunTime, nextRunTime)
}

// TryAcquireLock mocks base method.
func (m *MockActionScheduleAccess) TryAcquireLock(ctx context.Context, scheduleID, podID string, now, lockTimeout int64) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TryAcquireLock", ctx, scheduleID, podID, now, lockTimeout)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TryAcquireLock indicates an expected call of TryAcquireLock.
func (mr *MockActionScheduleAccessMockRecorder) TryAcquireLock(ctx, scheduleID, podID, now, lockTimeout interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TryAcquireLock", reflect.TypeOf((*MockActionScheduleAccess)(nil).TryAcquireLock), ctx, scheduleID, podID, now, lockTimeout)
}

// UpdateNextRunTime mocks base method.
func (m *MockActionScheduleAccess) UpdateNextRunTime(ctx context.Context, scheduleID string, nextRunTime int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateNextRunTime", ctx, scheduleID, nextRunTime)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateNextRunTime indicates an expected call of UpdateNextRunTime.
func (mr *MockActionScheduleAccessMockRecorder) UpdateNextRunTime(ctx, scheduleID, nextRunTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateNextRunTime", reflect.TypeOf((*MockActionScheduleAccess)(nil).UpdateNextRunTime), ctx, scheduleID, nextRunTime)
}

// UpdateSchedule mocks base method.
func (m *MockActionScheduleAccess) UpdateSchedule(ctx context.Context, tx *sql.Tx, schedule *interfaces.ActionSchedule) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateSchedule", ctx, tx, schedule)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateSchedule indicates an expected call of UpdateSchedule.
func (mr *MockActionScheduleAccessMockRecorder) UpdateSchedule(ctx, tx, schedule interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateSchedule", reflect.TypeOf((*MockActionScheduleAccess)(nil).UpdateSchedule), ctx, tx, schedule)
}

// UpdateScheduleStatus mocks base method.
func (m *MockActionScheduleAccess) UpdateScheduleStatus(ctx context.Context, scheduleID, status string, nextRunTime int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateScheduleStatus", ctx, scheduleID, status, nextRunTime)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateScheduleStatus indicates an expected call of UpdateScheduleStatus.
func (mr *MockActionScheduleAccessMockRecorder) UpdateScheduleStatus(ctx, scheduleID, status, nextRunTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateScheduleStatus", reflect.TypeOf((*MockActionScheduleAccess)(nil).UpdateScheduleStatus), ctx, scheduleID, status, nextRunTime)
}
