// Copyright The kweaver.ai Authors.
//
// Licensed under the Apache License, Version 2.0.
// See the LICENSE file in the project root for details.

// Code generated by MockGen. DO NOT EDIT.
// Source: ../interfaces/opensearch_access.go

// Package mock_interfaces is a generated GoMock package.
package mock_interfaces

import (
	bytes "bytes"
	context "context"
	reflect "reflect"
	time "time"
	interfaces "uniquery/interfaces"

	gomock "github.com/golang/mock/gomock"
)

// MockOpenSearchAccess is a mock of OpenSearchAccess interface.
type MockOpenSearchAccess struct {
	ctrl     *gomock.Controller
	recorder *MockOpenSearchAccessMockRecorder
}

// MockOpenSearchAccessMockRecorder is the mock recorder for MockOpenSearchAccess.
type MockOpenSearchAccessMockRecorder struct {
	mock *MockOpenSearchAccess
}

// NewMockOpenSearchAccess creates a new mock instance.
func NewMockOpenSearchAccess(ctrl *gomock.Controller) *MockOpenSearchAccess {
	mock := &MockOpenSearchAccess{ctrl: ctrl}
	mock.recorder = &MockOpenSearchAccessMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOpenSearchAccess) EXPECT() *MockOpenSearchAccessMockRecorder {
	return m.recorder
}

// Count mocks base method.
func (m *MockOpenSearchAccess) Count(ctx context.Context, query map[string]interface{}, indices []string) ([]byte, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", ctx, query, indices)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Count indicates an expected call of Count.
func (mr *MockOpenSearchAccessMockRecorder) Count(ctx, query, indices interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockOpenSearchAccess)(nil).Count), ctx, query, indices)
}

// CreatePointInTime mocks base method.
func (m *MockOpenSearchAccess) CreatePointInTime(ctx context.Context, indices []string, keepAlive time.Duration) ([]byte, string, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreatePointInTime", ctx, indices, keepAlive)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(int)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// CreatePointInTime indicates an expected call of CreatePointInTime.
func (mr *MockOpenSearchAccessMockRecorder) CreatePointInTime(ctx, indices, keepAlive interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePointInTime", reflect.TypeOf((*MockOpenSearchAccess)(nil).CreatePointInTime), ctx, indices, keepAlive)
}

// DeletePointInTime mocks base method.
func (m *MockOpenSearchAccess) DeletePointInTime(ctx context.Context, pitIDs []string) (*interfaces.DeletePitsResp, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeletePointInTime", ctx, pitIDs)
	ret0, _ := ret[0].(*interfaces.DeletePitsResp)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// DeletePointInTime indicates an expected call of DeletePointInTime.
func (mr *MockOpenSearchAccessMockRecorder) DeletePointInTime(ctx, pitIDs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePointInTime", reflect.TypeOf((*MockOpenSearchAccess)(nil).DeletePointInTime), ctx, pitIDs)
}

// DeleteScroll mocks base method.
func (m *MockOpenSearchAccess) DeleteScroll(ctx context.Context, deleteScroll interfaces.DeleteScroll) ([]byte, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteScroll", ctx, deleteScroll)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// DeleteScroll indicates an expected call of DeleteScroll.
func (mr *MockOpenSearchAccessMockRecorder) DeleteScroll(ctx, deleteScroll interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteScroll", reflect.TypeOf((*MockOpenSearchAccess)(nil).DeleteScroll), ctx, deleteScroll)
}

// LoadIndexShards mocks base method.
func (m *MockOpenSearchAccess) LoadIndexShards(ctx context.Context, indices string) ([]byte, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadIndexShards", ctx, indices)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// LoadIndexShards indicates an expected call of LoadIndexShards.
func (mr *MockOpenSearchAccessMockRecorder) LoadIndexShards(ctx, indices interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadIndexShards", reflect.TypeOf((*MockOpenSearchAccess)(nil).LoadIndexShards), ctx, indices)
}

// Scroll mocks base method.
func (m *MockOpenSearchAccess) Scroll(ctx context.Context, scroll interfaces.Scroll) ([]byte, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Scroll", ctx, scroll)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Scroll indicates an expected call of Scroll.
func (mr *MockOpenSearchAccessMockRecorder) Scroll(ctx, scroll interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scroll", reflect.TypeOf((*MockOpenSearchAccess)(nil).Scroll), ctx, scroll)
}

// SearchSubmit mocks base method.
func (m *MockOpenSearchAccess) SearchSubmit(ctx context.Context, query map[string]interface{}, indices []string, scroll time.Duration, preference string, trackTotalHits bool) ([]byte, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchSubmit", ctx, query, indices, scroll, preference, trackTotalHits)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SearchSubmit indicates an expected call of SearchSubmit.
func (mr *MockOpenSearchAccessMockRecorder) SearchSubmit(ctx, query, indices, scroll, preference, trackTotalHits interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchSubmit", reflect.TypeOf((*MockOpenSearchAccess)(nil).SearchSubmit), ctx, query, indices, scroll, preference, trackTotalHits)
}

// SearchSubmitWithBuffer mocks base method.
func (m *MockOpenSearchAccess) SearchSubmitWithBuffer(ctx context.Context, query bytes.Buffer, indices []string, scroll time.Duration, preference string) ([]byte, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchSubmitWithBuffer", ctx, query, indices, scroll, preference)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SearchSubmitWithBuffer indicates an expected call of SearchSubmitWithBuffer.
func (mr *MockOpenSearchAccessMockRecorder) SearchSubmitWithBuffer(ctx, query, indices, scroll, preference interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchSubmitWithBuffer", reflect.TypeOf((*MockOpenSearchAccess)(nil).SearchSubmitWithBuffer), ctx, query, indices, scroll, preference)
}

// SearchWithPit mocks base method.
func (m *MockOpenSearchAccess) SearchWithPit(ctx context.Context, query bytes.Buffer) ([]byte, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchWithPit", ctx, query)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SearchWithPit indicates an expected call of SearchWithPit.
func (mr *MockOpenSearchAccessMockRecorder) SearchWithPit(ctx, query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchWithPit", reflect.TypeOf((*MockOpenSearchAccess)(nil).SearchWithPit), ctx, query)
}
