// Copyright The kweaver.ai Authors.
//
// Licensed under the Apache License, Version 2.0.
// See the LICENSE file in the project root for details.

// Code generated from SqlBase.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parsing // SqlBase
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type SqlBaseParser struct {
	*antlr.BaseParser
}

var SqlBaseParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func sqlbaseParserInit() {
	staticData := &SqlBaseParserStaticData
	staticData.LiteralNames = []string{
		"", "'.'", "'('", "')'", "','", "'?'", "'->'", "'['", "']'", "'=>'",
		"'ADD'", "'ADMIN'", "'AGGREGATIONS'", "'ALL'", "'ALTER'", "'ANALYZE'",
		"'AND'", "'AND WAIT'", "'ANY'", "'ARRAY'", "'AS'", "'ASC'", "'AT'",
		"'BERNOULLI'", "'BETWEEN'", "'BY'", "'CACHE'", "'CALL'", "'CALLED'",
		"'CASCADE'", "'CASE'", "'CAST'", "'CATALOGS'", "'COLUMN'", "'COLUMNS'",
		"'COMMENT'", "'COMMIT'", "'COMMITTED'", "'CONSTRAINT'", "'CREATE'",
		"'CROSS'", "'CUBE'", "'CUBES'", "'CURRENT'", "'CURRENT_DATE'", "'CURRENT_PATH'",
		"'CURRENT_ROLE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'",
		"'DATA'", "'DATABASE'", "'DATABASES'", "'DATE'", "'DAY'", "'DEALLOCATE'",
		"'DEFINER'", "'DELETE'", "'DETERMINISTIC'", "'UPDATE'", "'DESC'", "'DESCRIBE'",
		"'DISTINCT'", "'DISTRIBUTED'", "'DROP'", "'ELSE'", "'END'", "'ESCAPE'",
		"'EXCEPT'", "'EXCLUDING'", "'EXECUTE'", "'EXISTS'", "'EXPLAIN'", "'EXTRACT'",
		"'EXTERNAL'", "'FALSE'", "'FETCH'", "'FILTER'", "'FIRST'", "'FOLLOWING'",
		"'FOR'", "'FORMAT'", "'FROM'", "'FULL'", "'FUNCTION'", "'FUNCPROPERTIES'",
		"'FUNCTIONS'", "'GRANT'", "'GRANTED'", "'GRANTS'", "'GRAPHVIZ'", "'GROUP'",
		"'GROUPING'", "'HAVING'", "'HOUR'", "'IF'", "'IN'", "'INCLUDING'", "'INNER'",
		"'INPUT'", "'INSERT'", "'INTERSECT'", "'INTERVAL'", "'INTO'", "'INVOKER'",
		"'IO'", "'IS'", "'ISOLATION'", "'JSON'", "'JOIN'", "'LANGUAGE'", "'LAST'",
		"'LATERAL'", "'LEFT'", "'LEVEL'", "'LIKE'", "'LIMIT'", "'LOCALTIME'",
		"'LOCALTIMESTAMP'", "'LOGICAL'", "'MAP'", "'UNIFY'", "'MINUTE'", "'MONTH'",
		"'NAME'", "'NATURAL'", "'NEXT'", "'NFC'", "'NFD'", "'NFKC'", "'NFKD'",
		"'NO'", "'NONE'", "'NORMALIZE'", "'NOT'", "'NULL'", "'NULLIF'", "'NULLS'",
		"'OFFSET'", "'ON'", "'ONLY'", "'OPTION'", "'OR'", "'ORDER'", "'ORDINALITY'",
		"'OUTER'", "'OUTPUT'", "'OVER'", "'OVERWRITE'", "'PARTITION'", "'PARTITIONS'",
		"'PATH'", "'POSITION'", "'PRECEDING'", "'PREPARE'", "'PRIVILEGES'",
		"'PROPERTIES'", "'RANGE'", "'READ'", "'RECURSIVE'", "'RENAME'", "'REPEATABLE'",
		"'REPLACE'", "'RESET'", "'RESTRICT'", "'RETURN'", "'RETURNS'", "'REVOKE'",
		"'RIGHT'", "'ROLE'", "'ROLES'", "'ROLLBACK'", "'ROLLUP'", "'ROW'", "'ROWS'",
		"'SCHEMA'", "'SCHEMAS'", "'SECOND'", "'SECURITY'", "'SELECT'", "'SERIALIZABLE'",
		"'SESSION'", "'SET'", "'SETS'", "'SHOW'", "'SOME'", "'START'", "'STATS'",
		"'SUBSTRING'", "'SYSTEM'", "'TABLE'", "'TABLES'", "'TABLESAMPLE'", "'TEXT'",
		"'THEN'", "'TIES'", "'TIME'", "'TIMESTAMP'", "'TO'", "'TRANSACTION'",
		"'TRUE'", "'TRY_CAST'", "'TYPE'", "'TRUNCATE'", "'UESCAPE'", "'UNBOUNDED'",
		"'UNCOMMITTED'", "'UNION'", "'UNNEST'", "'USE'", "'USER'", "'USING'",
		"'VACUUM'", "'VALIDATE'", "'VALUES'", "'VERBOSE'", "'VIEW'", "'VIEWS'",
		"'WHEN'", "'WHERE'", "'WITH'", "'WORK'", "'WRITE'", "'YEAR'", "'ZONE'",
		"'INDEX'", "'BITMAP'", "'BLOOM'", "'MINMAX'", "'BTREE'", "'REFRESH'",
		"'META'", "'RELOAD'", "'PRIMARY'", "'KEY'", "'='", "", "'<'", "'<='",
		"'>'", "'>='", "'+'", "'-'", "'*'", "'/'", "'%'", "'||'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "ADD", "ADMIN", "AGGREGATIONS",
		"ALL", "ALTER", "ANALYZE", "AND", "AND_WAIT", "ANY", "ARRAY", "AS",
		"ASC", "AT", "BERNOULLI", "BETWEEN", "BY", "CACHE", "CALL", "CALLED",
		"CASCADE", "CASE", "CAST", "CATALOGS", "COLUMN", "COLUMNS", "COMMENT",
		"COMMIT", "COMMITTED", "CONSTRAINT", "CREATE", "CROSS", "CUBE", "CUBES",
		"CURRENT", "CURRENT_DATE", "CURRENT_PATH", "CURRENT_ROLE", "CURRENT_TIME",
		"CURRENT_TIMESTAMP", "CURRENT_USER", "DATA", "DATABASE", "DATABASES",
		"DATE", "DAY", "DEALLOCATE", "DEFINER", "DELETE", "DETERMINISTIC", "UPDATE",
		"DESC", "DESCRIBE", "DISTINCT", "DISTRIBUTED", "DROP", "ELSE", "END",
		"ESCAPE", "EXCEPT", "EXCLUDING", "EXECUTE", "EXISTS", "EXPLAIN", "EXTRACT",
		"EXTERNAL", "FALSE", "FETCH", "FILTER", "FIRST", "FOLLOWING", "FOR",
		"FORMAT", "FROM", "FULL", "FUNCTION", "FUNCPROPERTIES", "FUNCTIONS",
		"GRANT", "GRANTED", "GRANTS", "GRAPHVIZ", "GROUP", "GROUPING", "HAVING",
		"HOUR", "IF", "IN", "INCLUDING", "INNER", "INPUT", "INSERT", "INTERSECT",
		"INTERVAL", "INTO", "INVOKER", "IO", "IS", "ISOLATION", "JSON", "JOIN",
		"LANGUAGE", "LAST", "LATERAL", "LEFT", "LEVEL", "LIKE", "LIMIT", "LOCALTIME",
		"LOCALTIMESTAMP", "LOGICAL", "MAP", "UNIFY", "MINUTE", "MONTH", "NAME",
		"NATURAL", "NEXT", "NFC", "NFD", "NFKC", "NFKD", "NO", "NONE", "NORMALIZE",
		"NOT", "NULL", "NULLIF", "NULLS", "OFFSET", "ON", "ONLY", "OPTION",
		"OR", "ORDER", "ORDINALITY", "OUTER", "OUTPUT", "OVER", "OVERWRITE",
		"PARTITION", "PARTITIONS", "PATH", "POSITION", "PRECEDING", "PREPARE",
		"PRIVILEGES", "PROPERTIES", "RANGE", "READ", "RECURSIVE", "RENAME",
		"REPEATABLE", "REPLACE", "RESET", "RESTRICT", "RETURN", "RETURNS", "REVOKE",
		"RIGHT", "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROW", "ROWS", "SCHEMA",
		"SCHEMAS", "SECOND", "SECURITY", "SELECT", "SERIALIZABLE", "SESSION",
		"SET", "SETS", "SHOW", "SOME", "START", "STATS", "SUBSTRING", "SYSTEM",
		"TABLE", "TABLES", "TABLESAMPLE", "TEXT", "THEN", "TIES", "TIME", "TIMESTAMP",
		"TO", "TRANSACTION", "TRUE", "TRY_CAST", "TYPE", "TRUNCATE", "UESCAPE",
		"UNBOUNDED", "UNCOMMITTED", "UNION", "UNNEST", "USE", "USER", "USING",
		"VACUUM", "VALIDATE", "VALUES", "VERBOSE", "VIEW", "VIEWS", "WHEN",
		"WHERE", "WITH", "WORK", "WRITE", "YEAR", "ZONE", "INDEX", "BITMAP",
		"BLOOM", "MINMAX", "BTREE", "REFRESH", "META", "RELOAD", "PRIMARY",
		"KEY", "EQ", "NEQ", "LT", "LTE", "GT", "GTE", "PLUS", "MINUS", "ASTERISK",
		"SLASH", "PERCENT", "CONCAT", "STRING", "UNICODE_STRING", "BINARY_LITERAL",
		"INTEGER_VALUE", "DECIMAL_VALUE", "DOUBLE_VALUE", "IDENTIFIER", "DIGIT_IDENTIFIER",
		"QUOTED_IDENTIFIER", "BACKQUOTED_IDENTIFIER", "TIME_WITH_TIME_ZONE",
		"TIMESTAMP_WITH_TIME_ZONE", "DOUBLE_PRECISION", "SIMPLE_COMMENT", "BRACKETED_COMMENT",
		"WS", "UNRECOGNIZED", "DELIMITER", "MATERIALIZED", "IGNORE", "RESPECT",
	}
	staticData.RuleNames = []string{
		"singleStatement", "standaloneExpression", "standalonePathSpecification",
		"standaloneRoutineBody", "statement", "assignmentList", "assignmentItem",
		"query", "with", "tableElement", "columnDefinition", "likeClause", "cubeProperties",
		"cubeProperty", "properties", "propertyAssignments", "property", "functionProperties",
		"functionProperty", "sqlParameterDeclaration", "routineCharacteristics",
		"routineCharacteristic", "routineBody", "returnStatement", "externalBodyReference",
		"language", "determinism", "nullCallClause", "externalRoutineName",
		"queryNoWith", "queryTerm", "queryPrimary", "sortItem", "querySpecification",
		"groupBy", "groupingElement", "groupingSet", "cubeGroup", "sourceFilter",
		"namedQuery", "setQuantifier", "selectItem", "relation", "joinType",
		"joinCriteria", "sampledRelation", "sampleType", "aliasedRelation",
		"columnAliases", "relationPrimary", "expression", "booleanExpression",
		"predicate", "valueExpression", "primaryExpression", "string", "nullTreatment",
		"timeZoneSpecifier", "comparisonOperator", "comparisonQuantifier", "aggregations",
		"booleanValue", "indexType", "interval", "intervalField", "normalForm",
		"types", "type", "typeParameter", "baseType", "whenClause", "filter",
		"over", "windowFrame", "frameBound", "explainOption", "transactionMode",
		"levelOfIsolation", "callArgument", "pathElement", "pathSpecification",
		"privilege", "qualifiedName", "grantor", "principal", "roles", "identifier",
		"number", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 267, 2156, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 1,
		0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 211, 8, 4, 1, 4, 1,
		4, 1, 4, 3, 4, 216, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 222, 8, 4, 1, 4,
		1, 4, 3, 4, 226, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 240, 8, 4, 1, 4, 1, 4, 3, 4, 244, 8, 4, 1,
		4, 1, 4, 3, 4, 248, 8, 4, 1, 4, 1, 4, 3, 4, 252, 8, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 3, 4, 260, 8, 4, 1, 4, 1, 4, 3, 4, 264, 8, 4, 1, 4, 3,
		4, 267, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 274, 8, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 5, 4, 281, 8, 4, 10, 4, 12, 4, 284, 9, 4, 1, 4, 1, 4,
		1, 4, 3, 4, 289, 8, 4, 1, 4, 1, 4, 3, 4, 293, 8, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 3, 4, 299, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 3, 4, 310, 8, 4, 1, 4, 1, 4, 3, 4, 314, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		3, 4, 320, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 325, 8, 4, 1, 4, 1, 4, 1, 4, 3,
		4, 330, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 337, 8, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 346, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 3, 4, 354, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4,
		362, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 368, 8, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 3, 4, 375, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 382, 8, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 389, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 399, 8, 4, 1, 4, 1, 4, 3, 4, 403, 8, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 3, 4, 409, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 414, 8, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 420, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 431, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		3, 4, 438, 8, 4, 1, 4, 3, 4, 441, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 447,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 454, 8, 4, 1, 4, 1, 4, 3, 4,
		458, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 467, 8, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 475, 8, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 491,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4,
		527, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 532, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3,
		4, 538, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 555, 8, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 5, 4, 564, 8, 4, 10, 4, 12, 4, 567, 9, 4, 3, 4, 569,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 579, 8, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 5, 4, 590, 8, 4,
		10, 4, 12, 4, 593, 9, 4, 1, 4, 1, 4, 1, 4, 3, 4, 598, 8, 4, 1, 4, 1, 4,
		1, 4, 3, 4, 603, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 609, 8, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 5, 4, 616, 8, 4, 10, 4, 12, 4, 619, 9, 4, 1, 4, 1,
		4, 1, 4, 3, 4, 624, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 631, 8, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 5, 4, 637, 8, 4, 10, 4, 12, 4, 640, 9, 4, 1, 4,
		1, 4, 3, 4, 644, 8, 4, 1, 4, 1, 4, 3, 4, 648, 8, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 3, 4, 656, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 662, 8, 4,
		1, 4, 1, 4, 1, 4, 5, 4, 667, 8, 4, 10, 4, 12, 4, 670, 9, 4, 1, 4, 1, 4,
		3, 4, 674, 8, 4, 1, 4, 1, 4, 3, 4, 678, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 3, 4, 688, 8, 4, 1, 4, 3, 4, 691, 8, 4, 1, 4, 1, 4,
		3, 4, 695, 8, 4, 1, 4, 3, 4, 698, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 5, 4, 704,
		8, 4, 10, 4, 12, 4, 707, 9, 4, 1, 4, 1, 4, 3, 4, 711, 8, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 719, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4,
		737, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 743, 8, 4, 3, 4, 745, 8, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 753, 8, 4, 1, 4, 3, 4, 756, 8, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 762, 8, 4, 3, 4, 764, 8, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 3, 4, 770, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 3, 4, 794, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 799, 8, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 806, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 818, 8, 4, 3, 4, 820, 8, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 5, 4, 838, 8, 4, 10, 4, 12, 4, 841, 9, 4, 3, 4, 843, 8,
		4, 1, 4, 1, 4, 3, 4, 847, 8, 4, 1, 4, 1, 4, 3, 4, 851, 8, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		5, 4, 867, 8, 4, 10, 4, 12, 4, 870, 9, 4, 3, 4, 872, 8, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 5, 4, 883, 8, 4, 10, 4, 12, 4,
		886, 9, 4, 3, 4, 888, 8, 4, 1, 4, 3, 4, 891, 8, 4, 1, 4, 1, 4, 3, 4, 895,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 5, 4, 903, 8, 4, 10, 4, 12, 4,
		906, 9, 4, 3, 4, 908, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 924, 8, 4, 3, 4, 926, 8, 4,
		1, 4, 1, 4, 3, 4, 930, 8, 4, 1, 4, 3, 4, 933, 8, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 3, 4, 942, 8, 4, 1, 4, 3, 4, 945, 8, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 3, 4, 951, 8, 4, 1, 4, 3, 4, 954, 8, 4, 1, 4, 1, 4, 1, 4, 3,
		4, 959, 8, 4, 3, 4, 961, 8, 4, 3, 4, 963, 8, 4, 1, 5, 1, 5, 1, 5, 5, 5,
		968, 8, 5, 10, 5, 12, 5, 971, 9, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 7, 3, 7,
		978, 8, 7, 1, 7, 1, 7, 1, 8, 1, 8, 3, 8, 984, 8, 8, 1, 8, 1, 8, 1, 8, 5,
		8, 989, 8, 8, 10, 8, 12, 8, 992, 9, 8, 1, 9, 1, 9, 3, 9, 996, 8, 9, 1,
		10, 1, 10, 1, 10, 1, 10, 3, 10, 1002, 8, 10, 1, 10, 1, 10, 3, 10, 1006,
		8, 10, 1, 10, 1, 10, 3, 10, 1010, 8, 10, 1, 10, 1, 10, 3, 10, 1014, 8,
		10, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 1020, 8, 11, 1, 12, 1, 12, 1, 12,
		1, 12, 5, 12, 1026, 8, 12, 10, 12, 12, 12, 1029, 9, 12, 3, 12, 1031, 8,
		12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 3, 13, 1054, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 5, 14, 1060, 8, 14,
		10, 14, 12, 14, 1063, 9, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		3, 14, 1071, 8, 14, 1, 15, 1, 15, 1, 15, 5, 15, 1076, 8, 15, 10, 15, 12,
		15, 1079, 9, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17,
		5, 17, 1089, 8, 17, 10, 17, 12, 17, 1092, 9, 17, 1, 17, 1, 17, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 20, 5, 20, 1104, 8, 20, 10, 20,
		12, 20, 1107, 9, 20, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 1113, 8, 21, 1,
		22, 1, 22, 3, 22, 1117, 8, 22, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24,
		3, 24, 1125, 8, 24, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 3, 26, 1132, 8,
		26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27,
		1143, 8, 27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 5,
		29, 1153, 8, 29, 10, 29, 12, 29, 1156, 9, 29, 3, 29, 1158, 8, 29, 1, 29,
		1, 29, 1, 29, 3, 29, 1163, 8, 29, 3, 29, 1165, 8, 29, 1, 29, 1, 29, 1,
		29, 1, 29, 1, 29, 3, 29, 1172, 8, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29,
		1178, 8, 29, 3, 29, 1180, 8, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 1188, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1194, 8, 30,
		1, 30, 5, 30, 1197, 8, 30, 10, 30, 12, 30, 1200, 9, 30, 1, 31, 1, 31, 1,
		31, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 1209, 8, 31, 10, 31, 12, 31, 1212,
		9, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 1218, 8, 31, 1, 32, 1, 32, 3,
		32, 1222, 8, 32, 1, 32, 1, 32, 3, 32, 1226, 8, 32, 1, 33, 1, 33, 3, 33,
		1230, 8, 33, 1, 33, 1, 33, 1, 33, 5, 33, 1235, 8, 33, 10, 33, 12, 33, 1238,
		9, 33, 1, 33, 1, 33, 1, 33, 1, 33, 5, 33, 1244, 8, 33, 10, 33, 12, 33,
		1247, 9, 33, 3, 33, 1249, 8, 33, 1, 33, 1, 33, 3, 33, 1253, 8, 33, 1, 33,
		1, 33, 1, 33, 3, 33, 1258, 8, 33, 1, 33, 1, 33, 3, 33, 1262, 8, 33, 1,
		34, 3, 34, 1265, 8, 34, 1, 34, 1, 34, 1, 34, 5, 34, 1270, 8, 34, 10, 34,
		12, 34, 1273, 9, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 1281,
		8, 35, 10, 35, 12, 35, 1284, 9, 35, 3, 35, 1286, 8, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 1, 35, 5, 35, 1294, 8, 35, 10, 35, 12, 35, 1297, 9, 35,
		3, 35, 1299, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 5,
		35, 1308, 8, 35, 10, 35, 12, 35, 1311, 9, 35, 1, 35, 1, 35, 3, 35, 1315,
		8, 35, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 1321, 8, 36, 10, 36, 12, 36,
		1324, 9, 36, 3, 36, 1326, 8, 36, 1, 36, 1, 36, 3, 36, 1330, 8, 36, 1, 37,
		1, 37, 1, 37, 5, 37, 1335, 8, 37, 10, 37, 12, 37, 1338, 9, 37, 3, 37, 1340,
		8, 37, 1, 38, 1, 38, 1, 39, 1, 39, 3, 39, 1346, 8, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 3, 41, 1357, 8, 41, 1, 41,
		3, 41, 1360, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1367, 8,
		41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 1386, 8, 42, 5,
		42, 1388, 8, 42, 10, 42, 12, 42, 1391, 9, 42, 1, 43, 3, 43, 1394, 8, 43,
		1, 43, 1, 43, 3, 43, 1398, 8, 43, 1, 43, 1, 43, 3, 43, 1402, 8, 43, 1,
		43, 1, 43, 3, 43, 1406, 8, 43, 3, 43, 1408, 8, 43, 1, 44, 1, 44, 1, 44,
		1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 1417, 8, 44, 10, 44, 12, 44, 1420, 9,
		44, 1, 44, 1, 44, 3, 44, 1424, 8, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 3, 45, 1433, 8, 45, 1, 46, 1, 46, 1, 47, 1, 47, 3, 47, 1439,
		8, 47, 1, 47, 1, 47, 3, 47, 1443, 8, 47, 3, 47, 1445, 8, 47, 1, 48, 1,
		48, 1, 48, 1, 48, 5, 48, 1451, 8, 48, 10, 48, 12, 48, 1454, 9, 48, 1, 48,
		1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 5, 49, 1468, 8, 49, 10, 49, 12, 49, 1471, 9, 49, 1, 49, 1, 49, 1, 49,
		3, 49, 1476, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 3, 49, 1487, 8, 49, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 3, 51,
		1494, 8, 51, 1, 51, 1, 51, 3, 51, 1498, 8, 51, 1, 51, 1, 51, 1, 51, 1,
		51, 1, 51, 1, 51, 5, 51, 1506, 8, 51, 10, 51, 12, 51, 1509, 9, 51, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1521,
		8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1529, 8, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 5, 52, 1536, 8, 52, 10, 52, 12, 52, 1539,
		9, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1544, 8, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 3, 52, 1552, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52,
		1558, 8, 52, 1, 52, 1, 52, 3, 52, 1562, 8, 52, 1, 52, 1, 52, 1, 52, 3,
		52, 1567, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1572, 8, 52, 1, 53, 1, 53,
		1, 53, 1, 53, 3, 53, 1578, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 5, 53, 1592, 8, 53, 10, 53,
		12, 53, 1595, 9, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54,
		1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 4, 54, 1621, 8, 54, 11, 54, 12,
		54, 1622, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 5, 54, 1632,
		8, 54, 10, 54, 12, 54, 1635, 9, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54,
		1, 54, 1, 54, 3, 54, 1644, 8, 54, 1, 54, 3, 54, 1647, 8, 54, 1, 54, 1,
		54, 1, 54, 3, 54, 1652, 8, 54, 1, 54, 1, 54, 1, 54, 5, 54, 1657, 8, 54,
		10, 54, 12, 54, 1660, 9, 54, 3, 54, 1662, 8, 54, 1, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 5, 54, 1669, 8, 54, 10, 54, 12, 54, 1672, 9, 54, 3, 54, 1674,
		8, 54, 1, 54, 1, 54, 3, 54, 1678, 8, 54, 1, 54, 3, 54, 1681, 8, 54, 1,
		54, 3, 54, 1684, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54,
		1, 54, 5, 54, 1694, 8, 54, 10, 54, 12, 54, 1697, 9, 54, 3, 54, 1699, 8,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54,
		1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 4, 54, 1716, 8, 54, 11, 54, 12, 54,
		1717, 1, 54, 1, 54, 3, 54, 1722, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 4,
		54, 1728, 8, 54, 11, 54, 12, 54, 1729, 1, 54, 1, 54, 3, 54, 1734, 8, 54,
		1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54,
		5, 54, 1757, 8, 54, 10, 54, 12, 54, 1760, 9, 54, 3, 54, 1762, 8, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1771, 8, 54, 1, 54,
		1, 54, 1, 54, 1, 54, 3, 54, 1777, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3,
		54, 1783, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1789, 8, 54, 1, 54,
		1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1800, 8,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1809, 8, 54,
		1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 5, 54, 1829, 8, 54,
		10, 54, 12, 54, 1832, 9, 54, 3, 54, 1834, 8, 54, 1, 54, 3, 54, 1837, 8,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 5, 54, 1847,
		8, 54, 10, 54, 12, 54, 1850, 9, 54, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55,
		1856, 8, 55, 3, 55, 1858, 8, 55, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1864,
		8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1872, 8, 57, 1,
		58, 1, 58, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 5, 60, 1881, 8, 60, 10, 60,
		12, 60, 1884, 9, 60, 1, 61, 1, 61, 1, 62, 1, 62, 1, 63, 1, 63, 3, 63, 1892,
		8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1898, 8, 63, 1, 64, 1, 64, 1,
		65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 5, 66, 1908, 8, 66, 10, 66, 12,
		66, 1911, 9, 66, 3, 66, 1913, 8, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67,
		1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1,
		67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 5, 67, 1938, 8, 67,
		10, 67, 12, 67, 1941, 9, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67,
		1, 67, 5, 67, 1950, 8, 67, 10, 67, 12, 67, 1953, 9, 67, 1, 67, 1, 67, 3,
		67, 1957, 8, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 1964, 8, 67,
		1, 67, 1, 67, 5, 67, 1968, 8, 67, 10, 67, 12, 67, 1971, 9, 67, 1, 68, 1,
		68, 3, 68, 1975, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 1981, 8, 69,
		1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1,
		71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 5, 72, 2001, 8, 72,
		10, 72, 12, 72, 2004, 9, 72, 3, 72, 2006, 8, 72, 1, 72, 1, 72, 1, 72, 1,
		72, 1, 72, 5, 72, 2013, 8, 72, 10, 72, 12, 72, 2016, 9, 72, 3, 72, 2018,
		8, 72, 1, 72, 3, 72, 2021, 8, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 3, 73, 2041, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 1, 74, 3, 74, 2052, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75,
		3, 75, 2058, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 2065, 8,
		76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 2074, 8, 77,
		1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2081, 8, 78, 1, 79, 1, 79, 1,
		79, 1, 79, 1, 79, 3, 79, 2088, 8, 79, 1, 80, 1, 80, 1, 80, 5, 80, 2093,
		8, 80, 10, 80, 12, 80, 2096, 9, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81,
		3, 81, 2103, 8, 81, 1, 82, 1, 82, 1, 82, 5, 82, 2108, 8, 82, 10, 82, 12,
		82, 2111, 9, 82, 1, 83, 1, 83, 1, 83, 3, 83, 2116, 8, 83, 1, 84, 1, 84,
		1, 84, 1, 84, 1, 84, 3, 84, 2123, 8, 84, 1, 85, 1, 85, 1, 85, 5, 85, 2128,
		8, 85, 10, 85, 12, 85, 2131, 9, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86,
		3, 86, 2138, 8, 86, 1, 87, 3, 87, 2141, 8, 87, 1, 87, 1, 87, 3, 87, 2145,
		8, 87, 1, 87, 1, 87, 3, 87, 2149, 8, 87, 1, 87, 3, 87, 2152, 8, 87, 1,
		88, 1, 88, 1, 88, 0, 6, 60, 84, 102, 106, 108, 134, 89, 0, 2, 4, 6, 8,
		10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
		46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
		82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
		144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
		174, 176, 0, 27, 2, 0, 51, 51, 175, 175, 2, 0, 29, 29, 164, 164, 2, 0,
		56, 56, 104, 104, 2, 0, 82, 82, 96, 96, 2, 0, 52, 52, 176, 176, 2, 0, 69,
		69, 97, 97, 1, 0, 173, 174, 2, 0, 13, 13, 250, 250, 2, 0, 78, 78, 126,
		126, 2, 0, 68, 68, 207, 207, 2, 0, 21, 21, 60, 60, 2, 0, 78, 78, 111, 111,
		2, 0, 13, 13, 62, 62, 2, 0, 23, 23, 189, 189, 1, 0, 241, 242, 1, 0, 243,
		245, 1, 0, 235, 240, 3, 0, 13, 13, 18, 18, 185, 185, 2, 0, 75, 75, 200,
		200, 1, 0, 226, 229, 5, 0, 54, 54, 94, 94, 122, 123, 177, 177, 223, 223,
		1, 0, 127, 130, 2, 0, 79, 79, 153, 153, 3, 0, 90, 90, 108, 108, 193, 193,
		4, 0, 63, 63, 105, 105, 119, 119, 213, 213, 2, 0, 140, 140, 222, 222, 49,
		0, 10, 11, 13, 13, 15, 15, 18, 19, 21, 23, 27, 29, 32, 37, 43, 43, 50,
		54, 56, 56, 60, 60, 63, 63, 69, 69, 72, 72, 74, 74, 76, 79, 81, 81, 84,
		84, 86, 90, 94, 95, 97, 97, 99, 99, 102, 102, 104, 105, 107, 108, 111,
		112, 114, 114, 116, 116, 119, 120, 122, 124, 126, 132, 136, 138, 140, 141,
		144, 144, 146, 147, 149, 153, 155, 158, 160, 167, 169, 171, 173, 178, 180,
		189, 191, 193, 195, 199, 201, 202, 205, 206, 209, 210, 213, 213, 215, 217,
		221, 225, 2497, 0, 178, 1, 0, 0, 0, 2, 181, 1, 0, 0, 0, 4, 184, 1, 0, 0,
		0, 6, 187, 1, 0, 0, 0, 8, 962, 1, 0, 0, 0, 10, 964, 1, 0, 0, 0, 12, 972,
		1, 0, 0, 0, 14, 977, 1, 0, 0, 0, 16, 981, 1, 0, 0, 0, 18, 995, 1, 0, 0,
		0, 20, 997, 1, 0, 0, 0, 22, 1015, 1, 0, 0, 0, 24, 1021, 1, 0, 0, 0, 26,
		1053, 1, 0, 0, 0, 28, 1070, 1, 0, 0, 0, 30, 1072, 1, 0, 0, 0, 32, 1080,
		1, 0, 0, 0, 34, 1084, 1, 0, 0, 0, 36, 1095, 1, 0, 0, 0, 38, 1099, 1, 0,
		0, 0, 40, 1105, 1, 0, 0, 0, 42, 1112, 1, 0, 0, 0, 44, 1116, 1, 0, 0, 0,
		46, 1118, 1, 0, 0, 0, 48, 1121, 1, 0, 0, 0, 50, 1126, 1, 0, 0, 0, 52, 1131,
		1, 0, 0, 0, 54, 1142, 1, 0, 0, 0, 56, 1144, 1, 0, 0, 0, 58, 1146, 1, 0,
		0, 0, 60, 1181, 1, 0, 0, 0, 62, 1217, 1, 0, 0, 0, 64, 1219, 1, 0, 0, 0,
		66, 1227, 1, 0, 0, 0, 68, 1264, 1, 0, 0, 0, 70, 1314, 1, 0, 0, 0, 72, 1329,
		1, 0, 0, 0, 74, 1339, 1, 0, 0, 0, 76, 1341, 1, 0, 0, 0, 78, 1343, 1, 0,
		0, 0, 80, 1352, 1, 0, 0, 0, 82, 1366, 1, 0, 0, 0, 84, 1368, 1, 0, 0, 0,
		86, 1407, 1, 0, 0, 0, 88, 1423, 1, 0, 0, 0, 90, 1425, 1, 0, 0, 0, 92, 1434,
		1, 0, 0, 0, 94, 1436, 1, 0, 0, 0, 96, 1446, 1, 0, 0, 0, 98, 1486, 1, 0,
		0, 0, 100, 1488, 1, 0, 0, 0, 102, 1497, 1, 0, 0, 0, 104, 1571, 1, 0, 0,
		0, 106, 1577, 1, 0, 0, 0, 108, 1836, 1, 0, 0, 0, 110, 1857, 1, 0, 0, 0,
		112, 1863, 1, 0, 0, 0, 114, 1871, 1, 0, 0, 0, 116, 1873, 1, 0, 0, 0, 118,
		1875, 1, 0, 0, 0, 120, 1877, 1, 0, 0, 0, 122, 1885, 1, 0, 0, 0, 124, 1887,
		1, 0, 0, 0, 126, 1889, 1, 0, 0, 0, 128, 1899, 1, 0, 0, 0, 130, 1901, 1,
		0, 0, 0, 132, 1903, 1, 0, 0, 0, 134, 1963, 1, 0, 0, 0, 136, 1974, 1, 0,
		0, 0, 138, 1980, 1, 0, 0, 0, 140, 1982, 1, 0, 0, 0, 142, 1987, 1, 0, 0,
		0, 144, 1993, 1, 0, 0, 0, 146, 2040, 1, 0, 0, 0, 148, 2051, 1, 0, 0, 0,
		150, 2057, 1, 0, 0, 0, 152, 2064, 1, 0, 0, 0, 154, 2073, 1, 0, 0, 0, 156,
		2080, 1, 0, 0, 0, 158, 2087, 1, 0, 0, 0, 160, 2089, 1, 0, 0, 0, 162, 2102,
		1, 0, 0, 0, 164, 2104, 1, 0, 0, 0, 166, 2115, 1, 0, 0, 0, 168, 2122, 1,
		0, 0, 0, 170, 2124, 1, 0, 0, 0, 172, 2137, 1, 0, 0, 0, 174, 2151, 1, 0,
		0, 0, 176, 2153, 1, 0, 0, 0, 178, 179, 3, 8, 4, 0, 179, 180, 5, 0, 0, 1,
		180, 1, 1, 0, 0, 0, 181, 182, 3, 100, 50, 0, 182, 183, 5, 0, 0, 1, 183,
		3, 1, 0, 0, 0, 184, 185, 3, 160, 80, 0, 185, 186, 5, 0, 0, 1, 186, 5, 1,
		0, 0, 0, 187, 188, 3, 44, 22, 0, 188, 189, 5, 0, 0, 1, 189, 7, 1, 0, 0,
		0, 190, 963, 3, 14, 7, 0, 191, 192, 5, 209, 0, 0, 192, 963, 3, 172, 86,
		0, 193, 194, 5, 209, 0, 0, 194, 195, 3, 172, 86, 0, 195, 196, 5, 1, 0,
		0, 196, 197, 3, 172, 86, 0, 197, 963, 1, 0, 0, 0, 198, 199, 5, 209, 0,
		0, 199, 200, 3, 172, 86, 0, 200, 201, 5, 1, 0, 0, 201, 202, 3, 172, 86,
		0, 202, 203, 5, 1, 0, 0, 203, 204, 3, 172, 86, 0, 204, 963, 1, 0, 0, 0,
		205, 206, 5, 39, 0, 0, 206, 210, 7, 0, 0, 0, 207, 208, 5, 95, 0, 0, 208,
		209, 5, 134, 0, 0, 209, 211, 5, 71, 0, 0, 210, 207, 1, 0, 0, 0, 210, 211,
		1, 0, 0, 0, 211, 212, 1, 0, 0, 0, 212, 215, 3, 164, 82, 0, 213, 214, 5,
		220, 0, 0, 214, 216, 3, 28, 14, 0, 215, 213, 1, 0, 0, 0, 215, 216, 1, 0,
		0, 0, 216, 963, 1, 0, 0, 0, 217, 218, 5, 64, 0, 0, 218, 221, 7, 0, 0, 0,
		219, 220, 5, 95, 0, 0, 220, 222, 5, 71, 0, 0, 221, 219, 1, 0, 0, 0, 221,
		222, 1, 0, 0, 0, 222, 223, 1, 0, 0, 0, 223, 225, 3, 164, 82, 0, 224, 226,
		7, 1, 0, 0, 225, 224, 1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 963, 1, 0,
		0, 0, 227, 228, 5, 14, 0, 0, 228, 229, 7, 0, 0, 0, 229, 230, 3, 164, 82,
		0, 230, 231, 5, 160, 0, 0, 231, 232, 5, 198, 0, 0, 232, 233, 3, 172, 86,
		0, 233, 963, 1, 0, 0, 0, 234, 235, 5, 39, 0, 0, 235, 239, 5, 190, 0, 0,
		236, 237, 5, 95, 0, 0, 237, 238, 5, 134, 0, 0, 238, 240, 5, 71, 0, 0, 239,
		236, 1, 0, 0, 0, 239, 240, 1, 0, 0, 0, 240, 241, 1, 0, 0, 0, 241, 243,
		3, 164, 82, 0, 242, 244, 3, 96, 48, 0, 243, 242, 1, 0, 0, 0, 243, 244,
		1, 0, 0, 0, 244, 247, 1, 0, 0, 0, 245, 246, 5, 35, 0, 0, 246, 248, 3, 110,
		55, 0, 247, 245, 1, 0, 0, 0, 247, 248, 1, 0, 0, 0, 248, 251, 1, 0, 0, 0,
		249, 250, 5, 220, 0, 0, 250, 252, 3, 28, 14, 0, 251, 249, 1, 0, 0, 0, 251,
		252, 1, 0, 0, 0, 252, 253, 1, 0, 0, 0, 253, 259, 5, 20, 0, 0, 254, 260,
		3, 14, 7, 0, 255, 256, 5, 2, 0, 0, 256, 257, 3, 14, 7, 0, 257, 258, 5,
		3, 0, 0, 258, 260, 1, 0, 0, 0, 259, 254, 1, 0, 0, 0, 259, 255, 1, 0, 0,
		0, 260, 266, 1, 0, 0, 0, 261, 263, 5, 220, 0, 0, 262, 264, 5, 131, 0, 0,
		263, 262, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 265, 1, 0, 0, 0, 265,
		267, 5, 50, 0, 0, 266, 261, 1, 0, 0, 0, 266, 267, 1, 0, 0, 0, 267, 963,
		1, 0, 0, 0, 268, 269, 5, 39, 0, 0, 269, 273, 5, 190, 0, 0, 270, 271, 5,
		95, 0, 0, 271, 272, 5, 134, 0, 0, 272, 274, 5, 71, 0, 0, 273, 270, 1, 0,
		0, 0, 273, 274, 1, 0, 0, 0, 274, 275, 1, 0, 0, 0, 275, 276, 3, 164, 82,
		0, 276, 277, 5, 2, 0, 0, 277, 282, 3, 18, 9, 0, 278, 279, 5, 4, 0, 0, 279,
		281, 3, 18, 9, 0, 280, 278, 1, 0, 0, 0, 281, 284, 1, 0, 0, 0, 282, 280,
		1, 0, 0, 0, 282, 283, 1, 0, 0, 0, 283, 285, 1, 0, 0, 0, 284, 282, 1, 0,
		0, 0, 285, 288, 5, 3, 0, 0, 286, 287, 5, 35, 0, 0, 287, 289, 3, 110, 55,
		0, 288, 286, 1, 0, 0, 0, 288, 289, 1, 0, 0, 0, 289, 292, 1, 0, 0, 0, 290,
		291, 5, 220, 0, 0, 291, 293, 3, 28, 14, 0, 292, 290, 1, 0, 0, 0, 292, 293,
		1, 0, 0, 0, 293, 963, 1, 0, 0, 0, 294, 295, 5, 64, 0, 0, 295, 298, 5, 190,
		0, 0, 296, 297, 5, 95, 0, 0, 297, 299, 5, 71, 0, 0, 298, 296, 1, 0, 0,
		0, 298, 299, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 300, 963, 3, 164, 82, 0,
		301, 302, 5, 203, 0, 0, 302, 303, 5, 190, 0, 0, 303, 963, 3, 164, 82, 0,
		304, 305, 5, 26, 0, 0, 305, 306, 5, 190, 0, 0, 306, 309, 3, 164, 82, 0,
		307, 308, 5, 219, 0, 0, 308, 310, 3, 102, 51, 0, 309, 307, 1, 0, 0, 0,
		309, 310, 1, 0, 0, 0, 310, 313, 1, 0, 0, 0, 311, 312, 5, 220, 0, 0, 312,
		314, 3, 28, 14, 0, 313, 311, 1, 0, 0, 0, 313, 314, 1, 0, 0, 0, 314, 963,
		1, 0, 0, 0, 315, 316, 5, 64, 0, 0, 316, 319, 5, 26, 0, 0, 317, 318, 5,
		95, 0, 0, 318, 320, 5, 71, 0, 0, 319, 317, 1, 0, 0, 0, 319, 320, 1, 0,
		0, 0, 320, 321, 1, 0, 0, 0, 321, 324, 3, 164, 82, 0, 322, 323, 5, 219,
		0, 0, 323, 325, 3, 102, 51, 0, 324, 322, 1, 0, 0, 0, 324, 325, 1, 0, 0,
		0, 325, 963, 1, 0, 0, 0, 326, 327, 5, 184, 0, 0, 327, 329, 5, 26, 0, 0,
		328, 330, 3, 164, 82, 0, 329, 328, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0, 330,
		963, 1, 0, 0, 0, 331, 332, 5, 39, 0, 0, 332, 336, 5, 41, 0, 0, 333, 334,
		5, 95, 0, 0, 334, 335, 5, 134, 0, 0, 335, 337, 5, 71, 0, 0, 336, 333, 1,
		0, 0, 0, 336, 337, 1, 0, 0, 0, 337, 338, 1, 0, 0, 0, 338, 339, 3, 164,
		82, 0, 339, 340, 5, 139, 0, 0, 340, 341, 3, 164, 82, 0, 341, 342, 5, 220,
		0, 0, 342, 345, 3, 24, 12, 0, 343, 344, 5, 219, 0, 0, 344, 346, 3, 100,
		50, 0, 345, 343, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346, 963, 1, 0, 0, 0,
		347, 348, 5, 100, 0, 0, 348, 349, 5, 103, 0, 0, 349, 350, 5, 41, 0, 0,
		350, 353, 3, 164, 82, 0, 351, 352, 5, 219, 0, 0, 352, 354, 3, 100, 50,
		0, 353, 351, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 963, 1, 0, 0, 0, 355,
		356, 5, 100, 0, 0, 356, 357, 5, 148, 0, 0, 357, 358, 5, 41, 0, 0, 358,
		361, 3, 164, 82, 0, 359, 360, 5, 219, 0, 0, 360, 362, 3, 100, 50, 0, 361,
		359, 1, 0, 0, 0, 361, 362, 1, 0, 0, 0, 362, 963, 1, 0, 0, 0, 363, 364,
		5, 232, 0, 0, 364, 367, 5, 41, 0, 0, 365, 366, 5, 95, 0, 0, 366, 368, 5,
		71, 0, 0, 367, 365, 1, 0, 0, 0, 367, 368, 1, 0, 0, 0, 368, 369, 1, 0, 0,
		0, 369, 963, 3, 164, 82, 0, 370, 371, 5, 64, 0, 0, 371, 374, 5, 41, 0,
		0, 372, 373, 5, 95, 0, 0, 373, 375, 5, 71, 0, 0, 374, 372, 1, 0, 0, 0,
		374, 375, 1, 0, 0, 0, 375, 376, 1, 0, 0, 0, 376, 963, 3, 164, 82, 0, 377,
		378, 5, 184, 0, 0, 378, 381, 5, 42, 0, 0, 379, 380, 5, 80, 0, 0, 380, 382,
		3, 164, 82, 0, 381, 379, 1, 0, 0, 0, 381, 382, 1, 0, 0, 0, 382, 963, 1,
		0, 0, 0, 383, 384, 5, 39, 0, 0, 384, 388, 5, 225, 0, 0, 385, 386, 5, 95,
		0, 0, 386, 387, 5, 134, 0, 0, 387, 389, 5, 71, 0, 0, 388, 385, 1, 0, 0,
		0, 388, 389, 1, 0, 0, 0, 389, 390, 1, 0, 0, 0, 390, 391, 3, 164, 82, 0,
		391, 392, 5, 211, 0, 0, 392, 393, 3, 124, 62, 0, 393, 394, 5, 139, 0, 0,
		394, 395, 3, 164, 82, 0, 395, 398, 3, 96, 48, 0, 396, 397, 5, 220, 0, 0,
		397, 399, 3, 28, 14, 0, 398, 396, 1, 0, 0, 0, 398, 399, 1, 0, 0, 0, 399,
		402, 1, 0, 0, 0, 400, 401, 5, 219, 0, 0, 401, 403, 3, 100, 50, 0, 402,
		400, 1, 0, 0, 0, 402, 403, 1, 0, 0, 0, 403, 963, 1, 0, 0, 0, 404, 405,
		5, 64, 0, 0, 405, 408, 5, 225, 0, 0, 406, 407, 5, 95, 0, 0, 407, 409, 5,
		71, 0, 0, 408, 406, 1, 0, 0, 0, 408, 409, 1, 0, 0, 0, 409, 410, 1, 0, 0,
		0, 410, 413, 3, 164, 82, 0, 411, 412, 5, 219, 0, 0, 412, 414, 3, 100, 50,
		0, 413, 411, 1, 0, 0, 0, 413, 414, 1, 0, 0, 0, 414, 963, 1, 0, 0, 0, 415,
		416, 5, 14, 0, 0, 416, 419, 5, 225, 0, 0, 417, 418, 5, 95, 0, 0, 418, 420,
		5, 71, 0, 0, 419, 417, 1, 0, 0, 0, 419, 420, 1, 0, 0, 0, 420, 421, 1, 0,
		0, 0, 421, 422, 3, 164, 82, 0, 422, 423, 5, 160, 0, 0, 423, 424, 5, 198,
		0, 0, 424, 425, 3, 164, 82, 0, 425, 963, 1, 0, 0, 0, 426, 427, 5, 59, 0,
		0, 427, 430, 5, 225, 0, 0, 428, 429, 5, 95, 0, 0, 429, 431, 5, 71, 0, 0,
		430, 428, 1, 0, 0, 0, 430, 431, 1, 0, 0, 0, 431, 432, 1, 0, 0, 0, 432,
		963, 3, 164, 82, 0, 433, 434, 5, 184, 0, 0, 434, 437, 5, 225, 0, 0, 435,
		436, 5, 95, 0, 0, 436, 438, 5, 71, 0, 0, 437, 435, 1, 0, 0, 0, 437, 438,
		1, 0, 0, 0, 438, 440, 1, 0, 0, 0, 439, 441, 3, 164, 82, 0, 440, 439, 1,
		0, 0, 0, 440, 441, 1, 0, 0, 0, 441, 963, 1, 0, 0, 0, 442, 443, 5, 100,
		0, 0, 443, 444, 5, 103, 0, 0, 444, 446, 3, 164, 82, 0, 445, 447, 3, 96,
		48, 0, 446, 445, 1, 0, 0, 0, 446, 447, 1, 0, 0, 0, 447, 448, 1, 0, 0, 0,
		448, 449, 3, 14, 7, 0, 449, 963, 1, 0, 0, 0, 450, 451, 5, 100, 0, 0, 451,
		453, 5, 148, 0, 0, 452, 454, 5, 190, 0, 0, 453, 452, 1, 0, 0, 0, 453, 454,
		1, 0, 0, 0, 454, 455, 1, 0, 0, 0, 455, 457, 3, 164, 82, 0, 456, 458, 3,
		96, 48, 0, 457, 456, 1, 0, 0, 0, 457, 458, 1, 0, 0, 0, 458, 459, 1, 0,
		0, 0, 459, 460, 3, 14, 7, 0, 460, 963, 1, 0, 0, 0, 461, 462, 5, 57, 0,
		0, 462, 463, 5, 82, 0, 0, 463, 466, 3, 164, 82, 0, 464, 465, 5, 219, 0,
		0, 465, 467, 3, 102, 51, 0, 466, 464, 1, 0, 0, 0, 466, 467, 1, 0, 0, 0,
		467, 963, 1, 0, 0, 0, 468, 469, 5, 59, 0, 0, 469, 470, 3, 164, 82, 0, 470,
		471, 5, 182, 0, 0, 471, 474, 3, 10, 5, 0, 472, 473, 5, 219, 0, 0, 473,
		475, 3, 102, 51, 0, 474, 472, 1, 0, 0, 0, 474, 475, 1, 0, 0, 0, 475, 963,
		1, 0, 0, 0, 476, 477, 5, 14, 0, 0, 477, 478, 5, 190, 0, 0, 478, 479, 3,
		164, 82, 0, 479, 480, 5, 160, 0, 0, 480, 481, 5, 198, 0, 0, 481, 482, 3,
		164, 82, 0, 482, 963, 1, 0, 0, 0, 483, 484, 5, 35, 0, 0, 484, 485, 5, 139,
		0, 0, 485, 486, 5, 190, 0, 0, 486, 487, 3, 164, 82, 0, 487, 490, 5, 106,
		0, 0, 488, 491, 3, 110, 55, 0, 489, 491, 5, 135, 0, 0, 490, 488, 1, 0,
		0, 0, 490, 489, 1, 0, 0, 0, 491, 963, 1, 0, 0, 0, 492, 493, 5, 14, 0, 0,
		493, 494, 5, 190, 0, 0, 494, 495, 3, 164, 82, 0, 495, 496, 5, 160, 0, 0,
		496, 497, 5, 33, 0, 0, 497, 498, 3, 172, 86, 0, 498, 499, 5, 198, 0, 0,
		499, 500, 3, 172, 86, 0, 500, 963, 1, 0, 0, 0, 501, 502, 5, 14, 0, 0, 502,
		503, 5, 190, 0, 0, 503, 504, 3, 164, 82, 0, 504, 505, 5, 64, 0, 0, 505,
		506, 5, 33, 0, 0, 506, 507, 3, 164, 82, 0, 507, 963, 1, 0, 0, 0, 508, 509,
		5, 14, 0, 0, 509, 510, 5, 190, 0, 0, 510, 511, 3, 164, 82, 0, 511, 512,
		5, 10, 0, 0, 512, 513, 5, 33, 0, 0, 513, 514, 3, 20, 10, 0, 514, 963, 1,
		0, 0, 0, 515, 516, 5, 14, 0, 0, 516, 517, 5, 190, 0, 0, 517, 518, 3, 164,
		82, 0, 518, 519, 5, 182, 0, 0, 519, 520, 5, 156, 0, 0, 520, 521, 3, 30,
		15, 0, 521, 963, 1, 0, 0, 0, 522, 523, 5, 15, 0, 0, 523, 526, 3, 164, 82,
		0, 524, 525, 5, 220, 0, 0, 525, 527, 3, 28, 14, 0, 526, 524, 1, 0, 0, 0,
		526, 527, 1, 0, 0, 0, 527, 963, 1, 0, 0, 0, 528, 531, 5, 39, 0, 0, 529,
		530, 5, 142, 0, 0, 530, 532, 5, 162, 0, 0, 531, 529, 1, 0, 0, 0, 531, 532,
		1, 0, 0, 0, 532, 533, 1, 0, 0, 0, 533, 534, 5, 216, 0, 0, 534, 537, 3,
		164, 82, 0, 535, 536, 5, 178, 0, 0, 536, 538, 7, 2, 0, 0, 537, 535, 1,
		0, 0, 0, 537, 538, 1, 0, 0, 0, 538, 539, 1, 0, 0, 0, 539, 540, 5, 20, 0,
		0, 540, 541, 3, 14, 7, 0, 541, 963, 1, 0, 0, 0, 542, 543, 5, 14, 0, 0,
		543, 544, 5, 265, 0, 0, 544, 545, 5, 216, 0, 0, 545, 546, 3, 164, 82, 0,
		546, 547, 5, 182, 0, 0, 547, 548, 5, 156, 0, 0, 548, 549, 3, 30, 15, 0,
		549, 963, 1, 0, 0, 0, 550, 551, 5, 64, 0, 0, 551, 554, 5, 216, 0, 0, 552,
		553, 5, 95, 0, 0, 553, 555, 5, 71, 0, 0, 554, 552, 1, 0, 0, 0, 554, 555,
		1, 0, 0, 0, 555, 556, 1, 0, 0, 0, 556, 963, 3, 164, 82, 0, 557, 558, 5,
		27, 0, 0, 558, 559, 3, 164, 82, 0, 559, 568, 5, 2, 0, 0, 560, 565, 3, 156,
		78, 0, 561, 562, 5, 4, 0, 0, 562, 564, 3, 156, 78, 0, 563, 561, 1, 0, 0,
		0, 564, 567, 1, 0, 0, 0, 565, 563, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566,
		569, 1, 0, 0, 0, 567, 565, 1, 0, 0, 0, 568, 560, 1, 0, 0, 0, 568, 569,
		1, 0, 0, 0, 569, 570, 1, 0, 0, 0, 570, 571, 5, 3, 0, 0, 571, 963, 1, 0,
		0, 0, 572, 573, 5, 39, 0, 0, 573, 574, 5, 169, 0, 0, 574, 578, 3, 172,
		86, 0, 575, 576, 5, 220, 0, 0, 576, 577, 5, 11, 0, 0, 577, 579, 3, 166,
		83, 0, 578, 575, 1, 0, 0, 0, 578, 579, 1, 0, 0, 0, 579, 963, 1, 0, 0, 0,
		580, 581, 5, 64, 0, 0, 581, 582, 5, 169, 0, 0, 582, 963, 3, 172, 86, 0,
		583, 584, 5, 87, 0, 0, 584, 585, 3, 170, 85, 0, 585, 586, 5, 198, 0, 0,
		586, 591, 3, 168, 84, 0, 587, 588, 5, 4, 0, 0, 588, 590, 3, 168, 84, 0,
		589, 587, 1, 0, 0, 0, 590, 593, 1, 0, 0, 0, 591, 589, 1, 0, 0, 0, 591,
		592, 1, 0, 0, 0, 592, 597, 1, 0, 0, 0, 593, 591, 1, 0, 0, 0, 594, 595,
		5, 220, 0, 0, 595, 596, 5, 11, 0, 0, 596, 598, 5, 141, 0, 0, 597, 594,
		1, 0, 0, 0, 597, 598, 1, 0, 0, 0, 598, 602, 1, 0, 0, 0, 599, 600, 5, 88,
		0, 0, 600, 601, 5, 25, 0, 0, 601, 603, 3, 166, 83, 0, 602, 599, 1, 0, 0,
		0, 602, 603, 1, 0, 0, 0, 603, 963, 1, 0, 0, 0, 604, 608, 5, 167, 0, 0,
		605, 606, 5, 11, 0, 0, 606, 607, 5, 141, 0, 0, 607, 609, 5, 80, 0, 0, 608,
		605, 1, 0, 0, 0, 608, 609, 1, 0, 0, 0, 609, 610, 1, 0, 0, 0, 610, 611,
		3, 170, 85, 0, 611, 612, 5, 82, 0, 0, 612, 617, 3, 168, 84, 0, 613, 614,
		5, 4, 0, 0, 614, 616, 3, 168, 84, 0, 615, 613, 1, 0, 0, 0, 616, 619, 1,
		0, 0, 0, 617, 615, 1, 0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 623, 1, 0, 0,
		0, 619, 617, 1, 0, 0, 0, 620, 621, 5, 88, 0, 0, 621, 622, 5, 25, 0, 0,
		622, 624, 3, 166, 83, 0, 623, 620, 1, 0, 0, 0, 623, 624, 1, 0, 0, 0, 624,
		963, 1, 0, 0, 0, 625, 626, 5, 182, 0, 0, 626, 630, 5, 169, 0, 0, 627, 631,
		5, 13, 0, 0, 628, 631, 5, 132, 0, 0, 629, 631, 3, 172, 86, 0, 630, 627,
		1, 0, 0, 0, 630, 628, 1, 0, 0, 0, 630, 629, 1, 0, 0, 0, 631, 963, 1, 0,
		0, 0, 632, 643, 5, 87, 0, 0, 633, 638, 3, 162, 81, 0, 634, 635, 5, 4, 0,
		0, 635, 637, 3, 162, 81, 0, 636, 634, 1, 0, 0, 0, 637, 640, 1, 0, 0, 0,
		638, 636, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 644, 1, 0, 0, 0, 640,
		638, 1, 0, 0, 0, 641, 642, 5, 13, 0, 0, 642, 644, 5, 155, 0, 0, 643, 633,
		1, 0, 0, 0, 643, 641, 1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645, 647, 5, 139,
		0, 0, 646, 648, 5, 190, 0, 0, 647, 646, 1, 0, 0, 0, 647, 648, 1, 0, 0,
		0, 648, 649, 1, 0, 0, 0, 649, 650, 3, 164, 82, 0, 650, 651, 5, 198, 0,
		0, 651, 655, 3, 168, 84, 0, 652, 653, 5, 220, 0, 0, 653, 654, 5, 87, 0,
		0, 654, 656, 5, 141, 0, 0, 655, 652, 1, 0, 0, 0, 655, 656, 1, 0, 0, 0,
		656, 963, 1, 0, 0, 0, 657, 661, 5, 167, 0, 0, 658, 659, 5, 87, 0, 0, 659,
		660, 5, 141, 0, 0, 660, 662, 5, 80, 0, 0, 661, 658, 1, 0, 0, 0, 661, 662,
		1, 0, 0, 0, 662, 673, 1, 0, 0, 0, 663, 668, 3, 162, 81, 0, 664, 665, 5,
		4, 0, 0, 665, 667, 3, 162, 81, 0, 666, 664, 1, 0, 0, 0, 667, 670, 1, 0,
		0, 0, 668, 666, 1, 0, 0, 0, 668, 669, 1, 0, 0, 0, 669, 674, 1, 0, 0, 0,
		670, 668, 1, 0, 0, 0, 671, 672, 5, 13, 0, 0, 672, 674, 5, 155, 0, 0, 673,
		663, 1, 0, 0, 0, 673, 671, 1, 0, 0, 0, 674, 675, 1, 0, 0, 0, 675, 677,
		5, 139, 0, 0, 676, 678, 5, 190, 0, 0, 677, 676, 1, 0, 0, 0, 677, 678, 1,
		0, 0, 0, 678, 679, 1, 0, 0, 0, 679, 680, 3, 164, 82, 0, 680, 681, 5, 82,
		0, 0, 681, 682, 3, 168, 84, 0, 682, 963, 1, 0, 0, 0, 683, 684, 5, 184,
		0, 0, 684, 690, 5, 89, 0, 0, 685, 687, 5, 139, 0, 0, 686, 688, 5, 190,
		0, 0, 687, 686, 1, 0, 0, 0, 687, 688, 1, 0, 0, 0, 688, 689, 1, 0, 0, 0,
		689, 691, 3, 164, 82, 0, 690, 685, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691,
		963, 1, 0, 0, 0, 692, 694, 5, 72, 0, 0, 693, 695, 5, 15, 0, 0, 694, 693,
		1, 0, 0, 0, 694, 695, 1, 0, 0, 0, 695, 697, 1, 0, 0, 0, 696, 698, 5, 215,
		0, 0, 697, 696, 1, 0, 0, 0, 697, 698, 1, 0, 0, 0, 698, 710, 1, 0, 0, 0,
		699, 700, 5, 2, 0, 0, 700, 705, 3, 150, 75, 0, 701, 702, 5, 4, 0, 0, 702,
		704, 3, 150, 75, 0, 703, 701, 1, 0, 0, 0, 704, 707, 1, 0, 0, 0, 705, 703,
		1, 0, 0, 0, 705, 706, 1, 0, 0, 0, 706, 708, 1, 0, 0, 0, 707, 705, 1, 0,
		0, 0, 708, 709, 5, 3, 0, 0, 709, 711, 1, 0, 0, 0, 710, 699, 1, 0, 0, 0,
		710, 711, 1, 0, 0, 0, 711, 712, 1, 0, 0, 0, 712, 963, 3, 8, 4, 0, 713,
		714, 5, 184, 0, 0, 714, 715, 5, 74, 0, 0, 715, 716, 5, 84, 0, 0, 716, 718,
		3, 164, 82, 0, 717, 719, 3, 132, 66, 0, 718, 717, 1, 0, 0, 0, 718, 719,
		1, 0, 0, 0, 719, 963, 1, 0, 0, 0, 720, 721, 5, 184, 0, 0, 721, 722, 5,
		39, 0, 0, 722, 723, 5, 190, 0, 0, 723, 963, 3, 164, 82, 0, 724, 725, 5,
		184, 0, 0, 725, 726, 5, 39, 0, 0, 726, 727, 5, 216, 0, 0, 727, 963, 3,
		164, 82, 0, 728, 729, 5, 184, 0, 0, 729, 730, 5, 39, 0, 0, 730, 731, 5,
		41, 0, 0, 731, 963, 3, 164, 82, 0, 732, 733, 5, 184, 0, 0, 733, 736, 5,
		191, 0, 0, 734, 735, 7, 3, 0, 0, 735, 737, 3, 164, 82, 0, 736, 734, 1,
		0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 744, 1, 0, 0, 0, 738, 739, 5, 115,
		0, 0, 739, 742, 3, 110, 55, 0, 740, 741, 5, 67, 0, 0, 741, 743, 3, 110,
		55, 0, 742, 740, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0, 743, 745, 1, 0, 0, 0,
		744, 738, 1, 0, 0, 0, 744, 745, 1, 0, 0, 0, 745, 963, 1, 0, 0, 0, 746,
		747, 5, 184, 0, 0, 747, 755, 7, 4, 0, 0, 748, 752, 7, 3, 0, 0, 749, 750,
		3, 172, 86, 0, 750, 751, 5, 1, 0, 0, 751, 753, 1, 0, 0, 0, 752, 749, 1,
		0, 0, 0, 752, 753, 1, 0, 0, 0, 753, 754, 1, 0, 0, 0, 754, 756, 3, 172,
		86, 0, 755, 748, 1, 0, 0, 0, 755, 756, 1, 0, 0, 0, 756, 763, 1, 0, 0, 0,
		757, 758, 5, 115, 0, 0, 758, 761, 3, 110, 55, 0, 759, 760, 5, 67, 0, 0,
		760, 762, 3, 110, 55, 0, 761, 759, 1, 0, 0, 0, 761, 762, 1, 0, 0, 0, 762,
		764, 1, 0, 0, 0, 763, 757, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 963,
		1, 0, 0, 0, 765, 766, 5, 184, 0, 0, 766, 769, 5, 32, 0, 0, 767, 768, 5,
		115, 0, 0, 768, 770, 3, 110, 55, 0, 769, 767, 1, 0, 0, 0, 769, 770, 1,
		0, 0, 0, 770, 963, 1, 0, 0, 0, 771, 772, 5, 184, 0, 0, 772, 773, 5, 34,
		0, 0, 773, 774, 7, 3, 0, 0, 774, 963, 3, 164, 82, 0, 775, 776, 5, 184,
		0, 0, 776, 777, 5, 83, 0, 0, 777, 778, 5, 34, 0, 0, 778, 779, 7, 3, 0,
		0, 779, 963, 3, 164, 82, 0, 780, 781, 5, 184, 0, 0, 781, 782, 5, 187, 0,
		0, 782, 783, 5, 80, 0, 0, 783, 963, 3, 164, 82, 0, 784, 785, 5, 184, 0,
		0, 785, 786, 5, 187, 0, 0, 786, 787, 5, 80, 0, 0, 787, 788, 5, 2, 0, 0,
		788, 789, 3, 66, 33, 0, 789, 790, 5, 3, 0, 0, 790, 963, 1, 0, 0, 0, 791,
		793, 5, 184, 0, 0, 792, 794, 5, 43, 0, 0, 793, 792, 1, 0, 0, 0, 793, 794,
		1, 0, 0, 0, 794, 795, 1, 0, 0, 0, 795, 798, 5, 170, 0, 0, 796, 797, 7,
		3, 0, 0, 797, 799, 3, 172, 86, 0, 798, 796, 1, 0, 0, 0, 798, 799, 1, 0,
		0, 0, 799, 963, 1, 0, 0, 0, 800, 801, 5, 184, 0, 0, 801, 802, 5, 169, 0,
		0, 802, 805, 5, 89, 0, 0, 803, 804, 7, 3, 0, 0, 804, 806, 3, 172, 86, 0,
		805, 803, 1, 0, 0, 0, 805, 806, 1, 0, 0, 0, 806, 963, 1, 0, 0, 0, 807,
		808, 5, 61, 0, 0, 808, 963, 3, 164, 82, 0, 809, 810, 5, 60, 0, 0, 810,
		963, 3, 164, 82, 0, 811, 812, 5, 184, 0, 0, 812, 819, 5, 86, 0, 0, 813,
		814, 5, 115, 0, 0, 814, 817, 3, 110, 55, 0, 815, 816, 5, 67, 0, 0, 816,
		818, 3, 110, 55, 0, 817, 815, 1, 0, 0, 0, 817, 818, 1, 0, 0, 0, 818, 820,
		1, 0, 0, 0, 819, 813, 1, 0, 0, 0, 819, 820, 1, 0, 0, 0, 820, 963, 1, 0,
		0, 0, 821, 822, 5, 184, 0, 0, 822, 963, 5, 181, 0, 0, 823, 824, 5, 182,
		0, 0, 824, 825, 5, 181, 0, 0, 825, 826, 3, 164, 82, 0, 826, 827, 5, 235,
		0, 0, 827, 828, 3, 100, 50, 0, 828, 963, 1, 0, 0, 0, 829, 830, 5, 163,
		0, 0, 830, 831, 5, 181, 0, 0, 831, 963, 3, 164, 82, 0, 832, 833, 5, 186,
		0, 0, 833, 842, 5, 199, 0, 0, 834, 839, 3, 152, 76, 0, 835, 836, 5, 4,
		0, 0, 836, 838, 3, 152, 76, 0, 837, 835, 1, 0, 0, 0, 838, 841, 1, 0, 0,
		0, 839, 837, 1, 0, 0, 0, 839, 840, 1, 0, 0, 0, 840, 843, 1, 0, 0, 0, 841,
		839, 1, 0, 0, 0, 842, 834, 1, 0, 0, 0, 842, 843, 1, 0, 0, 0, 843, 963,
		1, 0, 0, 0, 844, 846, 5, 36, 0, 0, 845, 847, 5, 221, 0, 0, 846, 845, 1,
		0, 0, 0, 846, 847, 1, 0, 0, 0, 847, 963, 1, 0, 0, 0, 848, 850, 5, 171,
		0, 0, 849, 851, 5, 221, 0, 0, 850, 849, 1, 0, 0, 0, 850, 851, 1, 0, 0,
		0, 851, 963, 1, 0, 0, 0, 852, 853, 5, 154, 0, 0, 853, 854, 3, 172, 86,
		0, 854, 855, 5, 82, 0, 0, 855, 856, 3, 8, 4, 0, 856, 963, 1, 0, 0, 0, 857,
		858, 5, 55, 0, 0, 858, 859, 5, 154, 0, 0, 859, 963, 3, 172, 86, 0, 860,
		861, 5, 70, 0, 0, 861, 871, 3, 172, 86, 0, 862, 863, 5, 211, 0, 0, 863,
		868, 3, 100, 50, 0, 864, 865, 5, 4, 0, 0, 865, 867, 3, 100, 50, 0, 866,
		864, 1, 0, 0, 0, 867, 870, 1, 0, 0, 0, 868, 866, 1, 0, 0, 0, 868, 869,
		1, 0, 0, 0, 869, 872, 1, 0, 0, 0, 870, 868, 1, 0, 0, 0, 871, 862, 1, 0,
		0, 0, 871, 872, 1, 0, 0, 0, 872, 963, 1, 0, 0, 0, 873, 874, 5, 14, 0, 0,
		874, 875, 5, 190, 0, 0, 875, 876, 3, 164, 82, 0, 876, 877, 5, 70, 0, 0,
		877, 890, 3, 172, 86, 0, 878, 887, 5, 2, 0, 0, 879, 884, 3, 156, 78, 0,
		880, 881, 5, 4, 0, 0, 881, 883, 3, 156, 78, 0, 882, 880, 1, 0, 0, 0, 883,
		886, 1, 0, 0, 0, 884, 882, 1, 0, 0, 0, 884, 885, 1, 0, 0, 0, 885, 888,
		1, 0, 0, 0, 886, 884, 1, 0, 0, 0, 887, 879, 1, 0, 0, 0, 887, 888, 1, 0,
		0, 0, 888, 889, 1, 0, 0, 0, 889, 891, 5, 3, 0, 0, 890, 878, 1, 0, 0, 0,
		890, 891, 1, 0, 0, 0, 891, 894, 1, 0, 0, 0, 892, 893, 5, 219, 0, 0, 893,
		895, 3, 102, 51, 0, 894, 892, 1, 0, 0, 0, 894, 895, 1, 0, 0, 0, 895, 963,
		1, 0, 0, 0, 896, 897, 5, 70, 0, 0, 897, 907, 3, 172, 86, 0, 898, 899, 5,
		211, 0, 0, 899, 904, 3, 100, 50, 0, 900, 901, 5, 4, 0, 0, 901, 903, 3,
		100, 50, 0, 902, 900, 1, 0, 0, 0, 903, 906, 1, 0, 0, 0, 904, 902, 1, 0,
		0, 0, 904, 905, 1, 0, 0, 0, 905, 908, 1, 0, 0, 0, 906, 904, 1, 0, 0, 0,
		907, 898, 1, 0, 0, 0, 907, 908, 1, 0, 0, 0, 908, 963, 1, 0, 0, 0, 909,
		910, 5, 61, 0, 0, 910, 911, 5, 99, 0, 0, 911, 963, 3, 172, 86, 0, 912,
		913, 5, 61, 0, 0, 913, 914, 5, 146, 0, 0, 914, 963, 3, 172, 86, 0, 915,
		916, 5, 182, 0, 0, 916, 917, 5, 151, 0, 0, 917, 963, 3, 160, 80, 0, 918,
		919, 5, 212, 0, 0, 919, 920, 5, 190, 0, 0, 920, 925, 3, 164, 82, 0, 921,
		923, 5, 83, 0, 0, 922, 924, 5, 121, 0, 0, 923, 922, 1, 0, 0, 0, 923, 924,
		1, 0, 0, 0, 924, 926, 1, 0, 0, 0, 925, 921, 1, 0, 0, 0, 925, 926, 1, 0,
		0, 0, 926, 929, 1, 0, 0, 0, 927, 928, 5, 149, 0, 0, 928, 930, 3, 110, 55,
		0, 929, 927, 1, 0, 0, 0, 929, 930, 1, 0, 0, 0, 930, 932, 1, 0, 0, 0, 931,
		933, 5, 17, 0, 0, 932, 931, 1, 0, 0, 0, 932, 933, 1, 0, 0, 0, 933, 963,
		1, 0, 0, 0, 934, 935, 5, 230, 0, 0, 935, 936, 5, 231, 0, 0, 936, 944, 5,
		26, 0, 0, 937, 941, 5, 80, 0, 0, 938, 939, 3, 172, 86, 0, 939, 940, 5,
		1, 0, 0, 940, 942, 1, 0, 0, 0, 941, 938, 1, 0, 0, 0, 941, 942, 1, 0, 0,
		0, 942, 943, 1, 0, 0, 0, 943, 945, 3, 172, 86, 0, 944, 937, 1, 0, 0, 0,
		944, 945, 1, 0, 0, 0, 945, 963, 1, 0, 0, 0, 946, 947, 5, 184, 0, 0, 947,
		950, 5, 217, 0, 0, 948, 949, 7, 3, 0, 0, 949, 951, 3, 164, 82, 0, 950,
		948, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 960, 1, 0, 0, 0, 952, 954,
		5, 115, 0, 0, 953, 952, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0, 954, 955, 1,
		0, 0, 0, 955, 958, 3, 110, 55, 0, 956, 957, 5, 67, 0, 0, 957, 959, 3, 110,
		55, 0, 958, 956, 1, 0, 0, 0, 958, 959, 1, 0, 0, 0, 959, 961, 1, 0, 0, 0,
		960, 953, 1, 0, 0, 0, 960, 961, 1, 0, 0, 0, 961, 963, 1, 0, 0, 0, 962,
		190, 1, 0, 0, 0, 962, 191, 1, 0, 0, 0, 962, 193, 1, 0, 0, 0, 962, 198,
		1, 0, 0, 0, 962, 205, 1, 0, 0, 0, 962, 217, 1, 0, 0, 0, 962, 227, 1, 0,
		0, 0, 962, 234, 1, 0, 0, 0, 962, 268, 1, 0, 0, 0, 962, 294, 1, 0, 0, 0,
		962, 301, 1, 0, 0, 0, 962, 304, 1, 0, 0, 0, 962, 315, 1, 0, 0, 0, 962,
		326, 1, 0, 0, 0, 962, 331, 1, 0, 0, 0, 962, 347, 1, 0, 0, 0, 962, 355,
		1, 0, 0, 0, 962, 363, 1, 0, 0, 0, 962, 370, 1, 0, 0, 0, 962, 377, 1, 0,
		0, 0, 962, 383, 1, 0, 0, 0, 962, 404, 1, 0, 0, 0, 962, 415, 1, 0, 0, 0,
		962, 426, 1, 0, 0, 0, 962, 433, 1, 0, 0, 0, 962, 442, 1, 0, 0, 0, 962,
		450, 1, 0, 0, 0, 962, 461, 1, 0, 0, 0, 962, 468, 1, 0, 0, 0, 962, 476,
		1, 0, 0, 0, 962, 483, 1, 0, 0, 0, 962, 492, 1, 0, 0, 0, 962, 501, 1, 0,
		0, 0, 962, 508, 1, 0, 0, 0, 962, 515, 1, 0, 0, 0, 962, 522, 1, 0, 0, 0,
		962, 528, 1, 0, 0, 0, 962, 542, 1, 0, 0, 0, 962, 550, 1, 0, 0, 0, 962,
		557, 1, 0, 0, 0, 962, 572, 1, 0, 0, 0, 962, 580, 1, 0, 0, 0, 962, 583,
		1, 0, 0, 0, 962, 604, 1, 0, 0, 0, 962, 625, 1, 0, 0, 0, 962, 632, 1, 0,
		0, 0, 962, 657, 1, 0, 0, 0, 962, 683, 1, 0, 0, 0, 962, 692, 1, 0, 0, 0,
		962, 713, 1, 0, 0, 0, 962, 720, 1, 0, 0, 0, 962, 724, 1, 0, 0, 0, 962,
		728, 1, 0, 0, 0, 962, 732, 1, 0, 0, 0, 962, 746, 1, 0, 0, 0, 962, 765,
		1, 0, 0, 0, 962, 771, 1, 0, 0, 0, 962, 775, 1, 0, 0, 0, 962, 780, 1, 0,
		0, 0, 962, 784, 1, 0, 0, 0, 962, 791, 1, 0, 0, 0, 962, 800, 1, 0, 0, 0,
		962, 807, 1, 0, 0, 0, 962, 809, 1, 0, 0, 0, 962, 811, 1, 0, 0, 0, 962,
		821, 1, 0, 0, 0, 962, 823, 1, 0, 0, 0, 962, 829, 1, 0, 0, 0, 962, 832,
		1, 0, 0, 0, 962, 844, 1, 0, 0, 0, 962, 848, 1, 0, 0, 0, 962, 852, 1, 0,
		0, 0, 962, 857, 1, 0, 0, 0, 962, 860, 1, 0, 0, 0, 962, 873, 1, 0, 0, 0,
		962, 896, 1, 0, 0, 0, 962, 909, 1, 0, 0, 0, 962, 912, 1, 0, 0, 0, 962,
		915, 1, 0, 0, 0, 962, 918, 1, 0, 0, 0, 962, 934, 1, 0, 0, 0, 962, 946,
		1, 0, 0, 0, 963, 9, 1, 0, 0, 0, 964, 969, 3, 12, 6, 0, 965, 966, 5, 4,
		0, 0, 966, 968, 3, 12, 6, 0, 967, 965, 1, 0, 0, 0, 968, 971, 1, 0, 0, 0,
		969, 967, 1, 0, 0, 0, 969, 970, 1, 0, 0, 0, 970, 11, 1, 0, 0, 0, 971, 969,
		1, 0, 0, 0, 972, 973, 3, 164, 82, 0, 973, 974, 5, 235, 0, 0, 974, 975,
		3, 100, 50, 0, 975, 13, 1, 0, 0, 0, 976, 978, 3, 16, 8, 0, 977, 976, 1,
		0, 0, 0, 977, 978, 1, 0, 0, 0, 978, 979, 1, 0, 0, 0, 979, 980, 3, 58, 29,
		0, 980, 15, 1, 0, 0, 0, 981, 983, 5, 220, 0, 0, 982, 984, 5, 159, 0, 0,
		983, 982, 1, 0, 0, 0, 983, 984, 1, 0, 0, 0, 984, 985, 1, 0, 0, 0, 985,
		990, 3, 78, 39, 0, 986, 987, 5, 4, 0, 0, 987, 989, 3, 78, 39, 0, 988, 986,
		1, 0, 0, 0, 989, 992, 1, 0, 0, 0, 990, 988, 1, 0, 0, 0, 990, 991, 1, 0,
		0, 0, 991, 17, 1, 0, 0, 0, 992, 990, 1, 0, 0, 0, 993, 996, 3, 20, 10, 0,
		994, 996, 3, 22, 11, 0, 995, 993, 1, 0, 0, 0, 995, 994, 1, 0, 0, 0, 996,
		19, 1, 0, 0, 0, 997, 998, 3, 172, 86, 0, 998, 1001, 3, 134, 67, 0, 999,
		1000, 5, 134, 0, 0, 1000, 1002, 5, 135, 0, 0, 1001, 999, 1, 0, 0, 0, 1001,
		1002, 1, 0, 0, 0, 1002, 1005, 1, 0, 0, 0, 1003, 1004, 5, 233, 0, 0, 1004,
		1006, 5, 234, 0, 0, 1005, 1003, 1, 0, 0, 0, 1005, 1006, 1, 0, 0, 0, 1006,
		1009, 1, 0, 0, 0, 1007, 1008, 5, 35, 0, 0, 1008, 1010, 3, 110, 55, 0, 1009,
		1007, 1, 0, 0, 0, 1009, 1010, 1, 0, 0, 0, 1010, 1013, 1, 0, 0, 0, 1011,
		1012, 5, 220, 0, 0, 1012, 1014, 3, 28, 14, 0, 1013, 1011, 1, 0, 0, 0, 1013,
		1014, 1, 0, 0, 0, 1014, 21, 1, 0, 0, 0, 1015, 1016, 5, 115, 0, 0, 1016,
		1019, 3, 164, 82, 0, 1017, 1018, 7, 5, 0, 0, 1018, 1020, 5, 156, 0, 0,
		1019, 1017, 1, 0, 0, 0, 1019, 1020, 1, 0, 0, 0, 1020, 23, 1, 0, 0, 0, 1021,
		1030, 5, 2, 0, 0, 1022, 1027, 3, 26, 13, 0, 1023, 1024, 5, 4, 0, 0, 1024,
		1026, 3, 26, 13, 0, 1025, 1023, 1, 0, 0, 0, 1026, 1029, 1, 0, 0, 0, 1027,
		1025, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 1031, 1, 0, 0, 0, 1029,
		1027, 1, 0, 0, 0, 1030, 1022, 1, 0, 0, 0, 1030, 1031, 1, 0, 0, 0, 1031,
		1032, 1, 0, 0, 0, 1032, 1033, 5, 3, 0, 0, 1033, 25, 1, 0, 0, 0, 1034, 1035,
		5, 12, 0, 0, 1035, 1036, 5, 235, 0, 0, 1036, 1037, 5, 2, 0, 0, 1037, 1038,
		3, 120, 60, 0, 1038, 1039, 5, 3, 0, 0, 1039, 1054, 1, 0, 0, 0, 1040, 1041,
		5, 91, 0, 0, 1041, 1042, 5, 235, 0, 0, 1042, 1043, 5, 2, 0, 0, 1043, 1044,
		3, 74, 37, 0, 1044, 1045, 5, 3, 0, 0, 1045, 1054, 1, 0, 0, 0, 1046, 1047,
		5, 77, 0, 0, 1047, 1048, 5, 235, 0, 0, 1048, 1049, 5, 2, 0, 0, 1049, 1050,
		3, 76, 38, 0, 1050, 1051, 5, 3, 0, 0, 1051, 1054, 1, 0, 0, 0, 1052, 1054,
		3, 32, 16, 0, 1053, 1034, 1, 0, 0, 0, 1053, 1040, 1, 0, 0, 0, 1053, 1046,
		1, 0, 0, 0, 1053, 1052, 1, 0, 0, 0, 1054, 27, 1, 0, 0, 0, 1055, 1056, 5,
		2, 0, 0, 1056, 1061, 3, 32, 16, 0, 1057, 1058, 5, 4, 0, 0, 1058, 1060,
		3, 32, 16, 0, 1059, 1057, 1, 0, 0, 0, 1060, 1063, 1, 0, 0, 0, 1061, 1059,
		1, 0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062, 1064, 1, 0, 0, 0, 1063, 1061,
		1, 0, 0, 0, 1064, 1065, 5, 3, 0, 0, 1065, 1071, 1, 0, 0, 0, 1066, 1067,
		5, 2, 0, 0, 1067, 1068, 3, 30, 15, 0, 1068, 1069, 5, 3, 0, 0, 1069, 1071,
		1, 0, 0, 0, 1070, 1055, 1, 0, 0, 0, 1070, 1066, 1, 0, 0, 0, 1071, 29, 1,
		0, 0, 0, 1072, 1077, 3, 32, 16, 0, 1073, 1074, 5, 4, 0, 0, 1074, 1076,
		3, 32, 16, 0, 1075, 1073, 1, 0, 0, 0, 1076, 1079, 1, 0, 0, 0, 1077, 1075,
		1, 0, 0, 0, 1077, 1078, 1, 0, 0, 0, 1078, 31, 1, 0, 0, 0, 1079, 1077, 1,
		0, 0, 0, 1080, 1081, 3, 172, 86, 0, 1081, 1082, 5, 235, 0, 0, 1082, 1083,
		3, 100, 50, 0, 1083, 33, 1, 0, 0, 0, 1084, 1085, 5, 2, 0, 0, 1085, 1090,
		3, 36, 18, 0, 1086, 1087, 5, 4, 0, 0, 1087, 1089, 3, 36, 18, 0, 1088, 1086,
		1, 0, 0, 0, 1089, 1092, 1, 0, 0, 0, 1090, 1088, 1, 0, 0, 0, 1090, 1091,
		1, 0, 0, 0, 1091, 1093, 1, 0, 0, 0, 1092, 1090, 1, 0, 0, 0, 1093, 1094,
		5, 3, 0, 0, 1094, 35, 1, 0, 0, 0, 1095, 1096, 3, 172, 86, 0, 1096, 1097,
		5, 235, 0, 0, 1097, 1098, 3, 110, 55, 0, 1098, 37, 1, 0, 0, 0, 1099, 1100,
		3, 172, 86, 0, 1100, 1101, 3, 134, 67, 0, 1101, 39, 1, 0, 0, 0, 1102, 1104,
		3, 42, 21, 0, 1103, 1102, 1, 0, 0, 0, 1104, 1107, 1, 0, 0, 0, 1105, 1103,
		1, 0, 0, 0, 1105, 1106, 1, 0, 0, 0, 1106, 41, 1, 0, 0, 0, 1107, 1105, 1,
		0, 0, 0, 1108, 1109, 5, 110, 0, 0, 1109, 1113, 3, 50, 25, 0, 1110, 1113,
		3, 52, 26, 0, 1111, 1113, 3, 54, 27, 0, 1112, 1108, 1, 0, 0, 0, 1112, 1110,
		1, 0, 0, 0, 1112, 1111, 1, 0, 0, 0, 1113, 43, 1, 0, 0, 0, 1114, 1117, 3,
		46, 23, 0, 1115, 1117, 3, 48, 24, 0, 1116, 1114, 1, 0, 0, 0, 1116, 1115,
		1, 0, 0, 0, 1117, 45, 1, 0, 0, 0, 1118, 1119, 5, 165, 0, 0, 1119, 1120,
		3, 100, 50, 0, 1120, 47, 1, 0, 0, 0, 1121, 1124, 5, 74, 0, 0, 1122, 1123,
		5, 124, 0, 0, 1123, 1125, 3, 56, 28, 0, 1124, 1122, 1, 0, 0, 0, 1124, 1125,
		1, 0, 0, 0, 1125, 49, 1, 0, 0, 0, 1126, 1127, 3, 172, 86, 0, 1127, 51,
		1, 0, 0, 0, 1128, 1132, 5, 58, 0, 0, 1129, 1130, 5, 134, 0, 0, 1130, 1132,
		5, 58, 0, 0, 1131, 1128, 1, 0, 0, 0, 1131, 1129, 1, 0, 0, 0, 1132, 53,
		1, 0, 0, 0, 1133, 1134, 5, 166, 0, 0, 1134, 1135, 5, 135, 0, 0, 1135, 1136,
		5, 139, 0, 0, 1136, 1137, 5, 135, 0, 0, 1137, 1143, 5, 99, 0, 0, 1138,
		1139, 5, 28, 0, 0, 1139, 1140, 5, 139, 0, 0, 1140, 1141, 5, 135, 0, 0,
		1141, 1143, 5, 99, 0, 0, 1142, 1133, 1, 0, 0, 0, 1142, 1138, 1, 0, 0, 0,
		1143, 55, 1, 0, 0, 0, 1144, 1145, 3, 172, 86, 0, 1145, 57, 1, 0, 0, 0,
		1146, 1157, 3, 60, 30, 0, 1147, 1148, 5, 143, 0, 0, 1148, 1149, 5, 25,
		0, 0, 1149, 1154, 3, 64, 32, 0, 1150, 1151, 5, 4, 0, 0, 1151, 1153, 3,
		64, 32, 0, 1152, 1150, 1, 0, 0, 0, 1153, 1156, 1, 0, 0, 0, 1154, 1152,
		1, 0, 0, 0, 1154, 1155, 1, 0, 0, 0, 1155, 1158, 1, 0, 0, 0, 1156, 1154,
		1, 0, 0, 0, 1157, 1147, 1, 0, 0, 0, 1157, 1158, 1, 0, 0, 0, 1158, 1164,
		1, 0, 0, 0, 1159, 1160, 5, 138, 0, 0, 1160, 1162, 5, 250, 0, 0, 1161, 1163,
		7, 6, 0, 0, 1162, 1161, 1, 0, 0, 0, 1162, 1163, 1, 0, 0, 0, 1163, 1165,
		1, 0, 0, 0, 1164, 1159, 1, 0, 0, 0, 1164, 1165, 1, 0, 0, 0, 1165, 1179,
		1, 0, 0, 0, 1166, 1167, 5, 116, 0, 0, 1167, 1180, 7, 7, 0, 0, 1168, 1169,
		5, 76, 0, 0, 1169, 1171, 7, 8, 0, 0, 1170, 1172, 5, 250, 0, 0, 1171, 1170,
		1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172, 1173, 1, 0, 0, 0, 1173, 1177,
		7, 6, 0, 0, 1174, 1178, 5, 140, 0, 0, 1175, 1176, 5, 220, 0, 0, 1176, 1178,
		5, 195, 0, 0, 1177, 1174, 1, 0, 0, 0, 1177, 1175, 1, 0, 0, 0, 1178, 1180,
		1, 0, 0, 0, 1179, 1166, 1, 0, 0, 0, 1179, 1168, 1, 0, 0, 0, 1179, 1180,
		1, 0, 0, 0, 1180, 59, 1, 0, 0, 0, 1181, 1182, 6, 30, -1, 0, 1182, 1183,
		3, 62, 31, 0, 1183, 1198, 1, 0, 0, 0, 1184, 1185, 10, 2, 0, 0, 1185, 1187,
		5, 101, 0, 0, 1186, 1188, 3, 80, 40, 0, 1187, 1186, 1, 0, 0, 0, 1187, 1188,
		1, 0, 0, 0, 1188, 1189, 1, 0, 0, 0, 1189, 1197, 3, 60, 30, 3, 1190, 1191,
		10, 1, 0, 0, 1191, 1193, 7, 9, 0, 0, 1192, 1194, 3, 80, 40, 0, 1193, 1192,
		1, 0, 0, 0, 1193, 1194, 1, 0, 0, 0, 1194, 1195, 1, 0, 0, 0, 1195, 1197,
		3, 60, 30, 2, 1196, 1184, 1, 0, 0, 0, 1196, 1190, 1, 0, 0, 0, 1197, 1200,
		1, 0, 0, 0, 1198, 1196, 1, 0, 0, 0, 1198, 1199, 1, 0, 0, 0, 1199, 61, 1,
		0, 0, 0, 1200, 1198, 1, 0, 0, 0, 1201, 1218, 3, 66, 33, 0, 1202, 1203,
		5, 190, 0, 0, 1203, 1218, 3, 164, 82, 0, 1204, 1205, 5, 214, 0, 0, 1205,
		1210, 3, 100, 50, 0, 1206, 1207, 5, 4, 0, 0, 1207, 1209, 3, 100, 50, 0,
		1208, 1206, 1, 0, 0, 0, 1209, 1212, 1, 0, 0, 0, 1210, 1208, 1, 0, 0, 0,
		1210, 1211, 1, 0, 0, 0, 1211, 1218, 1, 0, 0, 0, 1212, 1210, 1, 0, 0, 0,
		1213, 1214, 5, 2, 0, 0, 1214, 1215, 3, 58, 29, 0, 1215, 1216, 5, 3, 0,
		0, 1216, 1218, 1, 0, 0, 0, 1217, 1201, 1, 0, 0, 0, 1217, 1202, 1, 0, 0,
		0, 1217, 1204, 1, 0, 0, 0, 1217, 1213, 1, 0, 0, 0, 1218, 63, 1, 0, 0, 0,
		1219, 1221, 3, 100, 50, 0, 1220, 1222, 7, 10, 0, 0, 1221, 1220, 1, 0, 0,
		0, 1221, 1222, 1, 0, 0, 0, 1222, 1225, 1, 0, 0, 0, 1223, 1224, 5, 137,
		0, 0, 1224, 1226, 7, 11, 0, 0, 1225, 1223, 1, 0, 0, 0, 1225, 1226, 1, 0,
		0, 0, 1226, 65, 1, 0, 0, 0, 1227, 1229, 5, 179, 0, 0, 1228, 1230, 3, 80,
		40, 0, 1229, 1228, 1, 0, 0, 0, 1229, 1230, 1, 0, 0, 0, 1230, 1231, 1, 0,
		0, 0, 1231, 1236, 3, 82, 41, 0, 1232, 1233, 5, 4, 0, 0, 1233, 1235, 3,
		82, 41, 0, 1234, 1232, 1, 0, 0, 0, 1235, 1238, 1, 0, 0, 0, 1236, 1234,
		1, 0, 0, 0, 1236, 1237, 1, 0, 0, 0, 1237, 1248, 1, 0, 0, 0, 1238, 1236,
		1, 0, 0, 0, 1239, 1240, 5, 82, 0, 0, 1240, 1245, 3, 84, 42, 0, 1241, 1242,
		5, 4, 0, 0, 1242, 1244, 3, 84, 42, 0, 1243, 1241, 1, 0, 0, 0, 1244, 1247,
		1, 0, 0, 0, 1245, 1243, 1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246, 1249,
		1, 0, 0, 0, 1247, 1245, 1, 0, 0, 0, 1248, 1239, 1, 0, 0, 0, 1248, 1249,
		1, 0, 0, 0, 1249, 1252, 1, 0, 0, 0, 1250, 1251, 5, 219, 0, 0, 1251, 1253,
		3, 102, 51, 0, 1252, 1250, 1, 0, 0, 0, 1252, 1253, 1, 0, 0, 0, 1253, 1257,
		1, 0, 0, 0, 1254, 1255, 5, 91, 0, 0, 1255, 1256, 5, 25, 0, 0, 1256, 1258,
		3, 68, 34, 0, 1257, 1254, 1, 0, 0, 0, 1257, 1258, 1, 0, 0, 0, 1258, 1261,
		1, 0, 0, 0, 1259, 1260, 5, 93, 0, 0, 1260, 1262, 3, 102, 51, 0, 1261, 1259,
		1, 0, 0, 0, 1261, 1262, 1, 0, 0, 0, 1262, 67, 1, 0, 0, 0, 1263, 1265, 3,
		80, 40, 0, 1264, 1263, 1, 0, 0, 0, 1264, 1265, 1, 0, 0, 0, 1265, 1266,
		1, 0, 0, 0, 1266, 1271, 3, 70, 35, 0, 1267, 1268, 5, 4, 0, 0, 1268, 1270,
		3, 70, 35, 0, 1269, 1267, 1, 0, 0, 0, 1270, 1273, 1, 0, 0, 0, 1271, 1269,
		1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0, 1272, 69, 1, 0, 0, 0, 1273, 1271, 1,
		0, 0, 0, 1274, 1315, 3, 72, 36, 0, 1275, 1276, 5, 172, 0, 0, 1276, 1285,
		5, 2, 0, 0, 1277, 1282, 3, 100, 50, 0, 1278, 1279, 5, 4, 0, 0, 1279, 1281,
		3, 100, 50, 0, 1280, 1278, 1, 0, 0, 0, 1281, 1284, 1, 0, 0, 0, 1282, 1280,
		1, 0, 0, 0, 1282, 1283, 1, 0, 0, 0, 1283, 1286, 1, 0, 0, 0, 1284, 1282,
		1, 0, 0, 0, 1285, 1277, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286, 1287,
		1, 0, 0, 0, 1287, 1315, 5, 3, 0, 0, 1288, 1289, 5, 41, 0, 0, 1289, 1298,
		5, 2, 0, 0, 1290, 1295, 3, 100, 50, 0, 1291, 1292, 5, 4, 0, 0, 1292, 1294,
		3, 100, 50, 0, 1293, 1291, 1, 0, 0, 0, 1294, 1297, 1, 0, 0, 0, 1295, 1293,
		1, 0, 0, 0, 1295, 1296, 1, 0, 0, 0, 1296, 1299, 1, 0, 0, 0, 1297, 1295,
		1, 0, 0, 0, 1298, 1290, 1, 0, 0, 0, 1298, 1299, 1, 0, 0, 0, 1299, 1300,
		1, 0, 0, 0, 1300, 1315, 5, 3, 0, 0, 1301, 1302, 5, 92, 0, 0, 1302, 1303,
		5, 183, 0, 0, 1303, 1304, 5, 2, 0, 0, 1304, 1309, 3, 72, 36, 0, 1305, 1306,
		5, 4, 0, 0, 1306, 1308, 3, 72, 36, 0, 1307, 1305, 1, 0, 0, 0, 1308, 1311,
		1, 0, 0, 0, 1309, 1307, 1, 0, 0, 0, 1309, 1310, 1, 0, 0, 0, 1310, 1312,
		1, 0, 0, 0, 1311, 1309, 1, 0, 0, 0, 1312, 1313, 5, 3, 0, 0, 1313, 1315,
		1, 0, 0, 0, 1314, 1274, 1, 0, 0, 0, 1314, 1275, 1, 0, 0, 0, 1314, 1288,
		1, 0, 0, 0, 1314, 1301, 1, 0, 0, 0, 1315, 71, 1, 0, 0, 0, 1316, 1325, 5,
		2, 0, 0, 1317, 1322, 3, 100, 50, 0, 1318, 1319, 5, 4, 0, 0, 1319, 1321,
		3, 100, 50, 0, 1320, 1318, 1, 0, 0, 0, 1321, 1324, 1, 0, 0, 0, 1322, 1320,
		1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1326, 1, 0, 0, 0, 1324, 1322,
		1, 0, 0, 0, 1325, 1317, 1, 0, 0, 0, 1325, 1326, 1, 0, 0, 0, 1326, 1327,
		1, 0, 0, 0, 1327, 1330, 5, 3, 0, 0, 1328, 1330, 3, 100, 50, 0, 1329, 1316,
		1, 0, 0, 0, 1329, 1328, 1, 0, 0, 0, 1330, 73, 1, 0, 0, 0, 1331, 1336, 3,
		172, 86, 0, 1332, 1333, 5, 4, 0, 0, 1333, 1335, 3, 172, 86, 0, 1334, 1332,
		1, 0, 0, 0, 1335, 1338, 1, 0, 0, 0, 1336, 1334, 1, 0, 0, 0, 1336, 1337,
		1, 0, 0, 0, 1337, 1340, 1, 0, 0, 0, 1338, 1336, 1, 0, 0, 0, 1339, 1331,
		1, 0, 0, 0, 1339, 1340, 1, 0, 0, 0, 1340, 75, 1, 0, 0, 0, 1341, 1342, 3,
		100, 50, 0, 1342, 77, 1, 0, 0, 0, 1343, 1345, 3, 172, 86, 0, 1344, 1346,
		3, 96, 48, 0, 1345, 1344, 1, 0, 0, 0, 1345, 1346, 1, 0, 0, 0, 1346, 1347,
		1, 0, 0, 0, 1347, 1348, 5, 20, 0, 0, 1348, 1349, 5, 2, 0, 0, 1349, 1350,
		3, 14, 7, 0, 1350, 1351, 5, 3, 0, 0, 1351, 79, 1, 0, 0, 0, 1352, 1353,
		7, 12, 0, 0, 1353, 81, 1, 0, 0, 0, 1354, 1359, 3, 100, 50, 0, 1355, 1357,
		5, 20, 0, 0, 1356, 1355, 1, 0, 0, 0, 1356, 1357, 1, 0, 0, 0, 1357, 1358,
		1, 0, 0, 0, 1358, 1360, 3, 172, 86, 0, 1359, 1356, 1, 0, 0, 0, 1359, 1360,
		1, 0, 0, 0, 1360, 1367, 1, 0, 0, 0, 1361, 1362, 3, 164, 82, 0, 1362, 1363,
		5, 1, 0, 0, 1363, 1364, 5, 243, 0, 0, 1364, 1367, 1, 0, 0, 0, 1365, 1367,
		5, 243, 0, 0, 1366, 1354, 1, 0, 0, 0, 1366, 1361, 1, 0, 0, 0, 1366, 1365,
		1, 0, 0, 0, 1367, 83, 1, 0, 0, 0, 1368, 1369, 6, 42, -1, 0, 1369, 1370,
		3, 90, 45, 0, 1370, 1389, 1, 0, 0, 0, 1371, 1385, 10, 2, 0, 0, 1372, 1373,
		5, 40, 0, 0, 1373, 1374, 5, 109, 0, 0, 1374, 1386, 3, 90, 45, 0, 1375,
		1376, 3, 86, 43, 0, 1376, 1377, 5, 109, 0, 0, 1377, 1378, 3, 84, 42, 0,
		1378, 1379, 3, 88, 44, 0, 1379, 1386, 1, 0, 0, 0, 1380, 1381, 5, 125, 0,
		0, 1381, 1382, 3, 86, 43, 0, 1382, 1383, 5, 109, 0, 0, 1383, 1384, 3, 90,
		45, 0, 1384, 1386, 1, 0, 0, 0, 1385, 1372, 1, 0, 0, 0, 1385, 1375, 1, 0,
		0, 0, 1385, 1380, 1, 0, 0, 0, 1386, 1388, 1, 0, 0, 0, 1387, 1371, 1, 0,
		0, 0, 1388, 1391, 1, 0, 0, 0, 1389, 1387, 1, 0, 0, 0, 1389, 1390, 1, 0,
		0, 0, 1390, 85, 1, 0, 0, 0, 1391, 1389, 1, 0, 0, 0, 1392, 1394, 5, 98,
		0, 0, 1393, 1392, 1, 0, 0, 0, 1393, 1394, 1, 0, 0, 0, 1394, 1408, 1, 0,
		0, 0, 1395, 1397, 5, 113, 0, 0, 1396, 1398, 5, 145, 0, 0, 1397, 1396, 1,
		0, 0, 0, 1397, 1398, 1, 0, 0, 0, 1398, 1408, 1, 0, 0, 0, 1399, 1401, 5,
		168, 0, 0, 1400, 1402, 5, 145, 0, 0, 1401, 1400, 1, 0, 0, 0, 1401, 1402,
		1, 0, 0, 0, 1402, 1408, 1, 0, 0, 0, 1403, 1405, 5, 83, 0, 0, 1404, 1406,
		5, 145, 0, 0, 1405, 1404, 1, 0, 0, 0, 1405, 1406, 1, 0, 0, 0, 1406, 1408,
		1, 0, 0, 0, 1407, 1393, 1, 0, 0, 0, 1407, 1395, 1, 0, 0, 0, 1407, 1399,
		1, 0, 0, 0, 1407, 1403, 1, 0, 0, 0, 1408, 87, 1, 0, 0, 0, 1409, 1410, 5,
		139, 0, 0, 1410, 1424, 3, 102, 51, 0, 1411, 1412, 5, 211, 0, 0, 1412, 1413,
		5, 2, 0, 0, 1413, 1418, 3, 172, 86, 0, 1414, 1415, 5, 4, 0, 0, 1415, 1417,
		3, 172, 86, 0, 1416, 1414, 1, 0, 0, 0, 1417, 1420, 1, 0, 0, 0, 1418, 1416,
		1, 0, 0, 0, 1418, 1419, 1, 0, 0, 0, 1419, 1421, 1, 0, 0, 0, 1420, 1418,
		1, 0, 0, 0, 1421, 1422, 5, 3, 0, 0, 1422, 1424, 1, 0, 0, 0, 1423, 1409,
		1, 0, 0, 0, 1423, 1411, 1, 0, 0, 0, 1424, 89, 1, 0, 0, 0, 1425, 1432, 3,
		94, 47, 0, 1426, 1427, 5, 192, 0, 0, 1427, 1428, 3, 92, 46, 0, 1428, 1429,
		5, 2, 0, 0, 1429, 1430, 3, 100, 50, 0, 1430, 1431, 5, 3, 0, 0, 1431, 1433,
		1, 0, 0, 0, 1432, 1426, 1, 0, 0, 0, 1432, 1433, 1, 0, 0, 0, 1433, 91, 1,
		0, 0, 0, 1434, 1435, 7, 13, 0, 0, 1435, 93, 1, 0, 0, 0, 1436, 1444, 3,
		98, 49, 0, 1437, 1439, 5, 20, 0, 0, 1438, 1437, 1, 0, 0, 0, 1438, 1439,
		1, 0, 0, 0, 1439, 1440, 1, 0, 0, 0, 1440, 1442, 3, 172, 86, 0, 1441, 1443,
		3, 96, 48, 0, 1442, 1441, 1, 0, 0, 0, 1442, 1443, 1, 0, 0, 0, 1443, 1445,
		1, 0, 0, 0, 1444, 1438, 1, 0, 0, 0, 1444, 1445, 1, 0, 0, 0, 1445, 95, 1,
		0, 0, 0, 1446, 1447, 5, 2, 0, 0, 1447, 1452, 3, 172, 86, 0, 1448, 1449,
		5, 4, 0, 0, 1449, 1451, 3, 172, 86, 0, 1450, 1448, 1, 0, 0, 0, 1451, 1454,
		1, 0, 0, 0, 1452, 1450, 1, 0, 0, 0, 1452, 1453, 1, 0, 0, 0, 1453, 1455,
		1, 0, 0, 0, 1454, 1452, 1, 0, 0, 0, 1455, 1456, 5, 3, 0, 0, 1456, 97, 1,
		0, 0, 0, 1457, 1487, 3, 164, 82, 0, 1458, 1459, 5, 2, 0, 0, 1459, 1460,
		3, 14, 7, 0, 1460, 1461, 5, 3, 0, 0, 1461, 1487, 1, 0, 0, 0, 1462, 1463,
		5, 208, 0, 0, 1463, 1464, 5, 2, 0, 0, 1464, 1469, 3, 100, 50, 0, 1465,
		1466, 5, 4, 0, 0, 1466, 1468, 3, 100, 50, 0, 1467, 1465, 1, 0, 0, 0, 1468,
		1471, 1, 0, 0, 0, 1469, 1467, 1, 0, 0, 0, 1469, 1470, 1, 0, 0, 0, 1470,
		1472, 1, 0, 0, 0, 1471, 1469, 1, 0, 0, 0, 1472, 1475, 5, 3, 0, 0, 1473,
		1474, 5, 220, 0, 0, 1474, 1476, 5, 144, 0, 0, 1475, 1473, 1, 0, 0, 0, 1475,
		1476, 1, 0, 0, 0, 1476, 1487, 1, 0, 0, 0, 1477, 1478, 5, 112, 0, 0, 1478,
		1479, 5, 2, 0, 0, 1479, 1480, 3, 14, 7, 0, 1480, 1481, 5, 3, 0, 0, 1481,
		1487, 1, 0, 0, 0, 1482, 1483, 5, 2, 0, 0, 1483, 1484, 3, 84, 42, 0, 1484,
		1485, 5, 3, 0, 0, 1485, 1487, 1, 0, 0, 0, 1486, 1457, 1, 0, 0, 0, 1486,
		1458, 1, 0, 0, 0, 1486, 1462, 1, 0, 0, 0, 1486, 1477, 1, 0, 0, 0, 1486,
		1482, 1, 0, 0, 0, 1487, 99, 1, 0, 0, 0, 1488, 1489, 3, 102, 51, 0, 1489,
		101, 1, 0, 0, 0, 1490, 1491, 6, 51, -1, 0, 1491, 1493, 3, 106, 53, 0, 1492,
		1494, 3, 104, 52, 0, 1493, 1492, 1, 0, 0, 0, 1493, 1494, 1, 0, 0, 0, 1494,
		1498, 1, 0, 0, 0, 1495, 1496, 5, 134, 0, 0, 1496, 1498, 3, 102, 51, 3,
		1497, 1490, 1, 0, 0, 0, 1497, 1495, 1, 0, 0, 0, 1498, 1507, 1, 0, 0, 0,
		1499, 1500, 10, 2, 0, 0, 1500, 1501, 5, 16, 0, 0, 1501, 1506, 3, 102, 51,
		3, 1502, 1503, 10, 1, 0, 0, 1503, 1504, 5, 142, 0, 0, 1504, 1506, 3, 102,
		51, 2, 1505, 1499, 1, 0, 0, 0, 1505, 1502, 1, 0, 0, 0, 1506, 1509, 1, 0,
		0, 0, 1507, 1505, 1, 0, 0, 0, 1507, 1508, 1, 0, 0, 0, 1508, 103, 1, 0,
		0, 0, 1509, 1507, 1, 0, 0, 0, 1510, 1511, 3, 116, 58, 0, 1511, 1512, 3,
		106, 53, 0, 1512, 1572, 1, 0, 0, 0, 1513, 1514, 3, 116, 58, 0, 1514, 1515,
		3, 118, 59, 0, 1515, 1516, 5, 2, 0, 0, 1516, 1517, 3, 14, 7, 0, 1517, 1518,
		5, 3, 0, 0, 1518, 1572, 1, 0, 0, 0, 1519, 1521, 5, 134, 0, 0, 1520, 1519,
		1, 0, 0, 0, 1520, 1521, 1, 0, 0, 0, 1521, 1522, 1, 0, 0, 0, 1522, 1523,
		5, 24, 0, 0, 1523, 1524, 3, 106, 53, 0, 1524, 1525, 5, 16, 0, 0, 1525,
		1526, 3, 106, 53, 0, 1526, 1572, 1, 0, 0, 0, 1527, 1529, 5, 134, 0, 0,
		1528, 1527, 1, 0, 0, 0, 1528, 1529, 1, 0, 0, 0, 1529, 1530, 1, 0, 0, 0,
		1530, 1531, 5, 96, 0, 0, 1531, 1532, 5, 2, 0, 0, 1532, 1537, 3, 100, 50,
		0, 1533, 1534, 5, 4, 0, 0, 1534, 1536, 3, 100, 50, 0, 1535, 1533, 1, 0,
		0, 0, 1536, 1539, 1, 0, 0, 0, 1537, 1535, 1, 0, 0, 0, 1537, 1538, 1, 0,
		0, 0, 1538, 1540, 1, 0, 0, 0, 1539, 1537, 1, 0, 0, 0, 1540, 1541, 5, 3,
		0, 0, 1541, 1572, 1, 0, 0, 0, 1542, 1544, 5, 134, 0, 0, 1543, 1542, 1,
		0, 0, 0, 1543, 1544, 1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0, 1545, 1546, 5,
		96, 0, 0, 1546, 1547, 5, 2, 0, 0, 1547, 1548, 3, 14, 7, 0, 1548, 1549,
		5, 3, 0, 0, 1549, 1572, 1, 0, 0, 0, 1550, 1552, 5, 134, 0, 0, 1551, 1550,
		1, 0, 0, 0, 1551, 1552, 1, 0, 0, 0, 1552, 1553, 1, 0, 0, 0, 1553, 1554,
		5, 115, 0, 0, 1554, 1557, 3, 106, 53, 0, 1555, 1556, 5, 67, 0, 0, 1556,
		1558, 3, 106, 53, 0, 1557, 1555, 1, 0, 0, 0, 1557, 1558, 1, 0, 0, 0, 1558,
		1572, 1, 0, 0, 0, 1559, 1561, 5, 106, 0, 0, 1560, 1562, 5, 134, 0, 0, 1561,
		1560, 1, 0, 0, 0, 1561, 1562, 1, 0, 0, 0, 1562, 1563, 1, 0, 0, 0, 1563,
		1572, 5, 135, 0, 0, 1564, 1566, 5, 106, 0, 0, 1565, 1567, 5, 134, 0, 0,
		1566, 1565, 1, 0, 0, 0, 1566, 1567, 1, 0, 0, 0, 1567, 1568, 1, 0, 0, 0,
		1568, 1569, 5, 62, 0, 0, 1569, 1570, 5, 82, 0, 0, 1570, 1572, 3, 106, 53,
		0, 1571, 1510, 1, 0, 0, 0, 1571, 1513, 1, 0, 0, 0, 1571, 1520, 1, 0, 0,
		0, 1571, 1528, 1, 0, 0, 0, 1571, 1543, 1, 0, 0, 0, 1571, 1551, 1, 0, 0,
		0, 1571, 1559, 1, 0, 0, 0, 1571, 1564, 1, 0, 0, 0, 1572, 105, 1, 0, 0,
		0, 1573, 1574, 6, 53, -1, 0, 1574, 1578, 3, 108, 54, 0, 1575, 1576, 7,
		14, 0, 0, 1576, 1578, 3, 106, 53, 4, 1577, 1573, 1, 0, 0, 0, 1577, 1575,
		1, 0, 0, 0, 1578, 1593, 1, 0, 0, 0, 1579, 1580, 10, 3, 0, 0, 1580, 1581,
		7, 15, 0, 0, 1581, 1592, 3, 106, 53, 4, 1582, 1583, 10, 2, 0, 0, 1583,
		1584, 7, 14, 0, 0, 1584, 1592, 3, 106, 53, 3, 1585, 1586, 10, 1, 0, 0,
		1586, 1587, 5, 246, 0, 0, 1587, 1592, 3, 106, 53, 2, 1588, 1589, 10, 5,
		0, 0, 1589, 1590, 5, 22, 0, 0, 1590, 1592, 3, 114, 57, 0, 1591, 1579, 1,
		0, 0, 0, 1591, 1582, 1, 0, 0, 0, 1591, 1585, 1, 0, 0, 0, 1591, 1588, 1,
		0, 0, 0, 1592, 1595, 1, 0, 0, 0, 1593, 1591, 1, 0, 0, 0, 1593, 1594, 1,
		0, 0, 0, 1594, 107, 1, 0, 0, 0, 1595, 1593, 1, 0, 0, 0, 1596, 1597, 6,
		54, -1, 0, 1597, 1837, 5, 135, 0, 0, 1598, 1837, 3, 126, 63, 0, 1599, 1600,
		3, 172, 86, 0, 1600, 1601, 3, 110, 55, 0, 1601, 1837, 1, 0, 0, 0, 1602,
		1603, 5, 259, 0, 0, 1603, 1837, 3, 110, 55, 0, 1604, 1837, 3, 174, 87,
		0, 1605, 1837, 3, 122, 61, 0, 1606, 1837, 3, 110, 55, 0, 1607, 1837, 5,
		249, 0, 0, 1608, 1837, 5, 5, 0, 0, 1609, 1610, 5, 152, 0, 0, 1610, 1611,
		5, 2, 0, 0, 1611, 1612, 3, 106, 53, 0, 1612, 1613, 5, 96, 0, 0, 1613, 1614,
		3, 106, 53, 0, 1614, 1615, 5, 3, 0, 0, 1615, 1837, 1, 0, 0, 0, 1616, 1617,
		5, 2, 0, 0, 1617, 1620, 3, 100, 50, 0, 1618, 1619, 5, 4, 0, 0, 1619, 1621,
		3, 100, 50, 0, 1620, 1618, 1, 0, 0, 0, 1621, 1622, 1, 0, 0, 0, 1622, 1620,
		1, 0, 0, 0, 1622, 1623, 1, 0, 0, 0, 1623, 1624, 1, 0, 0, 0, 1624, 1625,
		5, 3, 0, 0, 1625, 1837, 1, 0, 0, 0, 1626, 1627, 5, 173, 0, 0, 1627, 1628,
		5, 2, 0, 0, 1628, 1633, 3, 100, 50, 0, 1629, 1630, 5, 4, 0, 0, 1630, 1632,
		3, 100, 50, 0, 1631, 1629, 1, 0, 0, 0, 1632, 1635, 1, 0, 0, 0, 1633, 1631,
		1, 0, 0, 0, 1633, 1634, 1, 0, 0, 0, 1634, 1636, 1, 0, 0, 0, 1635, 1633,
		1, 0, 0, 0, 1636, 1637, 5, 3, 0, 0, 1637, 1837, 1, 0, 0, 0, 1638, 1639,
		3, 164, 82, 0, 1639, 1640, 5, 2, 0, 0, 1640, 1641, 5, 243, 0, 0, 1641,
		1643, 5, 3, 0, 0, 1642, 1644, 3, 142, 71, 0, 1643, 1642, 1, 0, 0, 0, 1643,
		1644, 1, 0, 0, 0, 1644, 1646, 1, 0, 0, 0, 1645, 1647, 3, 144, 72, 0, 1646,
		1645, 1, 0, 0, 0, 1646, 1647, 1, 0, 0, 0, 1647, 1837, 1, 0, 0, 0, 1648,
		1649, 3, 164, 82, 0, 1649, 1661, 5, 2, 0, 0, 1650, 1652, 3, 80, 40, 0,
		1651, 1650, 1, 0, 0, 0, 1651, 1652, 1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0,
		1653, 1658, 3, 100, 50, 0, 1654, 1655, 5, 4, 0, 0, 1655, 1657, 3, 100,
		50, 0, 1656, 1654, 1, 0, 0, 0, 1657, 1660, 1, 0, 0, 0, 1658, 1656, 1, 0,
		0, 0, 1658, 1659, 1, 0, 0, 0, 1659, 1662, 1, 0, 0, 0, 1660, 1658, 1, 0,
		0, 0, 1661, 1651, 1, 0, 0, 0, 1661, 1662, 1, 0, 0, 0, 1662, 1673, 1, 0,
		0, 0, 1663, 1664, 5, 143, 0, 0, 1664, 1665, 5, 25, 0, 0, 1665, 1670, 3,
		64, 32, 0, 1666, 1667, 5, 4, 0, 0, 1667, 1669, 3, 64, 32, 0, 1668, 1666,
		1, 0, 0, 0, 1669, 1672, 1, 0, 0, 0, 1670, 1668, 1, 0, 0, 0, 1670, 1671,
		1, 0, 0, 0, 1671, 1674, 1, 0, 0, 0, 1672, 1670, 1, 0, 0, 0, 1673, 1663,
		1, 0, 0, 0, 1673, 1674, 1, 0, 0, 0, 1674, 1675, 1, 0, 0, 0, 1675, 1677,
		5, 3, 0, 0, 1676, 1678, 3, 142, 71, 0, 1677, 1676, 1, 0, 0, 0, 1677, 1678,
		1, 0, 0, 0, 1678, 1683, 1, 0, 0, 0, 1679, 1681, 3, 112, 56, 0, 1680, 1679,
		1, 0, 0, 0, 1680, 1681, 1, 0, 0, 0, 1681, 1682, 1, 0, 0, 0, 1682, 1684,
		3, 144, 72, 0, 1683, 1680, 1, 0, 0, 0, 1683, 1684, 1, 0, 0, 0, 1684, 1837,
		1, 0, 0, 0, 1685, 1686, 3, 172, 86, 0, 1686, 1687, 5, 6, 0, 0, 1687, 1688,
		3, 100, 50, 0, 1688, 1837, 1, 0, 0, 0, 1689, 1698, 5, 2, 0, 0, 1690, 1695,
		3, 172, 86, 0, 1691, 1692, 5, 4, 0, 0, 1692, 1694, 3, 172, 86, 0, 1693,
		1691, 1, 0, 0, 0, 1694, 1697, 1, 0, 0, 0, 1695, 1693, 1, 0, 0, 0, 1695,
		1696, 1, 0, 0, 0, 1696, 1699, 1, 0, 0, 0, 1697, 1695, 1, 0, 0, 0, 1698,
		1690, 1, 0, 0, 0, 1698, 1699, 1, 0, 0, 0, 1699, 1700, 1, 0, 0, 0, 1700,
		1701, 5, 3, 0, 0, 1701, 1702, 5, 6, 0, 0, 1702, 1837, 3, 100, 50, 0, 1703,
		1704, 5, 2, 0, 0, 1704, 1705, 3, 14, 7, 0, 1705, 1706, 5, 3, 0, 0, 1706,
		1837, 1, 0, 0, 0, 1707, 1708, 5, 71, 0, 0, 1708, 1709, 5, 2, 0, 0, 1709,
		1710, 3, 14, 7, 0, 1710, 1711, 5, 3, 0, 0, 1711, 1837, 1, 0, 0, 0, 1712,
		1713, 5, 30, 0, 0, 1713, 1715, 3, 106, 53, 0, 1714, 1716, 3, 140, 70, 0,
		1715, 1714, 1, 0, 0, 0, 1716, 1717, 1, 0, 0, 0, 1717, 1715, 1, 0, 0, 0,
		1717, 1718, 1, 0, 0, 0, 1718, 1721, 1, 0, 0, 0, 1719, 1720, 5, 65, 0, 0,
		1720, 1722, 3, 100, 50, 0, 1721, 1719, 1, 0, 0, 0, 1721, 1722, 1, 0, 0,
		0, 1722, 1723, 1, 0, 0, 0, 1723, 1724, 5, 66, 0, 0, 1724, 1837, 1, 0, 0,
		0, 1725, 1727, 5, 30, 0, 0, 1726, 1728, 3, 140, 70, 0, 1727, 1726, 1, 0,
		0, 0, 1728, 1729, 1, 0, 0, 0, 1729, 1727, 1, 0, 0, 0, 1729, 1730, 1, 0,
		0, 0, 1730, 1733, 1, 0, 0, 0, 1731, 1732, 5, 65, 0, 0, 1732, 1734, 3, 100,
		50, 0, 1733, 1731, 1, 0, 0, 0, 1733, 1734, 1, 0, 0, 0, 1734, 1735, 1, 0,
		0, 0, 1735, 1736, 5, 66, 0, 0, 1736, 1837, 1, 0, 0, 0, 1737, 1738, 5, 31,
		0, 0, 1738, 1739, 5, 2, 0, 0, 1739, 1740, 3, 100, 50, 0, 1740, 1741, 5,
		20, 0, 0, 1741, 1742, 3, 134, 67, 0, 1742, 1743, 5, 3, 0, 0, 1743, 1837,
		1, 0, 0, 0, 1744, 1745, 5, 201, 0, 0, 1745, 1746, 5, 2, 0, 0, 1746, 1747,
		3, 100, 50, 0, 1747, 1748, 5, 20, 0, 0, 1748, 1749, 3, 134, 67, 0, 1749,
		1750, 5, 3, 0, 0, 1750, 1837, 1, 0, 0, 0, 1751, 1752, 5, 19, 0, 0, 1752,
		1761, 5, 7, 0, 0, 1753, 1758, 3, 100, 50, 0, 1754, 1755, 5, 4, 0, 0, 1755,
		1757, 3, 100, 50, 0, 1756, 1754, 1, 0, 0, 0, 1757, 1760, 1, 0, 0, 0, 1758,
		1756, 1, 0, 0, 0, 1758, 1759, 1, 0, 0, 0, 1759, 1762, 1, 0, 0, 0, 1760,
		1758, 1, 0, 0, 0, 1761, 1753, 1, 0, 0, 0, 1761, 1762, 1, 0, 0, 0, 1762,
		1763, 1, 0, 0, 0, 1763, 1837, 5, 8, 0, 0, 1764, 1837, 3, 172, 86, 0, 1765,
		1837, 5, 44, 0, 0, 1766, 1770, 5, 47, 0, 0, 1767, 1768, 5, 2, 0, 0, 1768,
		1769, 5, 250, 0, 0, 1769, 1771, 5, 3, 0, 0, 1770, 1767, 1, 0, 0, 0, 1770,
		1771, 1, 0, 0, 0, 1771, 1837, 1, 0, 0, 0, 1772, 1776, 5, 48, 0, 0, 1773,
		1774, 5, 2, 0, 0, 1774, 1775, 5, 250, 0, 0, 1775, 1777, 5, 3, 0, 0, 1776,
		1773, 1, 0, 0, 0, 1776, 1777, 1, 0, 0, 0, 1777, 1837, 1, 0, 0, 0, 1778,
		1782, 5, 117, 0, 0, 1779, 1780, 5, 2, 0, 0, 1780, 1781, 5, 250, 0, 0, 1781,
		1783, 5, 3, 0, 0, 1782, 1779, 1, 0, 0, 0, 1782, 1783, 1, 0, 0, 0, 1783,
		1837, 1, 0, 0, 0, 1784, 1788, 5, 118, 0, 0, 1785, 1786, 5, 2, 0, 0, 1786,
		1787, 5, 250, 0, 0, 1787, 1789, 5, 3, 0, 0, 1788, 1785, 1, 0, 0, 0, 1788,
		1789, 1, 0, 0, 0, 1789, 1837, 1, 0, 0, 0, 1790, 1837, 5, 49, 0, 0, 1791,
		1837, 5, 45, 0, 0, 1792, 1793, 5, 188, 0, 0, 1793, 1794, 5, 2, 0, 0, 1794,
		1795, 3, 106, 53, 0, 1795, 1796, 5, 82, 0, 0, 1796, 1799, 3, 106, 53, 0,
		1797, 1798, 5, 80, 0, 0, 1798, 1800, 3, 106, 53, 0, 1799, 1797, 1, 0, 0,
		0, 1799, 1800, 1, 0, 0, 0, 1800, 1801, 1, 0, 0, 0, 1801, 1802, 5, 3, 0,
		0, 1802, 1837, 1, 0, 0, 0, 1803, 1804, 5, 133, 0, 0, 1804, 1805, 5, 2,
		0, 0, 1805, 1808, 3, 106, 53, 0, 1806, 1807, 5, 4, 0, 0, 1807, 1809, 3,
		130, 65, 0, 1808, 1806, 1, 0, 0, 0, 1808, 1809, 1, 0, 0, 0, 1809, 1810,
		1, 0, 0, 0, 1810, 1811, 5, 3, 0, 0, 1811, 1837, 1, 0, 0, 0, 1812, 1813,
		5, 73, 0, 0, 1813, 1814, 5, 2, 0, 0, 1814, 1815, 3, 172, 86, 0, 1815, 1816,
		5, 82, 0, 0, 1816, 1817, 3, 106, 53, 0, 1817, 1818, 5, 3, 0, 0, 1818, 1837,
		1, 0, 0, 0, 1819, 1820, 5, 2, 0, 0, 1820, 1821, 3, 100, 50, 0, 1821, 1822,
		5, 3, 0, 0, 1822, 1837, 1, 0, 0, 0, 1823, 1824, 5, 92, 0, 0, 1824, 1833,
		5, 2, 0, 0, 1825, 1830, 3, 164, 82, 0, 1826, 1827, 5, 4, 0, 0, 1827, 1829,
		3, 164, 82, 0, 1828, 1826, 1, 0, 0, 0, 1829, 1832, 1, 0, 0, 0, 1830, 1828,
		1, 0, 0, 0, 1830, 1831, 1, 0, 0, 0, 1831, 1834, 1, 0, 0, 0, 1832, 1830,
		1, 0, 0, 0, 1833, 1825, 1, 0, 0, 0, 1833, 1834, 1, 0, 0, 0, 1834, 1835,
		1, 0, 0, 0, 1835, 1837, 5, 3, 0, 0, 1836, 1596, 1, 0, 0, 0, 1836, 1598,
		1, 0, 0, 0, 1836, 1599, 1, 0, 0, 0, 1836, 1602, 1, 0, 0, 0, 1836, 1604,
		1, 0, 0, 0, 1836, 1605, 1, 0, 0, 0, 1836, 1606, 1, 0, 0, 0, 1836, 1607,
		1, 0, 0, 0, 1836, 1608, 1, 0, 0, 0, 1836, 1609, 1, 0, 0, 0, 1836, 1616,
		1, 0, 0, 0, 1836, 1626, 1, 0, 0, 0, 1836, 1638, 1, 0, 0, 0, 1836, 1648,
		1, 0, 0, 0, 1836, 1685, 1, 0, 0, 0, 1836, 1689, 1, 0, 0, 0, 1836, 1703,
		1, 0, 0, 0, 1836, 1707, 1, 0, 0, 0, 1836, 1712, 1, 0, 0, 0, 1836, 1725,
		1, 0, 0, 0, 1836, 1737, 1, 0, 0, 0, 1836, 1744, 1, 0, 0, 0, 1836, 1751,
		1, 0, 0, 0, 1836, 1764, 1, 0, 0, 0, 1836, 1765, 1, 0, 0, 0, 1836, 1766,
		1, 0, 0, 0, 1836, 1772, 1, 0, 0, 0, 1836, 1778, 1, 0, 0, 0, 1836, 1784,
		1, 0, 0, 0, 1836, 1790, 1, 0, 0, 0, 1836, 1791, 1, 0, 0, 0, 1836, 1792,
		1, 0, 0, 0, 1836, 1803, 1, 0, 0, 0, 1836, 1812, 1, 0, 0, 0, 1836, 1819,
		1, 0, 0, 0, 1836, 1823, 1, 0, 0, 0, 1837, 1848, 1, 0, 0, 0, 1838, 1839,
		10, 15, 0, 0, 1839, 1840, 5, 7, 0, 0, 1840, 1841, 3, 106, 53, 0, 1841,
		1842, 5, 8, 0, 0, 1842, 1847, 1, 0, 0, 0, 1843, 1844, 10, 13, 0, 0, 1844,
		1845, 5, 1, 0, 0, 1845, 1847, 3, 172, 86, 0, 1846, 1838, 1, 0, 0, 0, 1846,
		1843, 1, 0, 0, 0, 1847, 1850, 1, 0, 0, 0, 1848, 1846, 1, 0, 0, 0, 1848,
		1849, 1, 0, 0, 0, 1849, 109, 1, 0, 0, 0, 1850, 1848, 1, 0, 0, 0, 1851,
		1858, 5, 247, 0, 0, 1852, 1855, 5, 248, 0, 0, 1853, 1854, 5, 204, 0, 0,
		1854, 1856, 5, 247, 0, 0, 1855, 1853, 1, 0, 0, 0, 1855, 1856, 1, 0, 0,
		0, 1856, 1858, 1, 0, 0, 0, 1857, 1851, 1, 0, 0, 0, 1857, 1852, 1, 0, 0,
		0, 1858, 111, 1, 0, 0, 0, 1859, 1860, 5, 266, 0, 0, 1860, 1864, 5, 137,
		0, 0, 1861, 1862, 5, 267, 0, 0, 1862, 1864, 5, 137, 0, 0, 1863, 1859, 1,
		0, 0, 0, 1863, 1861, 1, 0, 0, 0, 1864, 113, 1, 0, 0, 0, 1865, 1866, 5,
		196, 0, 0, 1866, 1867, 5, 224, 0, 0, 1867, 1872, 3, 126, 63, 0, 1868, 1869,
		5, 196, 0, 0, 1869, 1870, 5, 224, 0, 0, 1870, 1872, 3, 110, 55, 0, 1871,
		1865, 1, 0, 0, 0, 1871, 1868, 1, 0, 0, 0, 1872, 115, 1, 0, 0, 0, 1873,
		1874, 7, 16, 0, 0, 1874, 117, 1, 0, 0, 0, 1875, 1876, 7, 17, 0, 0, 1876,
		119, 1, 0, 0, 0, 1877, 1882, 3, 100, 50, 0, 1878, 1879, 5, 4, 0, 0, 1879,
		1881, 3, 100, 50, 0, 1880, 1878, 1, 0, 0, 0, 1881, 1884, 1, 0, 0, 0, 1882,
		1880, 1, 0, 0, 0, 1882, 1883, 1, 0, 0, 0, 1883, 121, 1, 0, 0, 0, 1884,
		1882, 1, 0, 0, 0, 1885, 1886, 7, 18, 0, 0, 1886, 123, 1, 0, 0, 0, 1887,
		1888, 7, 19, 0, 0, 1888, 125, 1, 0, 0, 0, 1889, 1891, 5, 102, 0, 0, 1890,
		1892, 7, 14, 0, 0, 1891, 1890, 1, 0, 0, 0, 1891, 1892, 1, 0, 0, 0, 1892,
		1893, 1, 0, 0, 0, 1893, 1894, 3, 110, 55, 0, 1894, 1897, 3, 128, 64, 0,
		1895, 1896, 5, 198, 0, 0, 1896, 1898, 3, 128, 64, 0, 1897, 1895, 1, 0,
		0, 0, 1897, 1898, 1, 0, 0, 0, 1898, 127, 1, 0, 0, 0, 1899, 1900, 7, 20,
		0, 0, 1900, 129, 1, 0, 0, 0, 1901, 1902, 7, 21, 0, 0, 1902, 131, 1, 0,
		0, 0, 1903, 1912, 5, 2, 0, 0, 1904, 1909, 3, 134, 67, 0, 1905, 1906, 5,
		4, 0, 0, 1906, 1908, 3, 134, 67, 0, 1907, 1905, 1, 0, 0, 0, 1908, 1911,
		1, 0, 0, 0, 1909, 1907, 1, 0, 0, 0, 1909, 1910, 1, 0, 0, 0, 1910, 1913,
		1, 0, 0, 0, 1911, 1909, 1, 0, 0, 0, 1912, 1904, 1, 0, 0, 0, 1912, 1913,
		1, 0, 0, 0, 1913, 1914, 1, 0, 0, 0, 1914, 1915, 5, 3, 0, 0, 1915, 133,
		1, 0, 0, 0, 1916, 1917, 6, 67, -1, 0, 1917, 1918, 5, 19, 0, 0, 1918, 1919,
		5, 237, 0, 0, 1919, 1920, 3, 134, 67, 0, 1920, 1921, 5, 239, 0, 0, 1921,
		1964, 1, 0, 0, 0, 1922, 1923, 5, 120, 0, 0, 1923, 1924, 5, 237, 0, 0, 1924,
		1925, 3, 134, 67, 0, 1925, 1926, 5, 4, 0, 0, 1926, 1927, 3, 134, 67, 0,
		1927, 1928, 5, 239, 0, 0, 1928, 1964, 1, 0, 0, 0, 1929, 1930, 5, 173, 0,
		0, 1930, 1931, 5, 2, 0, 0, 1931, 1932, 3, 172, 86, 0, 1932, 1939, 3, 134,
		67, 0, 1933, 1934, 5, 4, 0, 0, 1934, 1935, 3, 172, 86, 0, 1935, 1936, 3,
		134, 67, 0, 1936, 1938, 1, 0, 0, 0, 1937, 1933, 1, 0, 0, 0, 1938, 1941,
		1, 0, 0, 0, 1939, 1937, 1, 0, 0, 0, 1939, 1940, 1, 0, 0, 0, 1940, 1942,
		1, 0, 0, 0, 1941, 1939, 1, 0, 0, 0, 1942, 1943, 5, 3, 0, 0, 1943, 1964,
		1, 0, 0, 0, 1944, 1956, 3, 138, 69, 0, 1945, 1946, 5, 2, 0, 0, 1946, 1951,
		3, 136, 68, 0, 1947, 1948, 5, 4, 0, 0, 1948, 1950, 3, 136, 68, 0, 1949,
		1947, 1, 0, 0, 0, 1950, 1953, 1, 0, 0, 0, 1951, 1949, 1, 0, 0, 0, 1951,
		1952, 1, 0, 0, 0, 1952, 1954, 1, 0, 0, 0, 1953, 1951, 1, 0, 0, 0, 1954,
		1955, 5, 3, 0, 0, 1955, 1957, 1, 0, 0, 0, 1956, 1945, 1, 0, 0, 0, 1956,
		1957, 1, 0, 0, 0, 1957, 1964, 1, 0, 0, 0, 1958, 1959, 5, 102, 0, 0, 1959,
		1960, 3, 128, 64, 0, 1960, 1961, 5, 198, 0, 0, 1961, 1962, 3, 128, 64,
		0, 1962, 1964, 1, 0, 0, 0, 1963, 1916, 1, 0, 0, 0, 1963, 1922, 1, 0, 0,
		0, 1963, 1929, 1, 0, 0, 0, 1963, 1944, 1, 0, 0, 0, 1963, 1958, 1, 0, 0,
		0, 1964, 1969, 1, 0, 0, 0, 1965, 1966, 10, 6, 0, 0, 1966, 1968, 5, 19,
		0, 0, 1967, 1965, 1, 0, 0, 0, 1968, 1971, 1, 0, 0, 0, 1969, 1967, 1, 0,
		0, 0, 1969, 1970, 1, 0, 0, 0, 1970, 135, 1, 0, 0, 0, 1971, 1969, 1, 0,
		0, 0, 1972, 1975, 5, 250, 0, 0, 1973, 1975, 3, 134, 67, 0, 1974, 1972,
		1, 0, 0, 0, 1974, 1973, 1, 0, 0, 0, 1975, 137, 1, 0, 0, 0, 1976, 1981,
		5, 257, 0, 0, 1977, 1981, 5, 258, 0, 0, 1978, 1981, 5, 259, 0, 0, 1979,
		1981, 3, 172, 86, 0, 1980, 1976, 1, 0, 0, 0, 1980, 1977, 1, 0, 0, 0, 1980,
		1978, 1, 0, 0, 0, 1980, 1979, 1, 0, 0, 0, 1981, 139, 1, 0, 0, 0, 1982,
		1983, 5, 218, 0, 0, 1983, 1984, 3, 100, 50, 0, 1984, 1985, 5, 194, 0, 0,
		1985, 1986, 3, 100, 50, 0, 1986, 141, 1, 0, 0, 0, 1987, 1988, 5, 77, 0,
		0, 1988, 1989, 5, 2, 0, 0, 1989, 1990, 5, 219, 0, 0, 1990, 1991, 3, 102,
		51, 0, 1991, 1992, 5, 3, 0, 0, 1992, 143, 1, 0, 0, 0, 1993, 1994, 5, 147,
		0, 0, 1994, 2005, 5, 2, 0, 0, 1995, 1996, 5, 149, 0, 0, 1996, 1997, 5,
		25, 0, 0, 1997, 2002, 3, 100, 50, 0, 1998, 1999, 5, 4, 0, 0, 1999, 2001,
		3, 100, 50, 0, 2000, 1998, 1, 0, 0, 0, 2001, 2004, 1, 0, 0, 0, 2002, 2000,
		1, 0, 0, 0, 2002, 2003, 1, 0, 0, 0, 2003, 2006, 1, 0, 0, 0, 2004, 2002,
		1, 0, 0, 0, 2005, 1995, 1, 0, 0, 0, 2005, 2006, 1, 0, 0, 0, 2006, 2017,
		1, 0, 0, 0, 2007, 2008, 5, 143, 0, 0, 2008, 2009, 5, 25, 0, 0, 2009, 2014,
		3, 64, 32, 0, 2010, 2011, 5, 4, 0, 0, 2011, 2013, 3, 64, 32, 0, 2012, 2010,
		1, 0, 0, 0, 2013, 2016, 1, 0, 0, 0, 2014, 2012, 1, 0, 0, 0, 2014, 2015,
		1, 0, 0, 0, 2015, 2018, 1, 0, 0, 0, 2016, 2014, 1, 0, 0, 0, 2017, 2007,
		1, 0, 0, 0, 2017, 2018, 1, 0, 0, 0, 2018, 2020, 1, 0, 0, 0, 2019, 2021,
		3, 146, 73, 0, 2020, 2019, 1, 0, 0, 0, 2020, 2021, 1, 0, 0, 0, 2021, 2022,
		1, 0, 0, 0, 2022, 2023, 5, 3, 0, 0, 2023, 145, 1, 0, 0, 0, 2024, 2025,
		5, 157, 0, 0, 2025, 2041, 3, 148, 74, 0, 2026, 2027, 5, 174, 0, 0, 2027,
		2041, 3, 148, 74, 0, 2028, 2029, 5, 157, 0, 0, 2029, 2030, 5, 24, 0, 0,
		2030, 2031, 3, 148, 74, 0, 2031, 2032, 5, 16, 0, 0, 2032, 2033, 3, 148,
		74, 0, 2033, 2041, 1, 0, 0, 0, 2034, 2035, 5, 174, 0, 0, 2035, 2036, 5,
		24, 0, 0, 2036, 2037, 3, 148, 74, 0, 2037, 2038, 5, 16, 0, 0, 2038, 2039,
		3, 148, 74, 0, 2039, 2041, 1, 0, 0, 0, 2040, 2024, 1, 0, 0, 0, 2040, 2026,
		1, 0, 0, 0, 2040, 2028, 1, 0, 0, 0, 2040, 2034, 1, 0, 0, 0, 2041, 147,
		1, 0, 0, 0, 2042, 2043, 5, 205, 0, 0, 2043, 2052, 5, 153, 0, 0, 2044, 2045,
		5, 205, 0, 0, 2045, 2052, 5, 79, 0, 0, 2046, 2047, 5, 43, 0, 0, 2047, 2052,
		5, 173, 0, 0, 2048, 2049, 3, 100, 50, 0, 2049, 2050, 7, 22, 0, 0, 2050,
		2052, 1, 0, 0, 0, 2051, 2042, 1, 0, 0, 0, 2051, 2044, 1, 0, 0, 0, 2051,
		2046, 1, 0, 0, 0, 2051, 2048, 1, 0, 0, 0, 2052, 149, 1, 0, 0, 0, 2053,
		2054, 5, 81, 0, 0, 2054, 2058, 7, 23, 0, 0, 2055, 2056, 5, 202, 0, 0, 2056,
		2058, 7, 24, 0, 0, 2057, 2053, 1, 0, 0, 0, 2057, 2055, 1, 0, 0, 0, 2058,
		151, 1, 0, 0, 0, 2059, 2060, 5, 107, 0, 0, 2060, 2061, 5, 114, 0, 0, 2061,
		2065, 3, 154, 77, 0, 2062, 2063, 5, 158, 0, 0, 2063, 2065, 7, 25, 0, 0,
		2064, 2059, 1, 0, 0, 0, 2064, 2062, 1, 0, 0, 0, 2065, 153, 1, 0, 0, 0,
		2066, 2067, 5, 158, 0, 0, 2067, 2074, 5, 206, 0, 0, 2068, 2069, 5, 158,
		0, 0, 2069, 2074, 5, 37, 0, 0, 2070, 2071, 5, 161, 0, 0, 2071, 2074, 5,
		158, 0, 0, 2072, 2074, 5, 180, 0, 0, 2073, 2066, 1, 0, 0, 0, 2073, 2068,
		1, 0, 0, 0, 2073, 2070, 1, 0, 0, 0, 2073, 2072, 1, 0, 0, 0, 2074, 155,
		1, 0, 0, 0, 2075, 2081, 3, 100, 50, 0, 2076, 2077, 3, 172, 86, 0, 2077,
		2078, 5, 9, 0, 0, 2078, 2079, 3, 100, 50, 0, 2079, 2081, 1, 0, 0, 0, 2080,
		2075, 1, 0, 0, 0, 2080, 2076, 1, 0, 0, 0, 2081, 157, 1, 0, 0, 0, 2082,
		2083, 3, 172, 86, 0, 2083, 2084, 5, 1, 0, 0, 2084, 2085, 3, 172, 86, 0,
		2085, 2088, 1, 0, 0, 0, 2086, 2088, 3, 172, 86, 0, 2087, 2082, 1, 0, 0,
		0, 2087, 2086, 1, 0, 0, 0, 2088, 159, 1, 0, 0, 0, 2089, 2094, 3, 158, 79,
		0, 2090, 2091, 5, 4, 0, 0, 2091, 2093, 3, 158, 79, 0, 2092, 2090, 1, 0,
		0, 0, 2093, 2096, 1, 0, 0, 0, 2094, 2092, 1, 0, 0, 0, 2094, 2095, 1, 0,
		0, 0, 2095, 161, 1, 0, 0, 0, 2096, 2094, 1, 0, 0, 0, 2097, 2103, 5, 179,
		0, 0, 2098, 2103, 5, 57, 0, 0, 2099, 2103, 5, 59, 0, 0, 2100, 2103, 5,
		100, 0, 0, 2101, 2103, 3, 172, 86, 0, 2102, 2097, 1, 0, 0, 0, 2102, 2098,
		1, 0, 0, 0, 2102, 2099, 1, 0, 0, 0, 2102, 2100, 1, 0, 0, 0, 2102, 2101,
		1, 0, 0, 0, 2103, 163, 1, 0, 0, 0, 2104, 2109, 3, 172, 86, 0, 2105, 2106,
		5, 1, 0, 0, 2106, 2108, 3, 172, 86, 0, 2107, 2105, 1, 0, 0, 0, 2108, 2111,
		1, 0, 0, 0, 2109, 2107, 1, 0, 0, 0, 2109, 2110, 1, 0, 0, 0, 2110, 165,
		1, 0, 0, 0, 2111, 2109, 1, 0, 0, 0, 2112, 2116, 3, 168, 84, 0, 2113, 2116,
		5, 49, 0, 0, 2114, 2116, 5, 46, 0, 0, 2115, 2112, 1, 0, 0, 0, 2115, 2113,
		1, 0, 0, 0, 2115, 2114, 1, 0, 0, 0, 2116, 167, 1, 0, 0, 0, 2117, 2123,
		3, 172, 86, 0, 2118, 2119, 5, 210, 0, 0, 2119, 2123, 3, 172, 86, 0, 2120,
		2121, 5, 169, 0, 0, 2121, 2123, 3, 172, 86, 0, 2122, 2117, 1, 0, 0, 0,
		2122, 2118, 1, 0, 0, 0, 2122, 2120, 1, 0, 0, 0, 2123, 169, 1, 0, 0, 0,
		2124, 2129, 3, 172, 86, 0, 2125, 2126, 5, 4, 0, 0, 2126, 2128, 3, 172,
		86, 0, 2127, 2125, 1, 0, 0, 0, 2128, 2131, 1, 0, 0, 0, 2129, 2127, 1, 0,
		0, 0, 2129, 2130, 1, 0, 0, 0, 2130, 171, 1, 0, 0, 0, 2131, 2129, 1, 0,
		0, 0, 2132, 2138, 5, 253, 0, 0, 2133, 2138, 5, 255, 0, 0, 2134, 2138, 3,
		176, 88, 0, 2135, 2138, 5, 256, 0, 0, 2136, 2138, 5, 254, 0, 0, 2137, 2132,
		1, 0, 0, 0, 2137, 2133, 1, 0, 0, 0, 2137, 2134, 1, 0, 0, 0, 2137, 2135,
		1, 0, 0, 0, 2137, 2136, 1, 0, 0, 0, 2138, 173, 1, 0, 0, 0, 2139, 2141,
		5, 242, 0, 0, 2140, 2139, 1, 0, 0, 0, 2140, 2141, 1, 0, 0, 0, 2141, 2142,
		1, 0, 0, 0, 2142, 2152, 5, 251, 0, 0, 2143, 2145, 5, 242, 0, 0, 2144, 2143,
		1, 0, 0, 0, 2144, 2145, 1, 0, 0, 0, 2145, 2146, 1, 0, 0, 0, 2146, 2152,
		5, 252, 0, 0, 2147, 2149, 5, 242, 0, 0, 2148, 2147, 1, 0, 0, 0, 2148, 2149,
		1, 0, 0, 0, 2149, 2150, 1, 0, 0, 0, 2150, 2152, 5, 250, 0, 0, 2151, 2140,
		1, 0, 0, 0, 2151, 2144, 1, 0, 0, 0, 2151, 2148, 1, 0, 0, 0, 2152, 175,
		1, 0, 0, 0, 2153, 2154, 7, 26, 0, 0, 2154, 177, 1, 0, 0, 0, 273, 210, 215,
		221, 225, 239, 243, 247, 251, 259, 263, 266, 273, 282, 288, 292, 298, 309,
		313, 319, 324, 329, 336, 345, 353, 361, 367, 374, 381, 388, 398, 402, 408,
		413, 419, 430, 437, 440, 446, 453, 457, 466, 474, 490, 526, 531, 537, 554,
		565, 568, 578, 591, 597, 602, 608, 617, 623, 630, 638, 643, 647, 655, 661,
		668, 673, 677, 687, 690, 694, 697, 705, 710, 718, 736, 742, 744, 752, 755,
		761, 763, 769, 793, 798, 805, 817, 819, 839, 842, 846, 850, 868, 871, 884,
		887, 890, 894, 904, 907, 923, 925, 929, 932, 941, 944, 950, 953, 958, 960,
		962, 969, 977, 983, 990, 995, 1001, 1005, 1009, 1013, 1019, 1027, 1030,
		1053, 1061, 1070, 1077, 1090, 1105, 1112, 1116, 1124, 1131, 1142, 1154,
		1157, 1162, 1164, 1171, 1177, 1179, 1187, 1193, 1196, 1198, 1210, 1217,
		1221, 1225, 1229, 1236, 1245, 1248, 1252, 1257, 1261, 1264, 1271, 1282,
		1285, 1295, 1298, 1309, 1314, 1322, 1325, 1329, 1336, 1339, 1345, 1356,
		1359, 1366, 1385, 1389, 1393, 1397, 1401, 1405, 1407, 1418, 1423, 1432,
		1438, 1442, 1444, 1452, 1469, 1475, 1486, 1493, 1497, 1505, 1507, 1520,
		1528, 1537, 1543, 1551, 1557, 1561, 1566, 1571, 1577, 1591, 1593, 1622,
		1633, 1643, 1646, 1651, 1658, 1661, 1670, 1673, 1677, 1680, 1683, 1695,
		1698, 1717, 1721, 1729, 1733, 1758, 1761, 1770, 1776, 1782, 1788, 1799,
		1808, 1830, 1833, 1836, 1846, 1848, 1855, 1857, 1863, 1871, 1882, 1891,
		1897, 1909, 1912, 1939, 1951, 1956, 1963, 1969, 1974, 1980, 2002, 2005,
		2014, 2017, 2020, 2040, 2051, 2057, 2064, 2073, 2080, 2087, 2094, 2102,
		2109, 2115, 2122, 2129, 2137, 2140, 2144, 2148, 2151,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// SqlBaseParserInit initializes any static state used to implement SqlBaseParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSqlBaseParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SqlBaseParserInit() {
	staticData := &SqlBaseParserStaticData
	staticData.once.Do(sqlbaseParserInit)
}

// NewSqlBaseParser produces a new parser instance for the optional input antlr.TokenStream.
func NewSqlBaseParser(input antlr.TokenStream) *SqlBaseParser {
	SqlBaseParserInit()
	this := new(SqlBaseParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &SqlBaseParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "SqlBase.g4"

	return this
}

// SqlBaseParser tokens.
const (
	SqlBaseParserEOF                      = antlr.TokenEOF
	SqlBaseParserT__0                     = 1
	SqlBaseParserT__1                     = 2
	SqlBaseParserT__2                     = 3
	SqlBaseParserT__3                     = 4
	SqlBaseParserT__4                     = 5
	SqlBaseParserT__5                     = 6
	SqlBaseParserT__6                     = 7
	SqlBaseParserT__7                     = 8
	SqlBaseParserT__8                     = 9
	SqlBaseParserADD                      = 10
	SqlBaseParserADMIN                    = 11
	SqlBaseParserAGGREGATIONS             = 12
	SqlBaseParserALL                      = 13
	SqlBaseParserALTER                    = 14
	SqlBaseParserANALYZE                  = 15
	SqlBaseParserAND                      = 16
	SqlBaseParserAND_WAIT                 = 17
	SqlBaseParserANY                      = 18
	SqlBaseParserARRAY                    = 19
	SqlBaseParserAS                       = 20
	SqlBaseParserASC                      = 21
	SqlBaseParserAT                       = 22
	SqlBaseParserBERNOULLI                = 23
	SqlBaseParserBETWEEN                  = 24
	SqlBaseParserBY                       = 25
	SqlBaseParserCACHE                    = 26
	SqlBaseParserCALL                     = 27
	SqlBaseParserCALLED                   = 28
	SqlBaseParserCASCADE                  = 29
	SqlBaseParserCASE                     = 30
	SqlBaseParserCAST                     = 31
	SqlBaseParserCATALOGS                 = 32
	SqlBaseParserCOLUMN                   = 33
	SqlBaseParserCOLUMNS                  = 34
	SqlBaseParserCOMMENT                  = 35
	SqlBaseParserCOMMIT                   = 36
	SqlBaseParserCOMMITTED                = 37
	SqlBaseParserCONSTRAINT               = 38
	SqlBaseParserCREATE                   = 39
	SqlBaseParserCROSS                    = 40
	SqlBaseParserCUBE                     = 41
	SqlBaseParserCUBES                    = 42
	SqlBaseParserCURRENT                  = 43
	SqlBaseParserCURRENT_DATE             = 44
	SqlBaseParserCURRENT_PATH             = 45
	SqlBaseParserCURRENT_ROLE             = 46
	SqlBaseParserCURRENT_TIME             = 47
	SqlBaseParserCURRENT_TIMESTAMP        = 48
	SqlBaseParserCURRENT_USER             = 49
	SqlBaseParserDATA                     = 50
	SqlBaseParserDATABASE                 = 51
	SqlBaseParserDATABASES                = 52
	SqlBaseParserDATE                     = 53
	SqlBaseParserDAY                      = 54
	SqlBaseParserDEALLOCATE               = 55
	SqlBaseParserDEFINER                  = 56
	SqlBaseParserDELETE                   = 57
	SqlBaseParserDETERMINISTIC            = 58
	SqlBaseParserUPDATE                   = 59
	SqlBaseParserDESC                     = 60
	SqlBaseParserDESCRIBE                 = 61
	SqlBaseParserDISTINCT                 = 62
	SqlBaseParserDISTRIBUTED              = 63
	SqlBaseParserDROP                     = 64
	SqlBaseParserELSE                     = 65
	SqlBaseParserEND                      = 66
	SqlBaseParserESCAPE                   = 67
	SqlBaseParserEXCEPT                   = 68
	SqlBaseParserEXCLUDING                = 69
	SqlBaseParserEXECUTE                  = 70
	SqlBaseParserEXISTS                   = 71
	SqlBaseParserEXPLAIN                  = 72
	SqlBaseParserEXTRACT                  = 73
	SqlBaseParserEXTERNAL                 = 74
	SqlBaseParserFALSE                    = 75
	SqlBaseParserFETCH                    = 76
	SqlBaseParserFILTER                   = 77
	SqlBaseParserFIRST                    = 78
	SqlBaseParserFOLLOWING                = 79
	SqlBaseParserFOR                      = 80
	SqlBaseParserFORMAT                   = 81
	SqlBaseParserFROM                     = 82
	SqlBaseParserFULL                     = 83
	SqlBaseParserFUNCTION                 = 84
	SqlBaseParserFUNCPROPERTIES           = 85
	SqlBaseParserFUNCTIONS                = 86
	SqlBaseParserGRANT                    = 87
	SqlBaseParserGRANTED                  = 88
	SqlBaseParserGRANTS                   = 89
	SqlBaseParserGRAPHVIZ                 = 90
	SqlBaseParserGROUP                    = 91
	SqlBaseParserGROUPING                 = 92
	SqlBaseParserHAVING                   = 93
	SqlBaseParserHOUR                     = 94
	SqlBaseParserIF                       = 95
	SqlBaseParserIN                       = 96
	SqlBaseParserINCLUDING                = 97
	SqlBaseParserINNER                    = 98
	SqlBaseParserINPUT                    = 99
	SqlBaseParserINSERT                   = 100
	SqlBaseParserINTERSECT                = 101
	SqlBaseParserINTERVAL                 = 102
	SqlBaseParserINTO                     = 103
	SqlBaseParserINVOKER                  = 104
	SqlBaseParserIO                       = 105
	SqlBaseParserIS                       = 106
	SqlBaseParserISOLATION                = 107
	SqlBaseParserJSON                     = 108
	SqlBaseParserJOIN                     = 109
	SqlBaseParserLANGUAGE                 = 110
	SqlBaseParserLAST                     = 111
	SqlBaseParserLATERAL                  = 112
	SqlBaseParserLEFT                     = 113
	SqlBaseParserLEVEL                    = 114
	SqlBaseParserLIKE                     = 115
	SqlBaseParserLIMIT                    = 116
	SqlBaseParserLOCALTIME                = 117
	SqlBaseParserLOCALTIMESTAMP           = 118
	SqlBaseParserLOGICAL                  = 119
	SqlBaseParserMAP                      = 120
	SqlBaseParserUNIFY                    = 121
	SqlBaseParserMINUTE                   = 122
	SqlBaseParserMONTH                    = 123
	SqlBaseParserNAME                     = 124
	SqlBaseParserNATURAL                  = 125
	SqlBaseParserNEXT                     = 126
	SqlBaseParserNFC                      = 127
	SqlBaseParserNFD                      = 128
	SqlBaseParserNFKC                     = 129
	SqlBaseParserNFKD                     = 130
	SqlBaseParserNO                       = 131
	SqlBaseParserNONE                     = 132
	SqlBaseParserNORMALIZE                = 133
	SqlBaseParserNOT                      = 134
	SqlBaseParserNULL                     = 135
	SqlBaseParserNULLIF                   = 136
	SqlBaseParserNULLS                    = 137
	SqlBaseParserOFFSET                   = 138
	SqlBaseParserON                       = 139
	SqlBaseParserONLY                     = 140
	SqlBaseParserOPTION                   = 141
	SqlBaseParserOR                       = 142
	SqlBaseParserORDER                    = 143
	SqlBaseParserORDINALITY               = 144
	SqlBaseParserOUTER                    = 145
	SqlBaseParserOUTPUT                   = 146
	SqlBaseParserOVER                     = 147
	SqlBaseParserOVERWRITE                = 148
	SqlBaseParserPARTITION                = 149
	SqlBaseParserPARTITIONS               = 150
	SqlBaseParserPATH                     = 151
	SqlBaseParserPOSITION                 = 152
	SqlBaseParserPRECEDING                = 153
	SqlBaseParserPREPARE                  = 154
	SqlBaseParserPRIVILEGES               = 155
	SqlBaseParserPROPERTIES               = 156
	SqlBaseParserRANGE                    = 157
	SqlBaseParserREAD                     = 158
	SqlBaseParserRECURSIVE                = 159
	SqlBaseParserRENAME                   = 160
	SqlBaseParserREPEATABLE               = 161
	SqlBaseParserREPLACE                  = 162
	SqlBaseParserRESET                    = 163
	SqlBaseParserRESTRICT                 = 164
	SqlBaseParserRETURN                   = 165
	SqlBaseParserRETURNS                  = 166
	SqlBaseParserREVOKE                   = 167
	SqlBaseParserRIGHT                    = 168
	SqlBaseParserROLE                     = 169
	SqlBaseParserROLES                    = 170
	SqlBaseParserROLLBACK                 = 171
	SqlBaseParserROLLUP                   = 172
	SqlBaseParserROW                      = 173
	SqlBaseParserROWS                     = 174
	SqlBaseParserSCHEMA                   = 175
	SqlBaseParserSCHEMAS                  = 176
	SqlBaseParserSECOND                   = 177
	SqlBaseParserSECURITY                 = 178
	SqlBaseParserSELECT                   = 179
	SqlBaseParserSERIALIZABLE             = 180
	SqlBaseParserSESSION                  = 181
	SqlBaseParserSET                      = 182
	SqlBaseParserSETS                     = 183
	SqlBaseParserSHOW                     = 184
	SqlBaseParserSOME                     = 185
	SqlBaseParserSTART                    = 186
	SqlBaseParserSTATS                    = 187
	SqlBaseParserSUBSTRING                = 188
	SqlBaseParserSYSTEM                   = 189
	SqlBaseParserTABLE                    = 190
	SqlBaseParserTABLES                   = 191
	SqlBaseParserTABLESAMPLE              = 192
	SqlBaseParserTEXT                     = 193
	SqlBaseParserTHEN                     = 194
	SqlBaseParserTIES                     = 195
	SqlBaseParserTIME                     = 196
	SqlBaseParserTIMESTAMP                = 197
	SqlBaseParserTO                       = 198
	SqlBaseParserTRANSACTION              = 199
	SqlBaseParserTRUE                     = 200
	SqlBaseParserTRY_CAST                 = 201
	SqlBaseParserTYPE                     = 202
	SqlBaseParserTRUNCATE                 = 203
	SqlBaseParserUESCAPE                  = 204
	SqlBaseParserUNBOUNDED                = 205
	SqlBaseParserUNCOMMITTED              = 206
	SqlBaseParserUNION                    = 207
	SqlBaseParserUNNEST                   = 208
	SqlBaseParserUSE                      = 209
	SqlBaseParserUSER                     = 210
	SqlBaseParserUSING                    = 211
	SqlBaseParserVACUUM                   = 212
	SqlBaseParserVALIDATE                 = 213
	SqlBaseParserVALUES                   = 214
	SqlBaseParserVERBOSE                  = 215
	SqlBaseParserVIEW                     = 216
	SqlBaseParserVIEWS                    = 217
	SqlBaseParserWHEN                     = 218
	SqlBaseParserWHERE                    = 219
	SqlBaseParserWITH                     = 220
	SqlBaseParserWORK                     = 221
	SqlBaseParserWRITE                    = 222
	SqlBaseParserYEAR                     = 223
	SqlBaseParserZONE                     = 224
	SqlBaseParserINDEX                    = 225
	SqlBaseParserBITMAP                   = 226
	SqlBaseParserBLOOM                    = 227
	SqlBaseParserMINMAX                   = 228
	SqlBaseParserBTREE                    = 229
	SqlBaseParserREFRESH                  = 230
	SqlBaseParserMETA                     = 231
	SqlBaseParserRELOAD                   = 232
	SqlBaseParserPRIMARY                  = 233
	SqlBaseParserKEY                      = 234
	SqlBaseParserEQ                       = 235
	SqlBaseParserNEQ                      = 236
	SqlBaseParserLT                       = 237
	SqlBaseParserLTE                      = 238
	SqlBaseParserGT                       = 239
	SqlBaseParserGTE                      = 240
	SqlBaseParserPLUS                     = 241
	SqlBaseParserMINUS                    = 242
	SqlBaseParserASTERISK                 = 243
	SqlBaseParserSLASH                    = 244
	SqlBaseParserPERCENT                  = 245
	SqlBaseParserCONCAT                   = 246
	SqlBaseParserSTRING                   = 247
	SqlBaseParserUNICODE_STRING           = 248
	SqlBaseParserBINARY_LITERAL           = 249
	SqlBaseParserINTEGER_VALUE            = 250
	SqlBaseParserDECIMAL_VALUE            = 251
	SqlBaseParserDOUBLE_VALUE             = 252
	SqlBaseParserIDENTIFIER               = 253
	SqlBaseParserDIGIT_IDENTIFIER         = 254
	SqlBaseParserQUOTED_IDENTIFIER        = 255
	SqlBaseParserBACKQUOTED_IDENTIFIER    = 256
	SqlBaseParserTIME_WITH_TIME_ZONE      = 257
	SqlBaseParserTIMESTAMP_WITH_TIME_ZONE = 258
	SqlBaseParserDOUBLE_PRECISION         = 259
	SqlBaseParserSIMPLE_COMMENT           = 260
	SqlBaseParserBRACKETED_COMMENT        = 261
	SqlBaseParserWS                       = 262
	SqlBaseParserUNRECOGNIZED             = 263
	SqlBaseParserDELIMITER                = 264
	SqlBaseParserMATERIALIZED             = 265
	SqlBaseParserIGNORE                   = 266
	SqlBaseParserRESPECT                  = 267
)

// SqlBaseParser rules.
const (
	SqlBaseParserRULE_singleStatement             = 0
	SqlBaseParserRULE_standaloneExpression        = 1
	SqlBaseParserRULE_standalonePathSpecification = 2
	SqlBaseParserRULE_standaloneRoutineBody       = 3
	SqlBaseParserRULE_statement                   = 4
	SqlBaseParserRULE_assignmentList              = 5
	SqlBaseParserRULE_assignmentItem              = 6
	SqlBaseParserRULE_query                       = 7
	SqlBaseParserRULE_with                        = 8
	SqlBaseParserRULE_tableElement                = 9
	SqlBaseParserRULE_columnDefinition            = 10
	SqlBaseParserRULE_likeClause                  = 11
	SqlBaseParserRULE_cubeProperties              = 12
	SqlBaseParserRULE_cubeProperty                = 13
	SqlBaseParserRULE_properties                  = 14
	SqlBaseParserRULE_propertyAssignments         = 15
	SqlBaseParserRULE_property                    = 16
	SqlBaseParserRULE_functionProperties          = 17
	SqlBaseParserRULE_functionProperty            = 18
	SqlBaseParserRULE_sqlParameterDeclaration     = 19
	SqlBaseParserRULE_routineCharacteristics      = 20
	SqlBaseParserRULE_routineCharacteristic       = 21
	SqlBaseParserRULE_routineBody                 = 22
	SqlBaseParserRULE_returnStatement             = 23
	SqlBaseParserRULE_externalBodyReference       = 24
	SqlBaseParserRULE_language                    = 25
	SqlBaseParserRULE_determinism                 = 26
	SqlBaseParserRULE_nullCallClause              = 27
	SqlBaseParserRULE_externalRoutineName         = 28
	SqlBaseParserRULE_queryNoWith                 = 29
	SqlBaseParserRULE_queryTerm                   = 30
	SqlBaseParserRULE_queryPrimary                = 31
	SqlBaseParserRULE_sortItem                    = 32
	SqlBaseParserRULE_querySpecification          = 33
	SqlBaseParserRULE_groupBy                     = 34
	SqlBaseParserRULE_groupingElement             = 35
	SqlBaseParserRULE_groupingSet                 = 36
	SqlBaseParserRULE_cubeGroup                   = 37
	SqlBaseParserRULE_sourceFilter                = 38
	SqlBaseParserRULE_namedQuery                  = 39
	SqlBaseParserRULE_setQuantifier               = 40
	SqlBaseParserRULE_selectItem                  = 41
	SqlBaseParserRULE_relation                    = 42
	SqlBaseParserRULE_joinType                    = 43
	SqlBaseParserRULE_joinCriteria                = 44
	SqlBaseParserRULE_sampledRelation             = 45
	SqlBaseParserRULE_sampleType                  = 46
	SqlBaseParserRULE_aliasedRelation             = 47
	SqlBaseParserRULE_columnAliases               = 48
	SqlBaseParserRULE_relationPrimary             = 49
	SqlBaseParserRULE_expression                  = 50
	SqlBaseParserRULE_booleanExpression           = 51
	SqlBaseParserRULE_predicate                   = 52
	SqlBaseParserRULE_valueExpression             = 53
	SqlBaseParserRULE_primaryExpression           = 54
	SqlBaseParserRULE_string                      = 55
	SqlBaseParserRULE_nullTreatment               = 56
	SqlBaseParserRULE_timeZoneSpecifier           = 57
	SqlBaseParserRULE_comparisonOperator          = 58
	SqlBaseParserRULE_comparisonQuantifier        = 59
	SqlBaseParserRULE_aggregations                = 60
	SqlBaseParserRULE_booleanValue                = 61
	SqlBaseParserRULE_indexType                   = 62
	SqlBaseParserRULE_interval                    = 63
	SqlBaseParserRULE_intervalField               = 64
	SqlBaseParserRULE_normalForm                  = 65
	SqlBaseParserRULE_types                       = 66
	SqlBaseParserRULE_type                        = 67
	SqlBaseParserRULE_typeParameter               = 68
	SqlBaseParserRULE_baseType                    = 69
	SqlBaseParserRULE_whenClause                  = 70
	SqlBaseParserRULE_filter                      = 71
	SqlBaseParserRULE_over                        = 72
	SqlBaseParserRULE_windowFrame                 = 73
	SqlBaseParserRULE_frameBound                  = 74
	SqlBaseParserRULE_explainOption               = 75
	SqlBaseParserRULE_transactionMode             = 76
	SqlBaseParserRULE_levelOfIsolation            = 77
	SqlBaseParserRULE_callArgument                = 78
	SqlBaseParserRULE_pathElement                 = 79
	SqlBaseParserRULE_pathSpecification           = 80
	SqlBaseParserRULE_privilege                   = 81
	SqlBaseParserRULE_qualifiedName               = 82
	SqlBaseParserRULE_grantor                     = 83
	SqlBaseParserRULE_principal                   = 84
	SqlBaseParserRULE_roles                       = 85
	SqlBaseParserRULE_identifier                  = 86
	SqlBaseParserRULE_number                      = 87
	SqlBaseParserRULE_nonReserved                 = 88
)

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	EOF() antlr.TerminalNode

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (p *SqlBaseParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SqlBaseParserRULE_singleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(178)
		p.Statement()
	}
	{
		p.SetState(179)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandaloneExpressionContext is an interface to support dynamic dispatch.
type IStandaloneExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	EOF() antlr.TerminalNode

	// IsStandaloneExpressionContext differentiates from other interfaces.
	IsStandaloneExpressionContext()
}

type StandaloneExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneExpressionContext() *StandaloneExpressionContext {
	var p = new(StandaloneExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_standaloneExpression
	return p
}

func InitEmptyStandaloneExpressionContext(p *StandaloneExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_standaloneExpression
}

func (*StandaloneExpressionContext) IsStandaloneExpressionContext() {}

func NewStandaloneExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneExpressionContext {
	var p = new(StandaloneExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_standaloneExpression

	return p
}

func (s *StandaloneExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StandaloneExpressionContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *StandaloneExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStandaloneExpression(s)
	}
}

func (s *StandaloneExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStandaloneExpression(s)
	}
}

func (p *SqlBaseParser) StandaloneExpression() (localctx IStandaloneExpressionContext) {
	localctx = NewStandaloneExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SqlBaseParserRULE_standaloneExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(181)
		p.Expression()
	}
	{
		p.SetState(182)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandalonePathSpecificationContext is an interface to support dynamic dispatch.
type IStandalonePathSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PathSpecification() IPathSpecificationContext
	EOF() antlr.TerminalNode

	// IsStandalonePathSpecificationContext differentiates from other interfaces.
	IsStandalonePathSpecificationContext()
}

type StandalonePathSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandalonePathSpecificationContext() *StandalonePathSpecificationContext {
	var p = new(StandalonePathSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_standalonePathSpecification
	return p
}

func InitEmptyStandalonePathSpecificationContext(p *StandalonePathSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_standalonePathSpecification
}

func (*StandalonePathSpecificationContext) IsStandalonePathSpecificationContext() {}

func NewStandalonePathSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandalonePathSpecificationContext {
	var p = new(StandalonePathSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_standalonePathSpecification

	return p
}

func (s *StandalonePathSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *StandalonePathSpecificationContext) PathSpecification() IPathSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathSpecificationContext)
}

func (s *StandalonePathSpecificationContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *StandalonePathSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandalonePathSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandalonePathSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStandalonePathSpecification(s)
	}
}

func (s *StandalonePathSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStandalonePathSpecification(s)
	}
}

func (p *SqlBaseParser) StandalonePathSpecification() (localctx IStandalonePathSpecificationContext) {
	localctx = NewStandalonePathSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SqlBaseParserRULE_standalonePathSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(184)
		p.PathSpecification()
	}
	{
		p.SetState(185)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandaloneRoutineBodyContext is an interface to support dynamic dispatch.
type IStandaloneRoutineBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoutineBody() IRoutineBodyContext
	EOF() antlr.TerminalNode

	// IsStandaloneRoutineBodyContext differentiates from other interfaces.
	IsStandaloneRoutineBodyContext()
}

type StandaloneRoutineBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneRoutineBodyContext() *StandaloneRoutineBodyContext {
	var p = new(StandaloneRoutineBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_standaloneRoutineBody
	return p
}

func InitEmptyStandaloneRoutineBodyContext(p *StandaloneRoutineBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_standaloneRoutineBody
}

func (*StandaloneRoutineBodyContext) IsStandaloneRoutineBodyContext() {}

func NewStandaloneRoutineBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneRoutineBodyContext {
	var p = new(StandaloneRoutineBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_standaloneRoutineBody

	return p
}

func (s *StandaloneRoutineBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneRoutineBodyContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *StandaloneRoutineBodyContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *StandaloneRoutineBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneRoutineBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneRoutineBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStandaloneRoutineBody(s)
	}
}

func (s *StandaloneRoutineBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStandaloneRoutineBody(s)
	}
}

func (p *SqlBaseParser) StandaloneRoutineBody() (localctx IStandaloneRoutineBodyContext) {
	localctx = NewStandaloneRoutineBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SqlBaseParserRULE_standaloneRoutineBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(187)
		p.RoutineBody()
	}
	{
		p.SetState(188)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyAll(ctx *StatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InsertCubeContext struct {
	StatementContext
	cubeName IQualifiedNameContext
}

func NewInsertCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertCubeContext {
	var p = new(InsertCubeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *InsertCubeContext) GetCubeName() IQualifiedNameContext { return s.cubeName }

func (s *InsertCubeContext) SetCubeName(v IQualifiedNameContext) { s.cubeName = v }

func (s *InsertCubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertCubeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *InsertCubeContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTO, 0)
}

func (s *InsertCubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *InsertCubeContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *InsertCubeContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *InsertCubeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InsertCubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInsertCube(s)
	}
}

func (s *InsertCubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInsertCube(s)
	}
}

type ExplainContext struct {
	StatementContext
}

func NewExplainContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainContext {
	var p = new(ExplainContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPLAIN, 0)
}

func (s *ExplainContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExplainContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANALYZE, 0)
}

func (s *ExplainContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVERBOSE, 0)
}

func (s *ExplainContext) AllExplainOption() []IExplainOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExplainOptionContext); ok {
			len++
		}
	}

	tst := make([]IExplainOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExplainOptionContext); ok {
			tst[i] = t.(IExplainOptionContext)
			i++
		}
	}

	return tst
}

func (s *ExplainContext) ExplainOption(i int) IExplainOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainOptionContext)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExplain(s)
	}
}

type ShowIndexContext struct {
	StatementContext
}

func NewShowIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexContext {
	var p = new(ShowIndexContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEX, 0)
}

func (s *ShowIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *ShowIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *ShowIndexContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowIndex(s)
	}
}

func (s *ShowIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowIndex(s)
	}
}

type PrepareContext struct {
	StatementContext
}

func NewPrepareContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrepareContext {
	var p = new(PrepareContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *PrepareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPREPARE, 0)
}

func (s *PrepareContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrepareContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *PrepareContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *PrepareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPrepare(s)
	}
}

func (s *PrepareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPrepare(s)
	}
}

type DropCacheContext struct {
	StatementContext
}

func NewDropCacheContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCacheContext {
	var p = new(DropCacheContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropCacheContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCacheContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropCacheContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCACHE, 0)
}

func (s *DropCacheContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropCacheContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropCacheContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropCacheContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *DropCacheContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *DropCacheContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropCache(s)
	}
}

func (s *DropCacheContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropCache(s)
	}
}

type SetMaterializedViewPropertiesContext struct {
	StatementContext
}

func NewSetMaterializedViewPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetMaterializedViewPropertiesContext {
	var p = new(SetMaterializedViewPropertiesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetMaterializedViewPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetMaterializedViewPropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *SetMaterializedViewPropertiesContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMATERIALIZED, 0)
}

func (s *SetMaterializedViewPropertiesContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *SetMaterializedViewPropertiesContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetMaterializedViewPropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetMaterializedViewPropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, 0)
}

func (s *SetMaterializedViewPropertiesContext) PropertyAssignments() IPropertyAssignmentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyAssignmentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentsContext)
}

func (s *SetMaterializedViewPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetMaterializedViewProperties(s)
	}
}

func (s *SetMaterializedViewPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetMaterializedViewProperties(s)
	}
}

type UseContext struct {
	StatementContext
	schema  IIdentifierContext
	catalog IIdentifierContext
	cluster IIdentifierContext
}

func NewUseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseContext {
	var p = new(UseContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *UseContext) GetSchema() IIdentifierContext { return s.schema }

func (s *UseContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *UseContext) GetCluster() IIdentifierContext { return s.cluster }

func (s *UseContext) SetSchema(v IIdentifierContext) { s.schema = v }

func (s *UseContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *UseContext) SetCluster(v IIdentifierContext) { s.cluster = v }

func (s *UseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseContext) USE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSE, 0)
}

func (s *UseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUse(s)
	}
}

func (s *UseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUse(s)
	}
}

type RefreshMetadataCacheContext struct {
	StatementContext
	cluster IIdentifierContext
	catalog IIdentifierContext
}

func NewRefreshMetadataCacheContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshMetadataCacheContext {
	var p = new(RefreshMetadataCacheContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RefreshMetadataCacheContext) GetCluster() IIdentifierContext { return s.cluster }

func (s *RefreshMetadataCacheContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *RefreshMetadataCacheContext) SetCluster(v IIdentifierContext) { s.cluster = v }

func (s *RefreshMetadataCacheContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *RefreshMetadataCacheContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMetadataCacheContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREFRESH, 0)
}

func (s *RefreshMetadataCacheContext) META() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMETA, 0)
}

func (s *RefreshMetadataCacheContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCACHE, 0)
}

func (s *RefreshMetadataCacheContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *RefreshMetadataCacheContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RefreshMetadataCacheContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RefreshMetadataCacheContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRefreshMetadataCache(s)
	}
}

func (s *RefreshMetadataCacheContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRefreshMetadataCache(s)
	}
}

type DeallocateContext struct {
	StatementContext
}

func NewDeallocateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeallocateContext {
	var p = new(DeallocateContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DeallocateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocateContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEALLOCATE, 0)
}

func (s *DeallocateContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPREPARE, 0)
}

func (s *DeallocateContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DeallocateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDeallocate(s)
	}
}

func (s *DeallocateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDeallocate(s)
	}
}

type RenameTableContext struct {
	StatementContext
	from IQualifiedNameContext
	to   IQualifiedNameContext
}

func NewRenameTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameTableContext {
	var p = new(RenameTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RenameTableContext) GetFrom() IQualifiedNameContext { return s.from }

func (s *RenameTableContext) GetTo() IQualifiedNameContext { return s.to }

func (s *RenameTableContext) SetFrom(v IQualifiedNameContext) { s.from = v }

func (s *RenameTableContext) SetTo(v IQualifiedNameContext) { s.to = v }

func (s *RenameTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *RenameTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *RenameTableContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *RenameTableContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *RenameTableContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameTableContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRenameTable(s)
	}
}

func (s *RenameTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRenameTable(s)
	}
}

type CommitContext struct {
	StatementContext
}

func NewCommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommitContext {
	var p = new(CommitContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMIT, 0)
}

func (s *CommitContext) WORK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWORK, 0)
}

func (s *CommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCommit(s)
	}
}

func (s *CommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCommit(s)
	}
}

type CreateRoleContext struct {
	StatementContext
	name IIdentifierContext
}

func NewCreateRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRoleContext {
	var p = new(CreateRoleContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateRoleContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRoleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *CreateRoleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoleContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateRoleContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADMIN, 0)
}

func (s *CreateRoleContext) Grantor() IGrantorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantorContext)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

type DropColumnContext struct {
	StatementContext
	tableName IQualifiedNameContext
	column    IQualifiedNameContext
}

func NewDropColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropColumnContext {
	var p = new(DropColumnContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *DropColumnContext) GetColumn() IQualifiedNameContext { return s.column }

func (s *DropColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *DropColumnContext) SetColumn(v IQualifiedNameContext) { s.column = v }

func (s *DropColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *DropColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *DropColumnContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *DropColumnContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *DropColumnContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropColumn(s)
	}
}

func (s *DropColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropColumn(s)
	}
}

type DropViewContext struct {
	StatementContext
}

func NewDropViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropViewContext {
	var p = new(DropViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *DropViewContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropViewContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropView(s)
	}
}

type ShowTablesContext struct {
	StatementContext
	pattern IStringContext
	escape  IStringContext
}

func NewShowTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTablesContext {
	var p = new(ShowTablesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowTablesContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTablesContext) GetEscape() IStringContext { return s.escape }

func (s *ShowTablesContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTablesContext) SetEscape(v IStringContext) { s.escape = v }

func (s *ShowTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLES, 0)
}

func (s *ShowTablesContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTablesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowTablesContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ShowTablesContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTablesContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowTables(s)
	}
}

func (s *ShowTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowTables(s)
	}
}

type DropIndexContext struct {
	StatementContext
	indexName IQualifiedNameContext
}

func NewDropIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexContext {
	var p = new(DropIndexContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropIndexContext) GetIndexName() IQualifiedNameContext { return s.indexName }

func (s *DropIndexContext) SetIndexName(v IQualifiedNameContext) { s.indexName = v }

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEX, 0)
}

func (s *DropIndexContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropIndexContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *DropIndexContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

type UpdateIndexContext struct {
	StatementContext
}

func NewUpdateIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UpdateIndexContext {
	var p = new(UpdateIndexContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *UpdateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateIndexContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUPDATE, 0)
}

func (s *UpdateIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEX, 0)
}

func (s *UpdateIndexContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UpdateIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *UpdateIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *UpdateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUpdateIndex(s)
	}
}

func (s *UpdateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUpdateIndex(s)
	}
}

type ShowCatalogsContext struct {
	StatementContext
	pattern IStringContext
}

func NewShowCatalogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogsContext {
	var p = new(ShowCatalogsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCatalogsContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCatalogsContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCatalogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCatalogsContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCATALOGS, 0)
}

func (s *ShowCatalogsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowCatalogsContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCatalogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowCatalogs(s)
	}
}

func (s *ShowCatalogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowCatalogs(s)
	}
}

type ShowRolesContext struct {
	StatementContext
}

func NewShowRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRolesContext {
	var p = new(ShowRolesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowRolesContext) ROLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLES, 0)
}

func (s *ShowRolesContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT, 0)
}

func (s *ShowRolesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRolesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowRolesContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowRoles(s)
	}
}

func (s *ShowRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowRoles(s)
	}
}

type RenameIndexContext struct {
	StatementContext
	from IQualifiedNameContext
	to   IQualifiedNameContext
}

func NewRenameIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameIndexContext {
	var p = new(RenameIndexContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RenameIndexContext) GetFrom() IQualifiedNameContext { return s.from }

func (s *RenameIndexContext) GetTo() IQualifiedNameContext { return s.to }

func (s *RenameIndexContext) SetFrom(v IQualifiedNameContext) { s.from = v }

func (s *RenameIndexContext) SetTo(v IQualifiedNameContext) { s.to = v }

func (s *RenameIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameIndexContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *RenameIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEX, 0)
}

func (s *RenameIndexContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *RenameIndexContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *RenameIndexContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameIndexContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *RenameIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *RenameIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRenameIndex(s)
	}
}

func (s *RenameIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRenameIndex(s)
	}
}

type RenameColumnContext struct {
	StatementContext
	tableName IQualifiedNameContext
	from      IIdentifierContext
	to        IIdentifierContext
}

func NewRenameColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameColumnContext {
	var p = new(RenameColumnContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RenameColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *RenameColumnContext) GetFrom() IIdentifierContext { return s.from }

func (s *RenameColumnContext) GetTo() IIdentifierContext { return s.to }

func (s *RenameColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *RenameColumnContext) SetFrom(v IIdentifierContext) { s.from = v }

func (s *RenameColumnContext) SetTo(v IIdentifierContext) { s.to = v }

func (s *RenameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *RenameColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *RenameColumnContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *RenameColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *RenameColumnContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *RenameColumnContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameColumnContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenameColumnContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRenameColumn(s)
	}
}

func (s *RenameColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRenameColumn(s)
	}
}

type RevokeRolesContext struct {
	StatementContext
}

func NewRevokeRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRolesContext {
	var p = new(RevokeRolesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RevokeRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRolesContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREVOKE, 0)
}

func (s *RevokeRolesContext) Roles() IRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRolesContext)
}

func (s *RevokeRolesContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *RevokeRolesContext) AllPrincipal() []IPrincipalContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrincipalContext); ok {
			len++
		}
	}

	tst := make([]IPrincipalContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrincipalContext); ok {
			tst[i] = t.(IPrincipalContext)
			i++
		}
	}

	return tst
}

func (s *RevokeRolesContext) Principal(i int) IPrincipalContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *RevokeRolesContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADMIN, 0)
}

func (s *RevokeRolesContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *RevokeRolesContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *RevokeRolesContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTED, 0)
}

func (s *RevokeRolesContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *RevokeRolesContext) Grantor() IGrantorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantorContext)
}

func (s *RevokeRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRevokeRoles(s)
	}
}

func (s *RevokeRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRevokeRoles(s)
	}
}

type ShowCreateTableContext struct {
	StatementContext
}

func NewShowCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateTableContext {
	var p = new(ShowCreateTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *ShowCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *ShowCreateTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowCreateTable(s)
	}
}

func (s *ShowCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowCreateTable(s)
	}
}

type ShowColumnsContext struct {
	StatementContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowColumnsContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowColumnsContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowColumnsContext) FULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFULL, 0)
}

func (s *ShowColumnsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *ShowColumnsContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

type ShowRoleGrantsContext struct {
	StatementContext
}

func NewShowRoleGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoleGrantsContext {
	var p = new(ShowRoleGrantsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowRoleGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoleGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowRoleGrantsContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *ShowRoleGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTS, 0)
}

func (s *ShowRoleGrantsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRoleGrantsContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowRoleGrantsContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowRoleGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowRoleGrants(s)
	}
}

func (s *ShowRoleGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowRoleGrants(s)
	}
}

type InsertOverwriteCubeContext struct {
	StatementContext
	cubeName IQualifiedNameContext
}

func NewInsertOverwriteCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertOverwriteCubeContext {
	var p = new(InsertOverwriteCubeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *InsertOverwriteCubeContext) GetCubeName() IQualifiedNameContext { return s.cubeName }

func (s *InsertOverwriteCubeContext) SetCubeName(v IQualifiedNameContext) { s.cubeName = v }

func (s *InsertOverwriteCubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertOverwriteCubeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *InsertOverwriteCubeContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVERWRITE, 0)
}

func (s *InsertOverwriteCubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *InsertOverwriteCubeContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *InsertOverwriteCubeContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *InsertOverwriteCubeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InsertOverwriteCubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInsertOverwriteCube(s)
	}
}

func (s *InsertOverwriteCubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInsertOverwriteCube(s)
	}
}

type AddColumnContext struct {
	StatementContext
	tableName IQualifiedNameContext
	column    IColumnDefinitionContext
}

func NewAddColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnContext {
	var p = new(AddColumnContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AddColumnContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *AddColumnContext) GetColumn() IColumnDefinitionContext { return s.column }

func (s *AddColumnContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *AddColumnContext) SetColumn(v IColumnDefinitionContext) { s.column = v }

func (s *AddColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AddColumnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *AddColumnContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *AddColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *AddColumnContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AddColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AddColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAddColumn(s)
	}
}

func (s *AddColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAddColumn(s)
	}
}

type ResetSessionContext struct {
	StatementContext
}

func NewResetSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResetSessionContext {
	var p = new(ResetSessionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ResetSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetSessionContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESET, 0)
}

func (s *ResetSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *ResetSessionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ResetSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterResetSession(s)
	}
}

func (s *ResetSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitResetSession(s)
	}
}

type InsertIntoContext struct {
	StatementContext
}

func NewInsertIntoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertIntoContext {
	var p = new(InsertIntoContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *InsertIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *InsertIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTO, 0)
}

func (s *InsertIntoContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *InsertIntoContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertIntoContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *InsertIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInsertInto(s)
	}
}

func (s *InsertIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInsertInto(s)
	}
}

type ShowSessionContext struct {
	StatementContext
}

func NewShowSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSessionContext {
	var p = new(ShowSessionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSessionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *ShowSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowSession(s)
	}
}

func (s *ShowSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowSession(s)
	}
}

type CreateSchemaContext struct {
	StatementContext
}

func NewCreateSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateSchemaContext {
	var p = new(CreateSchemaContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSchemaContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateSchemaContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *CreateSchemaContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASE, 0)
}

func (s *CreateSchemaContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateSchemaContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateSchemaContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateSchemaContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateSchemaContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateSchema(s)
	}
}

func (s *CreateSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateSchema(s)
	}
}

type UpdateTableContext struct {
	StatementContext
}

func NewUpdateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UpdateTableContext {
	var p = new(UpdateTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *UpdateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateTableContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUPDATE, 0)
}

func (s *UpdateTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UpdateTableContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *UpdateTableContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *UpdateTableContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *UpdateTableContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *UpdateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUpdateTable(s)
	}
}

func (s *UpdateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUpdateTable(s)
	}
}

type ExecuteContext struct {
	StatementContext
}

func NewExecuteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExecuteContext {
	var p = new(ExecuteContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ExecuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXECUTE, 0)
}

func (s *ExecuteContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExecuteContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *ExecuteContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExecuteContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExecuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExecute(s)
	}
}

func (s *ExecuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExecute(s)
	}
}

type RenameSchemaContext struct {
	StatementContext
}

func NewRenameSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameSchemaContext {
	var p = new(RenameSchemaContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RenameSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameSchemaContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *RenameSchemaContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RenameSchemaContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *RenameSchemaContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *RenameSchemaContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *RenameSchemaContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASE, 0)
}

func (s *RenameSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRenameSchema(s)
	}
}

func (s *RenameSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRenameSchema(s)
	}
}

type DropRoleContext struct {
	StatementContext
	name IIdentifierContext
}

func NewDropRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRoleContext {
	var p = new(DropRoleContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropRoleContext) GetName() IIdentifierContext { return s.name }

func (s *DropRoleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *DropRoleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropRole(s)
	}
}

type ShowCreateCubeContext struct {
	StatementContext
}

func NewShowCreateCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateCubeContext {
	var p = new(ShowCreateCubeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateCubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateCubeContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCreateCubeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *ShowCreateCubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *ShowCreateCubeContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateCubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowCreateCube(s)
	}
}

func (s *ShowCreateCubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowCreateCube(s)
	}
}

type InsertOverwriteContext struct {
	StatementContext
}

func NewInsertOverwriteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertOverwriteContext {
	var p = new(InsertOverwriteContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *InsertOverwriteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertOverwriteContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *InsertOverwriteContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVERWRITE, 0)
}

func (s *InsertOverwriteContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *InsertOverwriteContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertOverwriteContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *InsertOverwriteContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *InsertOverwriteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInsertOverwrite(s)
	}
}

func (s *InsertOverwriteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInsertOverwrite(s)
	}
}

type AnalyzeContext struct {
	StatementContext
}

func NewAnalyzeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnalyzeContext {
	var p = new(AnalyzeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AnalyzeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANALYZE, 0)
}

func (s *AnalyzeContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AnalyzeContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *AnalyzeContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AnalyzeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAnalyze(s)
	}
}

func (s *AnalyzeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAnalyze(s)
	}
}

type SetRoleContext struct {
	StatementContext
	role IIdentifierContext
}

func NewSetRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetRoleContext {
	var p = new(SetRoleContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetRoleContext) GetRole() IIdentifierContext { return s.role }

func (s *SetRoleContext) SetRole(v IIdentifierContext) { s.role = v }

func (s *SetRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *SetRoleContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *SetRoleContext) NONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNONE, 0)
}

func (s *SetRoleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetRole(s)
	}
}

func (s *SetRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetRole(s)
	}
}

type ShowGrantsContext struct {
	StatementContext
}

func NewShowGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsContext {
	var p = new(ShowGrantsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTS, 0)
}

func (s *ShowGrantsContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *ShowGrantsContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowGrantsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *ShowGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowGrants(s)
	}
}

func (s *ShowGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowGrants(s)
	}
}

type DropSchemaContext struct {
	StatementContext
}

func NewDropSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropSchemaContext {
	var p = new(DropSchemaContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSchemaContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropSchemaContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *DropSchemaContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASE, 0)
}

func (s *DropSchemaContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropSchemaContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropSchemaContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASCADE, 0)
}

func (s *DropSchemaContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESTRICT, 0)
}

func (s *DropSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropSchema(s)
	}
}

func (s *DropSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropSchema(s)
	}
}

type VacuumTableContext struct {
	StatementContext
	partition IStringContext
}

func NewVacuumTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VacuumTableContext {
	var p = new(VacuumTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *VacuumTableContext) GetPartition() IStringContext { return s.partition }

func (s *VacuumTableContext) SetPartition(v IStringContext) { s.partition = v }

func (s *VacuumTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VacuumTableContext) VACUUM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVACUUM, 0)
}

func (s *VacuumTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *VacuumTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *VacuumTableContext) FULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFULL, 0)
}

func (s *VacuumTableContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *VacuumTableContext) AND_WAIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND_WAIT, 0)
}

func (s *VacuumTableContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *VacuumTableContext) UNIFY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNIFY, 0)
}

func (s *VacuumTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterVacuumTable(s)
	}
}

func (s *VacuumTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitVacuumTable(s)
	}
}

type ShowCreateViewContext struct {
	StatementContext
}

func NewShowCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateViewContext {
	var p = new(ShowCreateViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *ShowCreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *ShowCreateViewContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowCreateView(s)
	}
}

func (s *ShowCreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowCreateView(s)
	}
}

type ReloadCubeContext struct {
	StatementContext
	cubeName IQualifiedNameContext
}

func NewReloadCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReloadCubeContext {
	var p = new(ReloadCubeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ReloadCubeContext) GetCubeName() IQualifiedNameContext { return s.cubeName }

func (s *ReloadCubeContext) SetCubeName(v IQualifiedNameContext) { s.cubeName = v }

func (s *ReloadCubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReloadCubeContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRELOAD, 0)
}

func (s *ReloadCubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *ReloadCubeContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ReloadCubeContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *ReloadCubeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *ReloadCubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterReloadCube(s)
	}
}

func (s *ReloadCubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitReloadCube(s)
	}
}

type CreateTableContext struct {
	StatementContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CreateTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableContext) AllTableElement() []ITableElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableElementContext); ok {
			len++
		}
	}

	tst := make([]ITableElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableElementContext); ok {
			tst[i] = t.(ITableElementContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableContext) TableElement(i int) ITableElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementContext)
}

func (s *CreateTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateTableContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateTableContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *CreateTableContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CreateTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateTableContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

type StartTransactionContext struct {
	StatementContext
}

func NewStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StartTransactionContext {
	var p = new(StartTransactionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *StartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTART, 0)
}

func (s *StartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSACTION, 0)
}

func (s *StartTransactionContext) AllTransactionMode() []ITransactionModeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionModeContext); ok {
			len++
		}
	}

	tst := make([]ITransactionModeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionModeContext); ok {
			tst[i] = t.(ITransactionModeContext)
			i++
		}
	}

	return tst
}

func (s *StartTransactionContext) TransactionMode(i int) ITransactionModeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionModeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionModeContext)
}

func (s *StartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStartTransaction(s)
	}
}

func (s *StartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStartTransaction(s)
	}
}

type CreateTableAsSelectContext struct {
	StatementContext
}

func NewCreateTableAsSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableAsSelectContext {
	var p = new(CreateTableAsSelectContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateTableAsSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsSelectContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateTableAsSelectContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CreateTableAsSelectContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableAsSelectContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreateTableAsSelectContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableAsSelectContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateTableAsSelectContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateTableAsSelectContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateTableAsSelectContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *CreateTableAsSelectContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *CreateTableAsSelectContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CreateTableAsSelectContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserWITH)
}

func (s *CreateTableAsSelectContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, i)
}

func (s *CreateTableAsSelectContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableAsSelectContext) DATA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATA, 0)
}

func (s *CreateTableAsSelectContext) NO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNO, 0)
}

func (s *CreateTableAsSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateTableAsSelect(s)
	}
}

func (s *CreateTableAsSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateTableAsSelect(s)
	}
}

type CreateCubeContext struct {
	StatementContext
	cubeName  IQualifiedNameContext
	tableName IQualifiedNameContext
}

func NewCreateCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateCubeContext {
	var p = new(CreateCubeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateCubeContext) GetCubeName() IQualifiedNameContext { return s.cubeName }

func (s *CreateCubeContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *CreateCubeContext) SetCubeName(v IQualifiedNameContext) { s.cubeName = v }

func (s *CreateCubeContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *CreateCubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateCubeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateCubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *CreateCubeContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *CreateCubeContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateCubeContext) CubeProperties() ICubePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICubePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICubePropertiesContext)
}

func (s *CreateCubeContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateCubeContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateCubeContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateCubeContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateCubeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateCubeContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *CreateCubeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreateCubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateCube(s)
	}
}

func (s *CreateCubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateCube(s)
	}
}

type ShowStatsContext struct {
	StatementContext
}

func NewShowStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatsContext {
	var p = new(ShowStatsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATS, 0)
}

func (s *ShowStatsContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *ShowStatsContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowStatsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowStats(s)
	}
}

func (s *ShowStatsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowStats(s)
	}
}

type RevokeContext struct {
	StatementContext
	grantee IPrincipalContext
}

func NewRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeContext {
	var p = new(RevokeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RevokeContext) GetGrantee() IPrincipalContext { return s.grantee }

func (s *RevokeContext) SetGrantee(v IPrincipalContext) { s.grantee = v }

func (s *RevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREVOKE, 0)
}

func (s *RevokeContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *RevokeContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *RevokeContext) Principal() IPrincipalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *RevokeContext) AllPrivilege() []IPrivilegeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeContext); ok {
			tst[i] = t.(IPrivilegeContext)
			i++
		}
	}

	return tst
}

func (s *RevokeContext) Privilege(i int) IPrivilegeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *RevokeContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *RevokeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRIVILEGES, 0)
}

func (s *RevokeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANT, 0)
}

func (s *RevokeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *RevokeContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *RevokeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *RevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRevoke(s)
	}
}

func (s *RevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRevoke(s)
	}
}

type TableExecuteContext struct {
	StatementContext
	tableName     IQualifiedNameContext
	procedureName IIdentifierContext
	where         IBooleanExpressionContext
}

func NewTableExecuteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExecuteContext {
	var p = new(TableExecuteContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *TableExecuteContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *TableExecuteContext) GetProcedureName() IIdentifierContext { return s.procedureName }

func (s *TableExecuteContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *TableExecuteContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *TableExecuteContext) SetProcedureName(v IIdentifierContext) { s.procedureName = v }

func (s *TableExecuteContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *TableExecuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExecuteContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *TableExecuteContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *TableExecuteContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXECUTE, 0)
}

func (s *TableExecuteContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableExecuteContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableExecuteContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *TableExecuteContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *TableExecuteContext) AllCallArgument() []ICallArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallArgumentContext); ok {
			len++
		}
	}

	tst := make([]ICallArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallArgumentContext); ok {
			tst[i] = t.(ICallArgumentContext)
			i++
		}
	}

	return tst
}

func (s *TableExecuteContext) CallArgument(i int) ICallArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallArgumentContext)
}

func (s *TableExecuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTableExecute(s)
	}
}

func (s *TableExecuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTableExecute(s)
	}
}

type DeleteContext struct {
	StatementContext
}

func NewDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteContext {
	var p = new(DeleteContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELETE, 0)
}

func (s *DeleteContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *DeleteContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DeleteContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *DeleteContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDelete(s)
	}
}

func (s *DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDelete(s)
	}
}

type DescribeInputContext struct {
	StatementContext
}

func NewDescribeInputContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeInputContext {
	var p = new(DescribeInputContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DescribeInputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeInputContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *DescribeInputContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUT, 0)
}

func (s *DescribeInputContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeInputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDescribeInput(s)
	}
}

func (s *DescribeInputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDescribeInput(s)
	}
}

type ShowStatsForQueryContext struct {
	StatementContext
}

func NewShowStatsForQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatsForQueryContext {
	var p = new(ShowStatsForQueryContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowStatsForQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsForQueryContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowStatsForQueryContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATS, 0)
}

func (s *ShowStatsForQueryContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *ShowStatsForQueryContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *ShowStatsForQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowStatsForQuery(s)
	}
}

func (s *ShowStatsForQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowStatsForQuery(s)
	}
}

type StatementDefaultContext struct {
	StatementContext
}

func NewStatementDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementDefaultContext {
	var p = new(StatementDefaultContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *StatementDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementDefaultContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStatementDefault(s)
	}
}

func (s *StatementDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStatementDefault(s)
	}
}

type TruncateTableContext struct {
	StatementContext
}

func NewTruncateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TruncateTableContext {
	var p = new(TruncateTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *TruncateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRUNCATE, 0)
}

func (s *TruncateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *TruncateTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TruncateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTruncateTable(s)
	}
}

func (s *TruncateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTruncateTable(s)
	}
}

type ShowExternalFunctionContext struct {
	StatementContext
}

func NewShowExternalFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowExternalFunctionContext {
	var p = new(ShowExternalFunctionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowExternalFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowExternalFunctionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowExternalFunctionContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTERNAL, 0)
}

func (s *ShowExternalFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *ShowExternalFunctionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowExternalFunctionContext) Types() ITypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypesContext)
}

func (s *ShowExternalFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowExternalFunction(s)
	}
}

func (s *ShowExternalFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowExternalFunction(s)
	}
}

type SetSessionContext struct {
	StatementContext
}

func NewSetSessionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSessionContext {
	var p = new(SetSessionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetSessionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSessionContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetSessionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *SetSessionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetSessionContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *SetSessionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetSessionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetSession(s)
	}
}

func (s *SetSessionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetSession(s)
	}
}

type CreateViewContext struct {
	StatementContext
}

func NewCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateViewContext {
	var p = new(CreateViewContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *CreateViewContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreateViewContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateViewContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *CreateViewContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *CreateViewContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECURITY, 0)
}

func (s *CreateViewContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINER, 0)
}

func (s *CreateViewContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINVOKER, 0)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateView(s)
	}
}

type ShowSchemasContext struct {
	StatementContext
	cluster IIdentifierContext
	catalog IIdentifierContext
	pattern IStringContext
	escape  IStringContext
}

func NewShowSchemasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSchemasContext {
	var p = new(ShowSchemasContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowSchemasContext) GetCluster() IIdentifierContext { return s.cluster }

func (s *ShowSchemasContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *ShowSchemasContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowSchemasContext) GetEscape() IStringContext { return s.escape }

func (s *ShowSchemasContext) SetCluster(v IIdentifierContext) { s.cluster = v }

func (s *ShowSchemasContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *ShowSchemasContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowSchemasContext) SetEscape(v IStringContext) { s.escape = v }

func (s *ShowSchemasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemasContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowSchemasContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMAS, 0)
}

func (s *ShowSchemasContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASES, 0)
}

func (s *ShowSchemasContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowSchemasContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowSchemasContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowSchemasContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowSchemasContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSchemasContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ShowSchemasContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowSchemasContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowSchemasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowSchemas(s)
	}
}

func (s *ShowSchemasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowSchemas(s)
	}
}

type DropTableContext struct {
	StatementContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *DropTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropTable(s)
	}
}

type RollbackContext struct {
	StatementContext
}

func NewRollbackContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollbackContext {
	var p = new(RollbackContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RollbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLBACK, 0)
}

func (s *RollbackContext) WORK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWORK, 0)
}

func (s *RollbackContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRollback(s)
	}
}

func (s *RollbackContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRollback(s)
	}
}

type ShowCubesContext struct {
	StatementContext
	tableName IQualifiedNameContext
}

func NewShowCubesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCubesContext {
	var p = new(ShowCubesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCubesContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *ShowCubesContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *ShowCubesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCubesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCubesContext) CUBES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBES, 0)
}

func (s *ShowCubesContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *ShowCubesContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCubesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowCubes(s)
	}
}

func (s *ShowCubesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowCubes(s)
	}
}

type CommentTableContext struct {
	StatementContext
}

func NewCommentTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentTableContext {
	var p = new(CommentTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CommentTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentTableContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *CommentTableContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *CommentTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CommentTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CommentTableContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *CommentTableContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CommentTableContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *CommentTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCommentTable(s)
	}
}

func (s *CommentTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCommentTable(s)
	}
}

type SetPathContext struct {
	StatementContext
}

func NewSetPathContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPathContext {
	var p = new(SetPathContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPathContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetPathContext) PATH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPATH, 0)
}

func (s *SetPathContext) PathSpecification() IPathSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathSpecificationContext)
}

func (s *SetPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetPath(s)
	}
}

func (s *SetPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetPath(s)
	}
}

type CreateIndexContext struct {
	StatementContext
	indexName IQualifiedNameContext
	tableName IQualifiedNameContext
}

func NewCreateIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateIndexContext {
	var p = new(CreateIndexContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateIndexContext) GetIndexName() IQualifiedNameContext { return s.indexName }

func (s *CreateIndexContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *CreateIndexContext) SetIndexName(v IQualifiedNameContext) { s.indexName = v }

func (s *CreateIndexContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEX, 0)
}

func (s *CreateIndexContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *CreateIndexContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *CreateIndexContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *CreateIndexContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateIndexContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateIndexContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateIndexContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateIndexContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateIndexContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *CreateIndexContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

type GrantRolesContext struct {
	StatementContext
}

func NewGrantRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRolesContext {
	var p = new(GrantRolesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *GrantRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRolesContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANT, 0)
}

func (s *GrantRolesContext) Roles() IRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRolesContext)
}

func (s *GrantRolesContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *GrantRolesContext) AllPrincipal() []IPrincipalContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrincipalContext); ok {
			len++
		}
	}

	tst := make([]IPrincipalContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrincipalContext); ok {
			tst[i] = t.(IPrincipalContext)
			i++
		}
	}

	return tst
}

func (s *GrantRolesContext) Principal(i int) IPrincipalContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *GrantRolesContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *GrantRolesContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADMIN, 0)
}

func (s *GrantRolesContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *GrantRolesContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTED, 0)
}

func (s *GrantRolesContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *GrantRolesContext) Grantor() IGrantorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantorContext)
}

func (s *GrantRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGrantRoles(s)
	}
}

func (s *GrantRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGrantRoles(s)
	}
}

type CallContext struct {
	StatementContext
}

func NewCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallContext {
	var p = new(CallContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallContext) CALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALL, 0)
}

func (s *CallContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CallContext) AllCallArgument() []ICallArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallArgumentContext); ok {
			len++
		}
	}

	tst := make([]ICallArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallArgumentContext); ok {
			tst[i] = t.(ICallArgumentContext)
			i++
		}
	}

	return tst
}

func (s *CallContext) CallArgument(i int) ICallArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallArgumentContext)
}

func (s *CallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCall(s)
	}
}

func (s *CallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCall(s)
	}
}

type DropCubeContext struct {
	StatementContext
	cubeName IQualifiedNameContext
}

func NewDropCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCubeContext {
	var p = new(DropCubeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropCubeContext) GetCubeName() IQualifiedNameContext { return s.cubeName }

func (s *DropCubeContext) SetCubeName(v IQualifiedNameContext) { s.cubeName = v }

func (s *DropCubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCubeContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropCubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *DropCubeContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropCubeContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropCubeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropCubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropCube(s)
	}
}

func (s *DropCubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropCube(s)
	}
}

type ShowViewsContext struct {
	StatementContext
	pattern IStringContext
	escape  IStringContext
}

func NewShowViewsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowViewsContext {
	var p = new(ShowViewsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowViewsContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowViewsContext) GetEscape() IStringContext { return s.escape }

func (s *ShowViewsContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowViewsContext) SetEscape(v IStringContext) { s.escape = v }

func (s *ShowViewsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowViewsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowViewsContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEWS, 0)
}

func (s *ShowViewsContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowViewsContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ShowViewsContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *ShowViewsContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ShowViewsContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowViewsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowViewsContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowViewsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowViews(s)
	}
}

func (s *ShowViewsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowViews(s)
	}
}

type CacheTableContext struct {
	StatementContext
	tableName IQualifiedNameContext
}

func NewCacheTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CacheTableContext {
	var p = new(CacheTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CacheTableContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *CacheTableContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *CacheTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CacheTableContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCACHE, 0)
}

func (s *CacheTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CacheTableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CacheTableContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *CacheTableContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *CacheTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CacheTableContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CacheTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCacheTable(s)
	}
}

func (s *CacheTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCacheTable(s)
	}
}

type ShowFunctionsContext struct {
	StatementContext
	pattern IStringContext
	escape  IStringContext
}

func NewShowFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFunctionsContext {
	var p = new(ShowFunctionsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowFunctionsContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowFunctionsContext) GetEscape() IStringContext { return s.escape }

func (s *ShowFunctionsContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowFunctionsContext) SetEscape(v IStringContext) { s.escape = v }

func (s *ShowFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTIONS, 0)
}

func (s *ShowFunctionsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *ShowFunctionsContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ShowFunctionsContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowFunctionsContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *ShowFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowFunctions(s)
	}
}

func (s *ShowFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowFunctions(s)
	}
}

type DescribeOutputContext struct {
	StatementContext
}

func NewDescribeOutputContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeOutputContext {
	var p = new(DescribeOutputContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DescribeOutputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeOutputContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *DescribeOutputContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTPUT, 0)
}

func (s *DescribeOutputContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeOutputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDescribeOutput(s)
	}
}

func (s *DescribeOutputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDescribeOutput(s)
	}
}

type GrantContext struct {
	StatementContext
	grantee IPrincipalContext
}

func NewGrantContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantContext {
	var p = new(GrantContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *GrantContext) GetGrantee() IPrincipalContext { return s.grantee }

func (s *GrantContext) SetGrantee(v IPrincipalContext) { s.grantee = v }

func (s *GrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserGRANT)
}

func (s *GrantContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANT, i)
}

func (s *GrantContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *GrantContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *GrantContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *GrantContext) Principal() IPrincipalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *GrantContext) AllPrivilege() []IPrivilegeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeContext); ok {
			tst[i] = t.(IPrivilegeContext)
			i++
		}
	}

	return tst
}

func (s *GrantContext) Privilege(i int) IPrivilegeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *GrantContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *GrantContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRIVILEGES, 0)
}

func (s *GrantContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *GrantContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *GrantContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *GrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGrant(s)
	}
}

func (s *GrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGrant(s)
	}
}

type SetTablePropertiesContext struct {
	StatementContext
	tableName IQualifiedNameContext
}

func NewSetTablePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTablePropertiesContext {
	var p = new(SetTablePropertiesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetTablePropertiesContext) GetTableName() IQualifiedNameContext { return s.tableName }

func (s *SetTablePropertiesContext) SetTableName(v IQualifiedNameContext) { s.tableName = v }

func (s *SetTablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTablePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *SetTablePropertiesContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *SetTablePropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetTablePropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, 0)
}

func (s *SetTablePropertiesContext) PropertyAssignments() IPropertyAssignmentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyAssignmentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentsContext)
}

func (s *SetTablePropertiesContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SetTablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetTableProperties(s)
	}
}

func (s *SetTablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetTableProperties(s)
	}
}

type ShowCacheContext struct {
	StatementContext
}

func NewShowCacheContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCacheContext {
	var p = new(ShowCacheContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCacheContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCacheContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ShowCacheContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCACHE, 0)
}

func (s *ShowCacheContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCacheContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowCache(s)
	}
}

func (s *ShowCacheContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowCache(s)
	}
}

func (p *SqlBaseParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SqlBaseParserRULE_statement)
	var _la int

	p.SetState(962)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(190)
			p.Query()
		}

	case 2:
		localctx = NewUseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(191)
			p.Match(SqlBaseParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(192)

			var _x = p.Identifier()

			localctx.(*UseContext).schema = _x
		}

	case 3:
		localctx = NewUseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(193)
			p.Match(SqlBaseParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(194)

			var _x = p.Identifier()

			localctx.(*UseContext).catalog = _x
		}
		{
			p.SetState(195)
			p.Match(SqlBaseParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(196)

			var _x = p.Identifier()

			localctx.(*UseContext).schema = _x
		}

	case 4:
		localctx = NewUseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(198)
			p.Match(SqlBaseParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(199)

			var _x = p.Identifier()

			localctx.(*UseContext).cluster = _x
		}
		{
			p.SetState(200)
			p.Match(SqlBaseParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(201)

			var _x = p.Identifier()

			localctx.(*UseContext).catalog = _x
		}
		{
			p.SetState(202)
			p.Match(SqlBaseParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(203)

			var _x = p.Identifier()

			localctx.(*UseContext).schema = _x
		}

	case 5:
		localctx = NewCreateSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(205)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(206)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDATABASE || _la == SqlBaseParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(210)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(207)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(208)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(209)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(212)
			p.QualifiedName()
		}
		p.SetState(215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(213)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(214)
				p.Properties()
			}

		}

	case 6:
		localctx = NewDropSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(217)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(218)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDATABASE || _la == SqlBaseParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(221)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(219)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(220)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(223)
			p.QualifiedName()
		}
		p.SetState(225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCASCADE || _la == SqlBaseParserRESTRICT {
			{
				p.SetState(224)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserCASCADE || _la == SqlBaseParserRESTRICT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 7:
		localctx = NewRenameSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(227)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(228)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDATABASE || _la == SqlBaseParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(229)
			p.QualifiedName()
		}
		{
			p.SetState(230)
			p.Match(SqlBaseParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(231)
			p.Match(SqlBaseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(232)
			p.Identifier()
		}

	case 8:
		localctx = NewCreateTableAsSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(234)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(235)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(239)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(236)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(237)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(238)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(241)
			p.QualifiedName()
		}
		p.SetState(243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__1 {
			{
				p.SetState(242)
				p.ColumnAliases()
			}

		}
		p.SetState(247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCOMMENT {
			{
				p.SetState(245)
				p.Match(SqlBaseParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(246)
				p.String_()
			}

		}
		p.SetState(251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(249)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(250)
				p.Properties()
			}

		}
		{
			p.SetState(253)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(254)
				p.Query()
			}

		case 2:
			{
				p.SetState(255)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(256)
				p.Query()
			}
			{
				p.SetState(257)
				p.Match(SqlBaseParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(261)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(263)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserNO {
				{
					p.SetState(262)
					p.Match(SqlBaseParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(265)
				p.Match(SqlBaseParserDATA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 9:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(268)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(269)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(270)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(271)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(272)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(275)
			p.QualifiedName()
		}
		{
			p.SetState(276)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(277)
			p.TableElement()
		}
		p.SetState(282)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(278)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(279)
				p.TableElement()
			}

			p.SetState(284)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(285)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCOMMENT {
			{
				p.SetState(286)
				p.Match(SqlBaseParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(287)
				p.String_()
			}

		}
		p.SetState(292)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(290)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(291)
				p.Properties()
			}

		}

	case 10:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(294)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(295)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(298)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(296)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(297)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(300)
			p.QualifiedName()
		}

	case 11:
		localctx = NewTruncateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(301)
			p.Match(SqlBaseParserTRUNCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(302)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(303)
			p.QualifiedName()
		}

	case 12:
		localctx = NewCacheTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(304)
			p.Match(SqlBaseParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(305)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(306)

			var _x = p.QualifiedName()

			localctx.(*CacheTableContext).tableName = _x
		}
		p.SetState(309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(307)
				p.Match(SqlBaseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(308)
				p.booleanExpression(0)
			}

		}
		p.SetState(313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(311)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(312)
				p.Properties()
			}

		}

	case 13:
		localctx = NewDropCacheContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(315)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(316)
			p.Match(SqlBaseParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(319)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(317)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(318)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(321)
			p.QualifiedName()
		}
		p.SetState(324)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(322)
				p.Match(SqlBaseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(323)
				p.booleanExpression(0)
			}

		}

	case 14:
		localctx = NewShowCacheContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(326)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(327)
			p.Match(SqlBaseParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(329)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7963480973466883072) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-77497039822350423) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-306253643777315529) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&67553994443182899) != 0) {
			{
				p.SetState(328)
				p.QualifiedName()
			}

		}

	case 15:
		localctx = NewCreateCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(331)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(332)
			p.Match(SqlBaseParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(336)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(333)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(334)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(335)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(338)

			var _x = p.QualifiedName()

			localctx.(*CreateCubeContext).cubeName = _x
		}
		{
			p.SetState(339)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(340)

			var _x = p.QualifiedName()

			localctx.(*CreateCubeContext).tableName = _x
		}
		{
			p.SetState(341)
			p.Match(SqlBaseParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(342)
			p.CubeProperties()
		}
		p.SetState(345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(343)
				p.Match(SqlBaseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(344)
				p.Expression()
			}

		}

	case 16:
		localctx = NewInsertCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(347)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(348)
			p.Match(SqlBaseParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(349)
			p.Match(SqlBaseParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(350)

			var _x = p.QualifiedName()

			localctx.(*InsertCubeContext).cubeName = _x
		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(351)
				p.Match(SqlBaseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(352)
				p.Expression()
			}

		}

	case 17:
		localctx = NewInsertOverwriteCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(355)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(356)
			p.Match(SqlBaseParserOVERWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(357)
			p.Match(SqlBaseParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(358)

			var _x = p.QualifiedName()

			localctx.(*InsertOverwriteCubeContext).cubeName = _x
		}
		p.SetState(361)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(359)
				p.Match(SqlBaseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(360)
				p.Expression()
			}

		}

	case 18:
		localctx = NewReloadCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(363)
			p.Match(SqlBaseParserRELOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(364)
			p.Match(SqlBaseParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(367)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(365)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(366)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(369)

			var _x = p.QualifiedName()

			localctx.(*ReloadCubeContext).cubeName = _x
		}

	case 19:
		localctx = NewDropCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(370)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(371)
			p.Match(SqlBaseParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(374)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(372)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(373)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(376)

			var _x = p.QualifiedName()

			localctx.(*DropCubeContext).cubeName = _x
		}

	case 20:
		localctx = NewShowCubesContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(377)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(378)
			p.Match(SqlBaseParserCUBES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFOR {
			{
				p.SetState(379)
				p.Match(SqlBaseParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(380)

				var _x = p.QualifiedName()

				localctx.(*ShowCubesContext).tableName = _x
			}

		}

	case 21:
		localctx = NewCreateIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(383)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(384)
			p.Match(SqlBaseParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(388)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(385)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(386)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(387)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(390)

			var _x = p.QualifiedName()

			localctx.(*CreateIndexContext).indexName = _x
		}
		{
			p.SetState(391)
			p.Match(SqlBaseParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(392)
			p.IndexType()
		}
		{
			p.SetState(393)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(394)

			var _x = p.QualifiedName()

			localctx.(*CreateIndexContext).tableName = _x
		}
		{
			p.SetState(395)
			p.ColumnAliases()
		}
		p.SetState(398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(396)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(397)
				p.Properties()
			}

		}
		p.SetState(402)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(400)
				p.Match(SqlBaseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(401)
				p.Expression()
			}

		}

	case 22:
		localctx = NewDropIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(404)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(405)
			p.Match(SqlBaseParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(408)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(406)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(407)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(410)

			var _x = p.QualifiedName()

			localctx.(*DropIndexContext).indexName = _x
		}
		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(411)
				p.Match(SqlBaseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(412)
				p.Expression()
			}

		}

	case 23:
		localctx = NewRenameIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(415)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(416)
			p.Match(SqlBaseParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(419)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(417)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(418)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(421)

			var _x = p.QualifiedName()

			localctx.(*RenameIndexContext).from = _x
		}
		{
			p.SetState(422)
			p.Match(SqlBaseParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(423)
			p.Match(SqlBaseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(424)

			var _x = p.QualifiedName()

			localctx.(*RenameIndexContext).to = _x
		}

	case 24:
		localctx = NewUpdateIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(426)
			p.Match(SqlBaseParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(427)
			p.Match(SqlBaseParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(430)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(428)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(429)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(432)
			p.QualifiedName()
		}

	case 25:
		localctx = NewShowIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(433)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(434)
			p.Match(SqlBaseParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(437)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(435)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(436)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(440)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7963480973466883072) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-77497039822350423) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-306253643777315529) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&67553994443182899) != 0) {
			{
				p.SetState(439)
				p.QualifiedName()
			}

		}

	case 26:
		localctx = NewInsertIntoContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(442)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(443)
			p.Match(SqlBaseParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(444)
			p.QualifiedName()
		}
		p.SetState(446)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(445)
				p.ColumnAliases()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(448)
			p.Query()
		}

	case 27:
		localctx = NewInsertOverwriteContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(450)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(451)
			p.Match(SqlBaseParserOVERWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserTABLE {
			{
				p.SetState(452)
				p.Match(SqlBaseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(455)
			p.QualifiedName()
		}
		p.SetState(457)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(456)
				p.ColumnAliases()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(459)
			p.Query()
		}

	case 28:
		localctx = NewDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(461)
			p.Match(SqlBaseParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(462)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(463)
			p.QualifiedName()
		}
		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(464)
				p.Match(SqlBaseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(465)
				p.booleanExpression(0)
			}

		}

	case 29:
		localctx = NewUpdateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(468)
			p.Match(SqlBaseParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(469)
			p.QualifiedName()
		}
		{
			p.SetState(470)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(471)
			p.AssignmentList()
		}
		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(472)
				p.Match(SqlBaseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(473)
				p.booleanExpression(0)
			}

		}

	case 30:
		localctx = NewRenameTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(476)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(477)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(478)

			var _x = p.QualifiedName()

			localctx.(*RenameTableContext).from = _x
		}
		{
			p.SetState(479)
			p.Match(SqlBaseParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(480)
			p.Match(SqlBaseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(481)

			var _x = p.QualifiedName()

			localctx.(*RenameTableContext).to = _x
		}

	case 31:
		localctx = NewCommentTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(483)
			p.Match(SqlBaseParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(484)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(485)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(486)
			p.QualifiedName()
		}
		{
			p.SetState(487)
			p.Match(SqlBaseParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SqlBaseParserSTRING, SqlBaseParserUNICODE_STRING:
			{
				p.SetState(488)
				p.String_()
			}

		case SqlBaseParserNULL:
			{
				p.SetState(489)
				p.Match(SqlBaseParserNULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 32:
		localctx = NewRenameColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(492)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(493)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(494)

			var _x = p.QualifiedName()

			localctx.(*RenameColumnContext).tableName = _x
		}
		{
			p.SetState(495)
			p.Match(SqlBaseParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(496)
			p.Match(SqlBaseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(497)

			var _x = p.Identifier()

			localctx.(*RenameColumnContext).from = _x
		}
		{
			p.SetState(498)
			p.Match(SqlBaseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(499)

			var _x = p.Identifier()

			localctx.(*RenameColumnContext).to = _x
		}

	case 33:
		localctx = NewDropColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(501)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(502)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(503)

			var _x = p.QualifiedName()

			localctx.(*DropColumnContext).tableName = _x
		}
		{
			p.SetState(504)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(505)
			p.Match(SqlBaseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(506)

			var _x = p.QualifiedName()

			localctx.(*DropColumnContext).column = _x
		}

	case 34:
		localctx = NewAddColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(508)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(509)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(510)

			var _x = p.QualifiedName()

			localctx.(*AddColumnContext).tableName = _x
		}
		{
			p.SetState(511)
			p.Match(SqlBaseParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(512)
			p.Match(SqlBaseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(513)

			var _x = p.ColumnDefinition()

			localctx.(*AddColumnContext).column = _x
		}

	case 35:
		localctx = NewSetTablePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(515)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(516)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(517)

			var _x = p.QualifiedName()

			localctx.(*SetTablePropertiesContext).tableName = _x
		}
		{
			p.SetState(518)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(519)
			p.Match(SqlBaseParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(520)
			p.PropertyAssignments()
		}

	case 36:
		localctx = NewAnalyzeContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(522)
			p.Match(SqlBaseParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(523)
			p.QualifiedName()
		}
		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(524)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(525)
				p.Properties()
			}

		}

	case 37:
		localctx = NewCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(528)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOR {
			{
				p.SetState(529)
				p.Match(SqlBaseParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(530)
				p.Match(SqlBaseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(533)
			p.Match(SqlBaseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(534)
			p.QualifiedName()
		}
		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserSECURITY {
			{
				p.SetState(535)
				p.Match(SqlBaseParserSECURITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(536)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserDEFINER || _la == SqlBaseParserINVOKER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(539)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(540)
			p.Query()
		}

	case 38:
		localctx = NewSetMaterializedViewPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(542)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(543)
			p.Match(SqlBaseParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(544)
			p.Match(SqlBaseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(545)
			p.QualifiedName()
		}
		{
			p.SetState(546)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(547)
			p.Match(SqlBaseParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(548)
			p.PropertyAssignments()
		}

	case 39:
		localctx = NewDropViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(550)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(551)
			p.Match(SqlBaseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(554)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(552)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(553)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(556)
			p.QualifiedName()
		}

	case 40:
		localctx = NewCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(557)
			p.Match(SqlBaseParserCALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(558)
			p.QualifiedName()
		}
		{
			p.SetState(559)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7962443031269037020) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-76652614883829763) != 0) || ((int64((_la-133)) & ^0x3f) == 0 && ((int64(1)<<(_la-133))&-2450029150218524225) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&5763534400207532863) != 0) {
			{
				p.SetState(560)
				p.CallArgument()
			}
			p.SetState(565)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(561)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(562)
					p.CallArgument()
				}

				p.SetState(567)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(570)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 41:
		localctx = NewCreateRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(572)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(573)
			p.Match(SqlBaseParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(574)

			var _x = p.Identifier()

			localctx.(*CreateRoleContext).name = _x
		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(575)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(576)
				p.Match(SqlBaseParserADMIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(577)
				p.Grantor()
			}

		}

	case 42:
		localctx = NewDropRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(580)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(581)
			p.Match(SqlBaseParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(582)

			var _x = p.Identifier()

			localctx.(*DropRoleContext).name = _x
		}

	case 43:
		localctx = NewGrantRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(583)
			p.Match(SqlBaseParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(584)
			p.Roles()
		}
		{
			p.SetState(585)
			p.Match(SqlBaseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(586)
			p.Principal()
		}
		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(587)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(588)
				p.Principal()
			}

			p.SetState(593)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(594)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(595)
				p.Match(SqlBaseParserADMIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(596)
				p.Match(SqlBaseParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserGRANTED {
			{
				p.SetState(599)
				p.Match(SqlBaseParserGRANTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(600)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(601)
				p.Grantor()
			}

		}

	case 44:
		localctx = NewRevokeRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(604)
			p.Match(SqlBaseParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(608)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(605)
				p.Match(SqlBaseParserADMIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(606)
				p.Match(SqlBaseParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(607)
				p.Match(SqlBaseParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(610)
			p.Roles()
		}
		{
			p.SetState(611)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(612)
			p.Principal()
		}
		p.SetState(617)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(613)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(614)
				p.Principal()
			}

			p.SetState(619)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserGRANTED {
			{
				p.SetState(620)
				p.Match(SqlBaseParserGRANTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(621)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(622)
				p.Grantor()
			}

		}

	case 45:
		localctx = NewSetRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(625)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(626)
			p.Match(SqlBaseParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(627)
				p.Match(SqlBaseParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(628)
				p.Match(SqlBaseParserNONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(629)

				var _x = p.Identifier()

				localctx.(*SetRoleContext).role = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 46:
		localctx = NewGrantContext(p, localctx)
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(632)
			p.Match(SqlBaseParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(633)
				p.Privilege()
			}
			p.SetState(638)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(634)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(635)
					p.Privilege()
				}

				p.SetState(640)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case 2:
			{
				p.SetState(641)
				p.Match(SqlBaseParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(642)
				p.Match(SqlBaseParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(645)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserTABLE {
			{
				p.SetState(646)
				p.Match(SqlBaseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(649)
			p.QualifiedName()
		}
		{
			p.SetState(650)
			p.Match(SqlBaseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(651)

			var _x = p.Principal()

			localctx.(*GrantContext).grantee = _x
		}
		p.SetState(655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(652)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(653)
				p.Match(SqlBaseParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(654)
				p.Match(SqlBaseParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 47:
		localctx = NewRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(657)
			p.Match(SqlBaseParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(661)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(658)
				p.Match(SqlBaseParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(659)
				p.Match(SqlBaseParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(660)
				p.Match(SqlBaseParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(663)
				p.Privilege()
			}
			p.SetState(668)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(664)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(665)
					p.Privilege()
				}

				p.SetState(670)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case 2:
			{
				p.SetState(671)
				p.Match(SqlBaseParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(672)
				p.Match(SqlBaseParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(675)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserTABLE {
			{
				p.SetState(676)
				p.Match(SqlBaseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(679)
			p.QualifiedName()
		}
		{
			p.SetState(680)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(681)

			var _x = p.Principal()

			localctx.(*RevokeContext).grantee = _x
		}

	case 48:
		localctx = NewShowGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(683)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(684)
			p.Match(SqlBaseParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserON {
			{
				p.SetState(685)
				p.Match(SqlBaseParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(687)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserTABLE {
				{
					p.SetState(686)
					p.Match(SqlBaseParserTABLE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(689)
				p.QualifiedName()
			}

		}

	case 49:
		localctx = NewExplainContext(p, localctx)
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(692)
			p.Match(SqlBaseParserEXPLAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(694)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(693)
				p.Match(SqlBaseParserANALYZE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserVERBOSE {
			{
				p.SetState(696)
				p.Match(SqlBaseParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(710)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(699)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(700)
				p.ExplainOption()
			}
			p.SetState(705)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(701)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(702)
					p.ExplainOption()
				}

				p.SetState(707)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(708)
				p.Match(SqlBaseParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(712)
			p.Statement()
		}

	case 50:
		localctx = NewShowExternalFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(713)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(714)
			p.Match(SqlBaseParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(715)
			p.Match(SqlBaseParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(716)
			p.QualifiedName()
		}
		p.SetState(718)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__1 {
			{
				p.SetState(717)
				p.Types()
			}

		}

	case 51:
		localctx = NewShowCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(720)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(721)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(722)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(723)
			p.QualifiedName()
		}

	case 52:
		localctx = NewShowCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(724)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(725)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(726)
			p.Match(SqlBaseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(727)
			p.QualifiedName()
		}

	case 53:
		localctx = NewShowCreateCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(728)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(729)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(730)
			p.Match(SqlBaseParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(731)
			p.QualifiedName()
		}

	case 54:
		localctx = NewShowTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(732)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(733)
			p.Match(SqlBaseParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(734)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(735)
				p.QualifiedName()
			}

		}
		p.SetState(744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(738)
				p.Match(SqlBaseParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(739)

				var _x = p.String_()

				localctx.(*ShowTablesContext).pattern = _x
			}
			p.SetState(742)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(740)
					p.Match(SqlBaseParserESCAPE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(741)

					var _x = p.String_()

					localctx.(*ShowTablesContext).escape = _x
				}

			}

		}

	case 55:
		localctx = NewShowSchemasContext(p, localctx)
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(746)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(747)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserDATABASES || _la == SqlBaseParserSCHEMAS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(748)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(752)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(749)

					var _x = p.Identifier()

					localctx.(*ShowSchemasContext).cluster = _x
				}
				{
					p.SetState(750)
					p.Match(SqlBaseParserT__0)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(754)

				var _x = p.Identifier()

				localctx.(*ShowSchemasContext).catalog = _x
			}

		}
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(757)
				p.Match(SqlBaseParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(758)

				var _x = p.String_()

				localctx.(*ShowSchemasContext).pattern = _x
			}
			p.SetState(761)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(759)
					p.Match(SqlBaseParserESCAPE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(760)

					var _x = p.String_()

					localctx.(*ShowSchemasContext).escape = _x
				}

			}

		}

	case 56:
		localctx = NewShowCatalogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(765)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(766)
			p.Match(SqlBaseParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(769)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(767)
				p.Match(SqlBaseParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(768)

				var _x = p.String_()

				localctx.(*ShowCatalogsContext).pattern = _x
			}

		}

	case 57:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(771)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(772)
			p.Match(SqlBaseParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(773)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(774)
			p.QualifiedName()
		}

	case 58:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(775)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(776)
			p.Match(SqlBaseParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(777)
			p.Match(SqlBaseParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(778)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(779)
			p.QualifiedName()
		}

	case 59:
		localctx = NewShowStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(780)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(781)
			p.Match(SqlBaseParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(782)
			p.Match(SqlBaseParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(783)
			p.QualifiedName()
		}

	case 60:
		localctx = NewShowStatsForQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(784)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(785)
			p.Match(SqlBaseParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(786)
			p.Match(SqlBaseParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(787)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(788)
			p.QuerySpecification()
		}
		{
			p.SetState(789)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 61:
		localctx = NewShowRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(791)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(793)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserCURRENT {
			{
				p.SetState(792)
				p.Match(SqlBaseParserCURRENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(795)
			p.Match(SqlBaseParserROLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(796)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(797)
				p.Identifier()
			}

		}

	case 62:
		localctx = NewShowRoleGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(800)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(801)
			p.Match(SqlBaseParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(802)
			p.Match(SqlBaseParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(805)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(803)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(804)
				p.Identifier()
			}

		}

	case 63:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(807)
			p.Match(SqlBaseParserDESCRIBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(808)
			p.QualifiedName()
		}

	case 64:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(809)
			p.Match(SqlBaseParserDESC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(810)
			p.QualifiedName()
		}

	case 65:
		localctx = NewShowFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(811)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(812)
			p.Match(SqlBaseParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE {
			{
				p.SetState(813)
				p.Match(SqlBaseParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(814)

				var _x = p.String_()

				localctx.(*ShowFunctionsContext).pattern = _x
			}
			p.SetState(817)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(815)
					p.Match(SqlBaseParserESCAPE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(816)

					var _x = p.String_()

					localctx.(*ShowFunctionsContext).escape = _x
				}

			}

		}

	case 66:
		localctx = NewShowSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(821)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(822)
			p.Match(SqlBaseParserSESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 67:
		localctx = NewSetSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(823)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(824)
			p.Match(SqlBaseParserSESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(825)
			p.QualifiedName()
		}
		{
			p.SetState(826)
			p.Match(SqlBaseParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(827)
			p.Expression()
		}

	case 68:
		localctx = NewResetSessionContext(p, localctx)
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(829)
			p.Match(SqlBaseParserRESET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(830)
			p.Match(SqlBaseParserSESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(831)
			p.QualifiedName()
		}

	case 69:
		localctx = NewStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 69)
		{
			p.SetState(832)
			p.Match(SqlBaseParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(833)
			p.Match(SqlBaseParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserISOLATION || _la == SqlBaseParserREAD {
			{
				p.SetState(834)
				p.TransactionMode()
			}
			p.SetState(839)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(835)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(836)
					p.TransactionMode()
				}

				p.SetState(841)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 70:
		localctx = NewCommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 70)
		{
			p.SetState(844)
			p.Match(SqlBaseParserCOMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWORK {
			{
				p.SetState(845)
				p.Match(SqlBaseParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 71:
		localctx = NewRollbackContext(p, localctx)
		p.EnterOuterAlt(localctx, 71)
		{
			p.SetState(848)
			p.Match(SqlBaseParserROLLBACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWORK {
			{
				p.SetState(849)
				p.Match(SqlBaseParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 72:
		localctx = NewPrepareContext(p, localctx)
		p.EnterOuterAlt(localctx, 72)
		{
			p.SetState(852)
			p.Match(SqlBaseParserPREPARE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(853)
			p.Identifier()
		}
		{
			p.SetState(854)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(855)
			p.Statement()
		}

	case 73:
		localctx = NewDeallocateContext(p, localctx)
		p.EnterOuterAlt(localctx, 73)
		{
			p.SetState(857)
			p.Match(SqlBaseParserDEALLOCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(858)
			p.Match(SqlBaseParserPREPARE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(859)
			p.Identifier()
		}

	case 74:
		localctx = NewExecuteContext(p, localctx)
		p.EnterOuterAlt(localctx, 74)
		{
			p.SetState(860)
			p.Match(SqlBaseParserEXECUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(861)
			p.Identifier()
		}
		p.SetState(871)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserUSING {
			{
				p.SetState(862)
				p.Match(SqlBaseParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(863)
				p.Expression()
			}
			p.SetState(868)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(864)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(865)
					p.Expression()
				}

				p.SetState(870)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 75:
		localctx = NewTableExecuteContext(p, localctx)
		p.EnterOuterAlt(localctx, 75)
		{
			p.SetState(873)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(874)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(875)

			var _x = p.QualifiedName()

			localctx.(*TableExecuteContext).tableName = _x
		}
		{
			p.SetState(876)
			p.Match(SqlBaseParserEXECUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(877)

			var _x = p.Identifier()

			localctx.(*TableExecuteContext).procedureName = _x
		}
		p.SetState(890)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__1 {
			{
				p.SetState(878)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(887)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7962443031269037020) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-76652614883829763) != 0) || ((int64((_la-133)) & ^0x3f) == 0 && ((int64(1)<<(_la-133))&-2450029150218524225) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&5763534400207532863) != 0) {
				{
					p.SetState(879)
					p.CallArgument()
				}
				p.SetState(884)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == SqlBaseParserT__3 {
					{
						p.SetState(880)
						p.Match(SqlBaseParserT__3)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(881)
						p.CallArgument()
					}

					p.SetState(886)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			}
			{
				p.SetState(889)
				p.Match(SqlBaseParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWHERE {
			{
				p.SetState(892)
				p.Match(SqlBaseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(893)

				var _x = p.booleanExpression(0)

				localctx.(*TableExecuteContext).where = _x
			}

		}

	case 76:
		localctx = NewExecuteContext(p, localctx)
		p.EnterOuterAlt(localctx, 76)
		{
			p.SetState(896)
			p.Match(SqlBaseParserEXECUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(897)
			p.Identifier()
		}
		p.SetState(907)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserUSING {
			{
				p.SetState(898)
				p.Match(SqlBaseParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(899)
				p.Expression()
			}
			p.SetState(904)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(900)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(901)
					p.Expression()
				}

				p.SetState(906)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 77:
		localctx = NewDescribeInputContext(p, localctx)
		p.EnterOuterAlt(localctx, 77)
		{
			p.SetState(909)
			p.Match(SqlBaseParserDESCRIBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(910)
			p.Match(SqlBaseParserINPUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(911)
			p.Identifier()
		}

	case 78:
		localctx = NewDescribeOutputContext(p, localctx)
		p.EnterOuterAlt(localctx, 78)
		{
			p.SetState(912)
			p.Match(SqlBaseParserDESCRIBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(913)
			p.Match(SqlBaseParserOUTPUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(914)
			p.Identifier()
		}

	case 79:
		localctx = NewSetPathContext(p, localctx)
		p.EnterOuterAlt(localctx, 79)
		{
			p.SetState(915)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(916)
			p.Match(SqlBaseParserPATH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(917)
			p.PathSpecification()
		}

	case 80:
		localctx = NewVacuumTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 80)
		{
			p.SetState(918)
			p.Match(SqlBaseParserVACUUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(919)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(920)
			p.QualifiedName()
		}
		p.SetState(925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFULL {
			{
				p.SetState(921)
				p.Match(SqlBaseParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(923)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserUNIFY {
				{
					p.SetState(922)
					p.Match(SqlBaseParserUNIFY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		p.SetState(929)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPARTITION {
			{
				p.SetState(927)
				p.Match(SqlBaseParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(928)

				var _x = p.String_()

				localctx.(*VacuumTableContext).partition = _x
			}

		}
		p.SetState(932)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserAND_WAIT {
			{
				p.SetState(931)
				p.Match(SqlBaseParserAND_WAIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 81:
		localctx = NewRefreshMetadataCacheContext(p, localctx)
		p.EnterOuterAlt(localctx, 81)
		{
			p.SetState(934)
			p.Match(SqlBaseParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(935)
			p.Match(SqlBaseParserMETA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(936)
			p.Match(SqlBaseParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(944)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFOR {
			{
				p.SetState(937)
				p.Match(SqlBaseParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(941)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(938)

					var _x = p.Identifier()

					localctx.(*RefreshMetadataCacheContext).cluster = _x
				}
				{
					p.SetState(939)
					p.Match(SqlBaseParserT__0)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(943)

				var _x = p.Identifier()

				localctx.(*RefreshMetadataCacheContext).catalog = _x
			}

		}

	case 82:
		localctx = NewShowViewsContext(p, localctx)
		p.EnterOuterAlt(localctx, 82)
		{
			p.SetState(946)
			p.Match(SqlBaseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(947)
			p.Match(SqlBaseParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFROM || _la == SqlBaseParserIN {
			{
				p.SetState(948)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserFROM || _la == SqlBaseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(949)
				p.QualifiedName()
			}

		}
		p.SetState(960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserLIKE || _la == SqlBaseParserSTRING || _la == SqlBaseParserUNICODE_STRING {
			p.SetState(953)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserLIKE {
				{
					p.SetState(952)
					p.Match(SqlBaseParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(955)

				var _x = p.String_()

				localctx.(*ShowViewsContext).pattern = _x
			}
			p.SetState(958)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserESCAPE {
				{
					p.SetState(956)
					p.Match(SqlBaseParserESCAPE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(957)

					var _x = p.String_()

					localctx.(*ShowViewsContext).escape = _x
				}

			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignmentItem() []IAssignmentItemContext
	AssignmentItem(i int) IAssignmentItemContext

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_assignmentList
	return p
}

func InitEmptyAssignmentListContext(p *AssignmentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_assignmentList
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) AllAssignmentItem() []IAssignmentItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentItemContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentItemContext); ok {
			tst[i] = t.(IAssignmentItemContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentListContext) AssignmentItem(i int) IAssignmentItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentItemContext)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAssignmentList(s)
	}
}

func (s *AssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAssignmentList(s)
	}
}

func (p *SqlBaseParser) AssignmentList() (localctx IAssignmentListContext) {
	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SqlBaseParserRULE_assignmentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(964)
		p.AssignmentItem()
	}
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__3 {
		{
			p.SetState(965)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(966)
			p.AssignmentItem()
		}

		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentItemContext is an interface to support dynamic dispatch.
type IAssignmentItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	EQ() antlr.TerminalNode
	Expression() IExpressionContext

	// IsAssignmentItemContext differentiates from other interfaces.
	IsAssignmentItemContext()
}

type AssignmentItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentItemContext() *AssignmentItemContext {
	var p = new(AssignmentItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_assignmentItem
	return p
}

func InitEmptyAssignmentItemContext(p *AssignmentItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_assignmentItem
}

func (*AssignmentItemContext) IsAssignmentItemContext() {}

func NewAssignmentItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentItemContext {
	var p = new(AssignmentItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_assignmentItem

	return p
}

func (s *AssignmentItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentItemContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AssignmentItemContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *AssignmentItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAssignmentItem(s)
	}
}

func (s *AssignmentItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAssignmentItem(s)
	}
}

func (p *SqlBaseParser) AssignmentItem() (localctx IAssignmentItemContext) {
	localctx = NewAssignmentItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SqlBaseParserRULE_assignmentItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(972)
		p.QualifiedName()
	}
	{
		p.SetState(973)
		p.Match(SqlBaseParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(974)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryNoWith() IQueryNoWithContext
	With() IWithContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) QueryNoWith() IQueryNoWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryNoWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *QueryContext) With() IWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *SqlBaseParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SqlBaseParserRULE_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserWITH {
		{
			p.SetState(976)
			p.With()
		}

	}
	{
		p.SetState(979)
		p.QueryNoWith()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithContext is an interface to support dynamic dispatch.
type IWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllNamedQuery() []INamedQueryContext
	NamedQuery(i int) INamedQueryContext
	RECURSIVE() antlr.TerminalNode

	// IsWithContext differentiates from other interfaces.
	IsWithContext()
}

type WithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithContext() *WithContext {
	var p = new(WithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_with
	return p
}

func InitEmptyWithContext(p *WithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_with
}

func (*WithContext) IsWithContext() {}

func NewWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithContext {
	var p = new(WithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_with

	return p
}

func (s *WithContext) GetParser() antlr.Parser { return s.parser }

func (s *WithContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *WithContext) AllNamedQuery() []INamedQueryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedQueryContext); ok {
			len++
		}
	}

	tst := make([]INamedQueryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedQueryContext); ok {
			tst[i] = t.(INamedQueryContext)
			i++
		}
	}

	return tst
}

func (s *WithContext) NamedQuery(i int) INamedQueryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedQueryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedQueryContext)
}

func (s *WithContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRECURSIVE, 0)
}

func (s *WithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterWith(s)
	}
}

func (s *WithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitWith(s)
	}
}

func (p *SqlBaseParser) With() (localctx IWithContext) {
	localctx = NewWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SqlBaseParserRULE_with)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(981)
		p.Match(SqlBaseParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(983)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserRECURSIVE {
		{
			p.SetState(982)
			p.Match(SqlBaseParserRECURSIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(985)
		p.NamedQuery()
	}
	p.SetState(990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__3 {
		{
			p.SetState(986)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(987)
			p.NamedQuery()
		}

		p.SetState(992)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnDefinition() IColumnDefinitionContext
	LikeClause() ILikeClauseContext

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableElement
	return p
}

func InitEmptyTableElementContext(p *TableElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableElement
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *TableElementContext) LikeClause() ILikeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikeClauseContext)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (p *SqlBaseParser) TableElement() (localctx ITableElementContext) {
	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SqlBaseParserRULE_tableElement)
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserDATA, SqlBaseParserDATABASE, SqlBaseParserDATABASES, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserEXTERNAL, SqlBaseParserFETCH, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNEXT, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPATH, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEXT, SqlBaseParserTIES, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserVIEWS, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserINDEX, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(993)
			p.ColumnDefinition()
		}

	case SqlBaseParserLIKE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(994)
			p.LikeClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Type_() ITypeContext
	NOT() antlr.TerminalNode
	NULL() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	String_() IStringContext
	WITH() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnDefinition
	return p
}

func InitEmptyColumnDefinitionContext(p *ColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnDefinition
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDefinitionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ColumnDefinitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *ColumnDefinitionContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *ColumnDefinitionContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRIMARY, 0)
}

func (s *ColumnDefinitionContext) KEY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserKEY, 0)
}

func (s *ColumnDefinitionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *ColumnDefinitionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ColumnDefinitionContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *ColumnDefinitionContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (p *SqlBaseParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SqlBaseParserRULE_columnDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		p.Identifier()
	}
	{
		p.SetState(998)
		p.type_(0)
	}
	p.SetState(1001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserNOT {
		{
			p.SetState(999)
			p.Match(SqlBaseParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1000)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserPRIMARY {
		{
			p.SetState(1003)
			p.Match(SqlBaseParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1004)
			p.Match(SqlBaseParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserCOMMENT {
		{
			p.SetState(1007)
			p.Match(SqlBaseParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1008)
			p.String_()
		}

	}
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserWITH {
		{
			p.SetState(1011)
			p.Match(SqlBaseParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1012)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILikeClauseContext is an interface to support dynamic dispatch.
type ILikeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOptionType returns the optionType token.
	GetOptionType() antlr.Token

	// SetOptionType sets the optionType token.
	SetOptionType(antlr.Token)

	// Getter signatures
	LIKE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PROPERTIES() antlr.TerminalNode
	INCLUDING() antlr.TerminalNode
	EXCLUDING() antlr.TerminalNode

	// IsLikeClauseContext differentiates from other interfaces.
	IsLikeClauseContext()
}

type LikeClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	optionType antlr.Token
}

func NewEmptyLikeClauseContext() *LikeClauseContext {
	var p = new(LikeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_likeClause
	return p
}

func InitEmptyLikeClauseContext(p *LikeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_likeClause
}

func (*LikeClauseContext) IsLikeClauseContext() {}

func NewLikeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeClauseContext {
	var p = new(LikeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_likeClause

	return p
}

func (s *LikeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeClauseContext) GetOptionType() antlr.Token { return s.optionType }

func (s *LikeClauseContext) SetOptionType(v antlr.Token) { s.optionType = v }

func (s *LikeClauseContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *LikeClauseContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *LikeClauseContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, 0)
}

func (s *LikeClauseContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINCLUDING, 0)
}

func (s *LikeClauseContext) EXCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCLUDING, 0)
}

func (s *LikeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLikeClause(s)
	}
}

func (s *LikeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLikeClause(s)
	}
}

func (p *SqlBaseParser) LikeClause() (localctx ILikeClauseContext) {
	localctx = NewLikeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SqlBaseParserRULE_likeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.Match(SqlBaseParserLIKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1016)
		p.QualifiedName()
	}
	p.SetState(1019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserEXCLUDING || _la == SqlBaseParserINCLUDING {
		{
			p.SetState(1017)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LikeClauseContext).optionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserEXCLUDING || _la == SqlBaseParserINCLUDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LikeClauseContext).optionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1018)
			p.Match(SqlBaseParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICubePropertiesContext is an interface to support dynamic dispatch.
type ICubePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCubeProperty() []ICubePropertyContext
	CubeProperty(i int) ICubePropertyContext

	// IsCubePropertiesContext differentiates from other interfaces.
	IsCubePropertiesContext()
}

type CubePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCubePropertiesContext() *CubePropertiesContext {
	var p = new(CubePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_cubeProperties
	return p
}

func InitEmptyCubePropertiesContext(p *CubePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_cubeProperties
}

func (*CubePropertiesContext) IsCubePropertiesContext() {}

func NewCubePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CubePropertiesContext {
	var p = new(CubePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_cubeProperties

	return p
}

func (s *CubePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *CubePropertiesContext) AllCubeProperty() []ICubePropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICubePropertyContext); ok {
			len++
		}
	}

	tst := make([]ICubePropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICubePropertyContext); ok {
			tst[i] = t.(ICubePropertyContext)
			i++
		}
	}

	return tst
}

func (s *CubePropertiesContext) CubeProperty(i int) ICubePropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICubePropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICubePropertyContext)
}

func (s *CubePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CubePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCubeProperties(s)
	}
}

func (s *CubePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCubeProperties(s)
	}
}

func (p *SqlBaseParser) CubeProperties() (localctx ICubePropertiesContext) {
	localctx = NewCubePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SqlBaseParserRULE_cubeProperties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1021)
		p.Match(SqlBaseParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7963480973466878976) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-77497039818156119) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-306253643777315529) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&67553994443182899) != 0) {
		{
			p.SetState(1022)
			p.CubeProperty()
		}
		p.SetState(1027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1023)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1024)
				p.CubeProperty()
			}

			p.SetState(1029)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1032)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICubePropertyContext is an interface to support dynamic dispatch.
type ICubePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AGGREGATIONS() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Aggregations() IAggregationsContext
	GROUP() antlr.TerminalNode
	CubeGroup() ICubeGroupContext
	FILTER() antlr.TerminalNode
	SourceFilter() ISourceFilterContext
	Property() IPropertyContext

	// IsCubePropertyContext differentiates from other interfaces.
	IsCubePropertyContext()
}

type CubePropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCubePropertyContext() *CubePropertyContext {
	var p = new(CubePropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_cubeProperty
	return p
}

func InitEmptyCubePropertyContext(p *CubePropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_cubeProperty
}

func (*CubePropertyContext) IsCubePropertyContext() {}

func NewCubePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CubePropertyContext {
	var p = new(CubePropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_cubeProperty

	return p
}

func (s *CubePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *CubePropertyContext) AGGREGATIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAGGREGATIONS, 0)
}

func (s *CubePropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *CubePropertyContext) Aggregations() IAggregationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationsContext)
}

func (s *CubePropertyContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUP, 0)
}

func (s *CubePropertyContext) CubeGroup() ICubeGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICubeGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICubeGroupContext)
}

func (s *CubePropertyContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILTER, 0)
}

func (s *CubePropertyContext) SourceFilter() ISourceFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceFilterContext)
}

func (s *CubePropertyContext) Property() IPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *CubePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CubePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCubeProperty(s)
	}
}

func (s *CubePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCubeProperty(s)
	}
}

func (p *SqlBaseParser) CubeProperty() (localctx ICubePropertyContext) {
	localctx = NewCubePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SqlBaseParserRULE_cubeProperty)
	p.SetState(1053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1034)
			p.Match(SqlBaseParserAGGREGATIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1035)
			p.Match(SqlBaseParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1036)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1037)
			p.Aggregations()
		}
		{
			p.SetState(1038)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1040)
			p.Match(SqlBaseParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1041)
			p.Match(SqlBaseParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1042)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1043)
			p.CubeGroup()
		}
		{
			p.SetState(1044)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1046)
			p.Match(SqlBaseParserFILTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1047)
			p.Match(SqlBaseParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1048)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1049)
			p.SourceFilter()
		}
		{
			p.SetState(1050)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1052)
			p.Property()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext
	PropertyAssignments() IPropertyAssignmentsContext

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_properties
	return p
}

func InitEmptyPropertiesContext(p *PropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_properties
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertiesContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertiesContext) PropertyAssignments() IPropertyAssignmentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyAssignmentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyAssignmentsContext)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterProperties(s)
	}
}

func (s *PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitProperties(s)
	}
}

func (p *SqlBaseParser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SqlBaseParserRULE_properties)
	var _la int

	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1055)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1056)
			p.Property()
		}
		p.SetState(1061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1057)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1058)
				p.Property()
			}

			p.SetState(1063)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1064)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1066)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1067)
			p.PropertyAssignments()
		}
		{
			p.SetState(1068)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyAssignmentsContext is an interface to support dynamic dispatch.
type IPropertyAssignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsPropertyAssignmentsContext differentiates from other interfaces.
	IsPropertyAssignmentsContext()
}

type PropertyAssignmentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyAssignmentsContext() *PropertyAssignmentsContext {
	var p = new(PropertyAssignmentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_propertyAssignments
	return p
}

func InitEmptyPropertyAssignmentsContext(p *PropertyAssignmentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_propertyAssignments
}

func (*PropertyAssignmentsContext) IsPropertyAssignmentsContext() {}

func NewPropertyAssignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyAssignmentsContext {
	var p = new(PropertyAssignmentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_propertyAssignments

	return p
}

func (s *PropertyAssignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyAssignmentsContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertyAssignmentsContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertyAssignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyAssignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyAssignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPropertyAssignments(s)
	}
}

func (s *PropertyAssignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPropertyAssignments(s)
	}
}

func (p *SqlBaseParser) PropertyAssignments() (localctx IPropertyAssignmentsContext) {
	localctx = NewPropertyAssignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SqlBaseParserRULE_propertyAssignments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1072)
		p.Property()
	}
	p.SetState(1077)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__3 {
		{
			p.SetState(1073)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1074)
			p.Property()
		}

		p.SetState(1079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_property
	return p
}

func InitEmptyPropertyContext(p *PropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_property
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *PropertyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (p *SqlBaseParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SqlBaseParserRULE_property)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1080)
		p.Identifier()
	}
	{
		p.SetState(1081)
		p.Match(SqlBaseParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1082)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionPropertiesContext is an interface to support dynamic dispatch.
type IFunctionPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionProperty() []IFunctionPropertyContext
	FunctionProperty(i int) IFunctionPropertyContext

	// IsFunctionPropertiesContext differentiates from other interfaces.
	IsFunctionPropertiesContext()
}

type FunctionPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionPropertiesContext() *FunctionPropertiesContext {
	var p = new(FunctionPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionProperties
	return p
}

func InitEmptyFunctionPropertiesContext(p *FunctionPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionProperties
}

func (*FunctionPropertiesContext) IsFunctionPropertiesContext() {}

func NewFunctionPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionPropertiesContext {
	var p = new(FunctionPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_functionProperties

	return p
}

func (s *FunctionPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionPropertiesContext) AllFunctionProperty() []IFunctionPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionPropertyContext); ok {
			len++
		}
	}

	tst := make([]IFunctionPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionPropertyContext); ok {
			tst[i] = t.(IFunctionPropertyContext)
			i++
		}
	}

	return tst
}

func (s *FunctionPropertiesContext) FunctionProperty(i int) IFunctionPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionPropertyContext)
}

func (s *FunctionPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterFunctionProperties(s)
	}
}

func (s *FunctionPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitFunctionProperties(s)
	}
}

func (p *SqlBaseParser) FunctionProperties() (localctx IFunctionPropertiesContext) {
	localctx = NewFunctionPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SqlBaseParserRULE_functionProperties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1084)
		p.Match(SqlBaseParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1085)
		p.FunctionProperty()
	}
	p.SetState(1090)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__3 {
		{
			p.SetState(1086)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1087)
			p.FunctionProperty()
		}

		p.SetState(1092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1093)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionPropertyContext is an interface to support dynamic dispatch.
type IFunctionPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	String_() IStringContext

	// IsFunctionPropertyContext differentiates from other interfaces.
	IsFunctionPropertyContext()
}

type FunctionPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionPropertyContext() *FunctionPropertyContext {
	var p = new(FunctionPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionProperty
	return p
}

func InitEmptyFunctionPropertyContext(p *FunctionPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionProperty
}

func (*FunctionPropertyContext) IsFunctionPropertyContext() {}

func NewFunctionPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionPropertyContext {
	var p = new(FunctionPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_functionProperty

	return p
}

func (s *FunctionPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionPropertyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionPropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *FunctionPropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *FunctionPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterFunctionProperty(s)
	}
}

func (s *FunctionPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitFunctionProperty(s)
	}
}

func (p *SqlBaseParser) FunctionProperty() (localctx IFunctionPropertyContext) {
	localctx = NewFunctionPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SqlBaseParserRULE_functionProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1095)
		p.Identifier()
	}
	{
		p.SetState(1096)
		p.Match(SqlBaseParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1097)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlParameterDeclarationContext is an interface to support dynamic dispatch.
type ISqlParameterDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Type_() ITypeContext

	// IsSqlParameterDeclarationContext differentiates from other interfaces.
	IsSqlParameterDeclarationContext()
}

type SqlParameterDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlParameterDeclarationContext() *SqlParameterDeclarationContext {
	var p = new(SqlParameterDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sqlParameterDeclaration
	return p
}

func InitEmptySqlParameterDeclarationContext(p *SqlParameterDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sqlParameterDeclaration
}

func (*SqlParameterDeclarationContext) IsSqlParameterDeclarationContext() {}

func NewSqlParameterDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlParameterDeclarationContext {
	var p = new(SqlParameterDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sqlParameterDeclaration

	return p
}

func (s *SqlParameterDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlParameterDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SqlParameterDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SqlParameterDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlParameterDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlParameterDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSqlParameterDeclaration(s)
	}
}

func (s *SqlParameterDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSqlParameterDeclaration(s)
	}
}

func (p *SqlBaseParser) SqlParameterDeclaration() (localctx ISqlParameterDeclarationContext) {
	localctx = NewSqlParameterDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SqlBaseParserRULE_sqlParameterDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1099)
		p.Identifier()
	}
	{
		p.SetState(1100)
		p.type_(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineCharacteristicsContext is an interface to support dynamic dispatch.
type IRoutineCharacteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRoutineCharacteristic() []IRoutineCharacteristicContext
	RoutineCharacteristic(i int) IRoutineCharacteristicContext

	// IsRoutineCharacteristicsContext differentiates from other interfaces.
	IsRoutineCharacteristicsContext()
}

type RoutineCharacteristicsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineCharacteristicsContext() *RoutineCharacteristicsContext {
	var p = new(RoutineCharacteristicsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristics
	return p
}

func InitEmptyRoutineCharacteristicsContext(p *RoutineCharacteristicsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristics
}

func (*RoutineCharacteristicsContext) IsRoutineCharacteristicsContext() {}

func NewRoutineCharacteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineCharacteristicsContext {
	var p = new(RoutineCharacteristicsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristics

	return p
}

func (s *RoutineCharacteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineCharacteristicsContext) AllRoutineCharacteristic() []IRoutineCharacteristicContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineCharacteristicContext); ok {
			len++
		}
	}

	tst := make([]IRoutineCharacteristicContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineCharacteristicContext); ok {
			tst[i] = t.(IRoutineCharacteristicContext)
			i++
		}
	}

	return tst
}

func (s *RoutineCharacteristicsContext) RoutineCharacteristic(i int) IRoutineCharacteristicContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineCharacteristicContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineCharacteristicContext)
}

func (s *RoutineCharacteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCharacteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineCharacteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRoutineCharacteristics(s)
	}
}

func (s *RoutineCharacteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRoutineCharacteristics(s)
	}
}

func (p *SqlBaseParser) RoutineCharacteristics() (localctx IRoutineCharacteristicsContext) {
	localctx = NewRoutineCharacteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SqlBaseParserRULE_routineCharacteristics)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserCALLED || _la == SqlBaseParserDETERMINISTIC || ((int64((_la-110)) & ^0x3f) == 0 && ((int64(1)<<(_la-110))&72057594054705153) != 0) {
		{
			p.SetState(1102)
			p.RoutineCharacteristic()
		}

		p.SetState(1107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineCharacteristicContext is an interface to support dynamic dispatch.
type IRoutineCharacteristicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LANGUAGE() antlr.TerminalNode
	Language() ILanguageContext
	Determinism() IDeterminismContext
	NullCallClause() INullCallClauseContext

	// IsRoutineCharacteristicContext differentiates from other interfaces.
	IsRoutineCharacteristicContext()
}

type RoutineCharacteristicContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineCharacteristicContext() *RoutineCharacteristicContext {
	var p = new(RoutineCharacteristicContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristic
	return p
}

func InitEmptyRoutineCharacteristicContext(p *RoutineCharacteristicContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristic
}

func (*RoutineCharacteristicContext) IsRoutineCharacteristicContext() {}

func NewRoutineCharacteristicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineCharacteristicContext {
	var p = new(RoutineCharacteristicContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_routineCharacteristic

	return p
}

func (s *RoutineCharacteristicContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineCharacteristicContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLANGUAGE, 0)
}

func (s *RoutineCharacteristicContext) Language() ILanguageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILanguageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILanguageContext)
}

func (s *RoutineCharacteristicContext) Determinism() IDeterminismContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeterminismContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeterminismContext)
}

func (s *RoutineCharacteristicContext) NullCallClause() INullCallClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullCallClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullCallClauseContext)
}

func (s *RoutineCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCharacteristicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRoutineCharacteristic(s)
	}
}

func (s *RoutineCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRoutineCharacteristic(s)
	}
}

func (p *SqlBaseParser) RoutineCharacteristic() (localctx IRoutineCharacteristicContext) {
	localctx = NewRoutineCharacteristicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SqlBaseParserRULE_routineCharacteristic)
	p.SetState(1112)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserLANGUAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1108)
			p.Match(SqlBaseParserLANGUAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1109)
			p.Language()
		}

	case SqlBaseParserDETERMINISTIC, SqlBaseParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1110)
			p.Determinism()
		}

	case SqlBaseParserCALLED, SqlBaseParserRETURNS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1111)
			p.NullCallClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineBodyContext is an interface to support dynamic dispatch.
type IRoutineBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReturnStatement() IReturnStatementContext
	ExternalBodyReference() IExternalBodyReferenceContext

	// IsRoutineBodyContext differentiates from other interfaces.
	IsRoutineBodyContext()
}

type RoutineBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineBodyContext() *RoutineBodyContext {
	var p = new(RoutineBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineBody
	return p
}

func InitEmptyRoutineBodyContext(p *RoutineBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_routineBody
}

func (*RoutineBodyContext) IsRoutineBodyContext() {}

func NewRoutineBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineBodyContext {
	var p = new(RoutineBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_routineBody

	return p
}

func (s *RoutineBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineBodyContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *RoutineBodyContext) ExternalBodyReference() IExternalBodyReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalBodyReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalBodyReferenceContext)
}

func (s *RoutineBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRoutineBody(s)
	}
}

func (s *RoutineBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRoutineBody(s)
	}
}

func (p *SqlBaseParser) RoutineBody() (localctx IRoutineBodyContext) {
	localctx = NewRoutineBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SqlBaseParserRULE_routineBody)
	p.SetState(1116)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserRETURN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1114)
			p.ReturnStatement()
		}

	case SqlBaseParserEXTERNAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1115)
			p.ExternalBodyReference()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURN, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *SqlBaseParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SqlBaseParserRULE_returnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1118)
		p.Match(SqlBaseParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1119)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternalBodyReferenceContext is an interface to support dynamic dispatch.
type IExternalBodyReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTERNAL() antlr.TerminalNode
	NAME() antlr.TerminalNode
	ExternalRoutineName() IExternalRoutineNameContext

	// IsExternalBodyReferenceContext differentiates from other interfaces.
	IsExternalBodyReferenceContext()
}

type ExternalBodyReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalBodyReferenceContext() *ExternalBodyReferenceContext {
	var p = new(ExternalBodyReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_externalBodyReference
	return p
}

func InitEmptyExternalBodyReferenceContext(p *ExternalBodyReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_externalBodyReference
}

func (*ExternalBodyReferenceContext) IsExternalBodyReferenceContext() {}

func NewExternalBodyReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalBodyReferenceContext {
	var p = new(ExternalBodyReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_externalBodyReference

	return p
}

func (s *ExternalBodyReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalBodyReferenceContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTERNAL, 0)
}

func (s *ExternalBodyReferenceContext) NAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAME, 0)
}

func (s *ExternalBodyReferenceContext) ExternalRoutineName() IExternalRoutineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalRoutineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalRoutineNameContext)
}

func (s *ExternalBodyReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalBodyReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalBodyReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExternalBodyReference(s)
	}
}

func (s *ExternalBodyReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExternalBodyReference(s)
	}
}

func (p *SqlBaseParser) ExternalBodyReference() (localctx IExternalBodyReferenceContext) {
	localctx = NewExternalBodyReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SqlBaseParserRULE_externalBodyReference)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1121)
		p.Match(SqlBaseParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserNAME {
		{
			p.SetState(1122)
			p.Match(SqlBaseParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1123)
			p.ExternalRoutineName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILanguageContext is an interface to support dynamic dispatch.
type ILanguageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsLanguageContext differentiates from other interfaces.
	IsLanguageContext()
}

type LanguageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLanguageContext() *LanguageContext {
	var p = new(LanguageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_language
	return p
}

func InitEmptyLanguageContext(p *LanguageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_language
}

func (*LanguageContext) IsLanguageContext() {}

func NewLanguageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LanguageContext {
	var p = new(LanguageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_language

	return p
}

func (s *LanguageContext) GetParser() antlr.Parser { return s.parser }

func (s *LanguageContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LanguageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LanguageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LanguageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLanguage(s)
	}
}

func (s *LanguageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLanguage(s)
	}
}

func (p *SqlBaseParser) Language() (localctx ILanguageContext) {
	localctx = NewLanguageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SqlBaseParserRULE_language)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1126)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeterminismContext is an interface to support dynamic dispatch.
type IDeterminismContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DETERMINISTIC() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsDeterminismContext differentiates from other interfaces.
	IsDeterminismContext()
}

type DeterminismContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeterminismContext() *DeterminismContext {
	var p = new(DeterminismContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_determinism
	return p
}

func InitEmptyDeterminismContext(p *DeterminismContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_determinism
}

func (*DeterminismContext) IsDeterminismContext() {}

func NewDeterminismContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeterminismContext {
	var p = new(DeterminismContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_determinism

	return p
}

func (s *DeterminismContext) GetParser() antlr.Parser { return s.parser }

func (s *DeterminismContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDETERMINISTIC, 0)
}

func (s *DeterminismContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *DeterminismContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeterminismContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeterminismContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDeterminism(s)
	}
}

func (s *DeterminismContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDeterminism(s)
	}
}

func (p *SqlBaseParser) Determinism() (localctx IDeterminismContext) {
	localctx = NewDeterminismContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SqlBaseParserRULE_determinism)
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserDETERMINISTIC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1128)
			p.Match(SqlBaseParserDETERMINISTIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1129)
			p.Match(SqlBaseParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1130)
			p.Match(SqlBaseParserDETERMINISTIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullCallClauseContext is an interface to support dynamic dispatch.
type INullCallClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURNS() antlr.TerminalNode
	AllNULL() []antlr.TerminalNode
	NULL(i int) antlr.TerminalNode
	ON() antlr.TerminalNode
	INPUT() antlr.TerminalNode
	CALLED() antlr.TerminalNode

	// IsNullCallClauseContext differentiates from other interfaces.
	IsNullCallClauseContext()
}

type NullCallClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullCallClauseContext() *NullCallClauseContext {
	var p = new(NullCallClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nullCallClause
	return p
}

func InitEmptyNullCallClauseContext(p *NullCallClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nullCallClause
}

func (*NullCallClauseContext) IsNullCallClauseContext() {}

func NewNullCallClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullCallClauseContext {
	var p = new(NullCallClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_nullCallClause

	return p
}

func (s *NullCallClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *NullCallClauseContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURNS, 0)
}

func (s *NullCallClauseContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserNULL)
}

func (s *NullCallClauseContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, i)
}

func (s *NullCallClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *NullCallClauseContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUT, 0)
}

func (s *NullCallClauseContext) CALLED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALLED, 0)
}

func (s *NullCallClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullCallClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullCallClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNullCallClause(s)
	}
}

func (s *NullCallClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNullCallClause(s)
	}
}

func (p *SqlBaseParser) NullCallClause() (localctx INullCallClauseContext) {
	localctx = NewNullCallClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SqlBaseParserRULE_nullCallClause)
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserRETURNS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1133)
			p.Match(SqlBaseParserRETURNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1134)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1135)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1136)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1137)
			p.Match(SqlBaseParserINPUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserCALLED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1138)
			p.Match(SqlBaseParserCALLED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1139)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1140)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1141)
			p.Match(SqlBaseParserINPUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternalRoutineNameContext is an interface to support dynamic dispatch.
type IExternalRoutineNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsExternalRoutineNameContext differentiates from other interfaces.
	IsExternalRoutineNameContext()
}

type ExternalRoutineNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalRoutineNameContext() *ExternalRoutineNameContext {
	var p = new(ExternalRoutineNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_externalRoutineName
	return p
}

func InitEmptyExternalRoutineNameContext(p *ExternalRoutineNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_externalRoutineName
}

func (*ExternalRoutineNameContext) IsExternalRoutineNameContext() {}

func NewExternalRoutineNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalRoutineNameContext {
	var p = new(ExternalRoutineNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_externalRoutineName

	return p
}

func (s *ExternalRoutineNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalRoutineNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExternalRoutineNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalRoutineNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalRoutineNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExternalRoutineName(s)
	}
}

func (s *ExternalRoutineNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExternalRoutineName(s)
	}
}

func (p *SqlBaseParser) ExternalRoutineName() (localctx IExternalRoutineNameContext) {
	localctx = NewExternalRoutineNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SqlBaseParserRULE_externalRoutineName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1144)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryNoWithContext is an interface to support dynamic dispatch.
type IQueryNoWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset token.
	GetOffset() antlr.Token

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// GetFetchFirst returns the fetchFirst token.
	GetFetchFirst() antlr.Token

	// SetOffset sets the offset token.
	SetOffset(antlr.Token)

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// SetFetchFirst sets the fetchFirst token.
	SetFetchFirst(antlr.Token)

	// Getter signatures
	QueryTerm() IQueryTermContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	OFFSET() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	FETCH() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	AllROW() []antlr.TerminalNode
	ROW(i int) antlr.TerminalNode
	AllROWS() []antlr.TerminalNode
	ROWS(i int) antlr.TerminalNode
	ALL() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	WITH() antlr.TerminalNode
	TIES() antlr.TerminalNode

	// IsQueryNoWithContext differentiates from other interfaces.
	IsQueryNoWithContext()
}

type QueryNoWithContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	offset     antlr.Token
	limit      antlr.Token
	fetchFirst antlr.Token
}

func NewEmptyQueryNoWithContext() *QueryNoWithContext {
	var p = new(QueryNoWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryNoWith
	return p
}

func InitEmptyQueryNoWithContext(p *QueryNoWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryNoWith
}

func (*QueryNoWithContext) IsQueryNoWithContext() {}

func NewQueryNoWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryNoWithContext {
	var p = new(QueryNoWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_queryNoWith

	return p
}

func (s *QueryNoWithContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryNoWithContext) GetOffset() antlr.Token { return s.offset }

func (s *QueryNoWithContext) GetLimit() antlr.Token { return s.limit }

func (s *QueryNoWithContext) GetFetchFirst() antlr.Token { return s.fetchFirst }

func (s *QueryNoWithContext) SetOffset(v antlr.Token) { s.offset = v }

func (s *QueryNoWithContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *QueryNoWithContext) SetFetchFirst(v antlr.Token) { s.fetchFirst = v }

func (s *QueryNoWithContext) QueryTerm() IQueryTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryNoWithContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *QueryNoWithContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *QueryNoWithContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *QueryNoWithContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryNoWithContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOFFSET, 0)
}

func (s *QueryNoWithContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserINTEGER_VALUE)
}

func (s *QueryNoWithContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, i)
}

func (s *QueryNoWithContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIMIT, 0)
}

func (s *QueryNoWithContext) FETCH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFETCH, 0)
}

func (s *QueryNoWithContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *QueryNoWithContext) NEXT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNEXT, 0)
}

func (s *QueryNoWithContext) AllROW() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserROW)
}

func (s *QueryNoWithContext) ROW(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, i)
}

func (s *QueryNoWithContext) AllROWS() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserROWS)
}

func (s *QueryNoWithContext) ROWS(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROWS, i)
}

func (s *QueryNoWithContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *QueryNoWithContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserONLY, 0)
}

func (s *QueryNoWithContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *QueryNoWithContext) TIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIES, 0)
}

func (s *QueryNoWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryNoWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryNoWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQueryNoWith(s)
	}
}

func (p *SqlBaseParser) QueryNoWith() (localctx IQueryNoWithContext) {
	localctx = NewQueryNoWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SqlBaseParserRULE_queryNoWith)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1146)
		p.queryTerm(0)
	}
	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserORDER {
		{
			p.SetState(1147)
			p.Match(SqlBaseParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1148)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1149)
			p.SortItem()
		}
		p.SetState(1154)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1150)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1151)
				p.SortItem()
			}

			p.SetState(1156)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(1164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserOFFSET {
		{
			p.SetState(1159)
			p.Match(SqlBaseParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1160)

			var _m = p.Match(SqlBaseParserINTEGER_VALUE)

			localctx.(*QueryNoWithContext).offset = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserROW || _la == SqlBaseParserROWS {
			{
				p.SetState(1161)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserROW || _la == SqlBaseParserROWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	}
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserLIMIT:
		{
			p.SetState(1166)
			p.Match(SqlBaseParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1167)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*QueryNoWithContext).limit = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserALL || _la == SqlBaseParserINTEGER_VALUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*QueryNoWithContext).limit = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SqlBaseParserFETCH:
		{
			p.SetState(1168)
			p.Match(SqlBaseParserFETCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1169)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFIRST || _la == SqlBaseParserNEXT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserINTEGER_VALUE {
			{
				p.SetState(1170)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*QueryNoWithContext).fetchFirst = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1173)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserROW || _la == SqlBaseParserROWS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SqlBaseParserONLY:
			{
				p.SetState(1174)
				p.Match(SqlBaseParserONLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case SqlBaseParserWITH:
			{
				p.SetState(1175)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1176)
				p.Match(SqlBaseParserTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case SqlBaseParserEOF, SqlBaseParserT__2, SqlBaseParserWITH:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryTerm
	return p
}

func InitEmptyQueryTermContext(p *QueryTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryTerm
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyAll(ctx *QueryTermContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryTermDefaultContext struct {
	QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQueryTermDefault(s)
	}
}

func (s *QueryTermDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQueryTermDefault(s)
	}
}

type SetOperationContext struct {
	QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryTerm() []IQueryTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryTermContext); ok {
			len++
		}
	}

	tst := make([]IQueryTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryTermContext); ok {
			tst[i] = t.(IQueryTermContext)
			i++
		}
	}

	return tst
}

func (s *SetOperationContext) QueryTerm(i int) IQueryTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCEPT, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (p *SqlBaseParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *SqlBaseParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 60
	p.EnterRecursionRule(localctx, 60, SqlBaseParserRULE_queryTerm, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(1182)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1196)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_queryTerm)
				p.SetState(1184)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1185)

					var _m = p.Match(SqlBaseParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1187)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT {
					{
						p.SetState(1186)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(1189)

					var _x = p.queryTerm(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_queryTerm)
				p.SetState(1190)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1191)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserEXCEPT || _la == SqlBaseParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(1193)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT {
					{
						p.SetState(1192)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(1195)

					var _x = p.queryTerm(2)

					localctx.(*SetOperationContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyAll(ctx *QueryPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) QueryNoWith() IQueryNoWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryNoWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubquery(s)
	}
}

type QueryPrimaryDefaultContext struct {
	QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

type TableContext struct {
	QueryPrimaryContext
}

func NewTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableContext {
	var p = new(TableContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *TableContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTable(s)
	}
}

type InlineTableContext struct {
	QueryPrimaryContext
}

func NewInlineTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableContext {
	var p = new(InlineTableContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUES, 0)
}

func (s *InlineTableContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InlineTableContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (p *SqlBaseParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SqlBaseParserRULE_queryPrimary)
	var _alt int

	p.SetState(1217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1201)
			p.QuerySpecification()
		}

	case SqlBaseParserTABLE:
		localctx = NewTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1202)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1203)
			p.QualifiedName()
		}

	case SqlBaseParserVALUES:
		localctx = NewInlineTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1204)
			p.Match(SqlBaseParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1205)
			p.Expression()
		}
		p.SetState(1210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1206)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1207)
					p.Expression()
				}

			}
			p.SetState(1212)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case SqlBaseParserT__1:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1213)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1214)
			p.QueryNoWith()
		}
		{
			p.SetState(1215)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrdering returns the nullOrdering token.
	GetNullOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrdering sets the nullOrdering token.
	SetNullOrdering(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	NULLS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	ordering     antlr.Token
	nullOrdering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetNullOrdering() antlr.Token { return s.nullOrdering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetNullOrdering(v antlr.Token) { s.nullOrdering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAST, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (p *SqlBaseParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SqlBaseParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1219)
		p.Expression()
	}
	p.SetState(1221)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserASC || _la == SqlBaseParserDESC {
		{
			p.SetState(1220)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserASC || _la == SqlBaseParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserNULLS {
		{
			p.SetState(1223)
			p.Match(SqlBaseParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1224)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).nullOrdering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFIRST || _la == SqlBaseParserLAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).nullOrdering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IBooleanExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IBooleanExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IBooleanExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IBooleanExpressionContext)

	// Getter signatures
	SELECT() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	SetQuantifier() ISetQuantifierContext
	FROM() antlr.TerminalNode
	AllRelation() []IRelationContext
	Relation(i int) IRelationContext
	WHERE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	GroupBy() IGroupByContext
	HAVING() antlr.TerminalNode
	AllBooleanExpression() []IBooleanExpressionContext
	BooleanExpression(i int) IBooleanExpressionContext

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IBooleanExpressionContext
	having IBooleanExpressionContext
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *QuerySpecificationContext) GetHaving() IBooleanExpressionContext { return s.having }

func (s *QuerySpecificationContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *QuerySpecificationContext) SetHaving(v IBooleanExpressionContext) { s.having = v }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSELECT, 0)
}

func (s *QuerySpecificationContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QuerySpecificationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *QuerySpecificationContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *QuerySpecificationContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *QuerySpecificationContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *QuerySpecificationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUP, 0)
}

func (s *QuerySpecificationContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *QuerySpecificationContext) GroupBy() IGroupByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByContext)
}

func (s *QuerySpecificationContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHAVING, 0)
}

func (s *QuerySpecificationContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (p *SqlBaseParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SqlBaseParserRULE_querySpecification)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1227)
		p.Match(SqlBaseParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1229)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1228)
			p.SetQuantifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1231)
		p.SelectItem()
	}
	p.SetState(1236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1232)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1233)
				p.SelectItem()
			}

		}
		p.SetState(1238)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1248)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1239)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1240)
			p.relation(0)
		}
		p.SetState(1245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1241)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1242)
					p.relation(0)
				}

			}
			p.SetState(1247)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1252)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1250)
			p.Match(SqlBaseParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1251)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).where = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1257)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1254)
			p.Match(SqlBaseParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1255)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1256)
			p.GroupBy()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1261)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1259)
			p.Match(SqlBaseParserHAVING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1260)

			var _x = p.booleanExpression(0)

			localctx.(*QuerySpecificationContext).having = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByContext is an interface to support dynamic dispatch.
type IGroupByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGroupingElement() []IGroupingElementContext
	GroupingElement(i int) IGroupingElementContext
	SetQuantifier() ISetQuantifierContext

	// IsGroupByContext differentiates from other interfaces.
	IsGroupByContext()
}

type GroupByContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByContext() *GroupByContext {
	var p = new(GroupByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupBy
	return p
}

func InitEmptyGroupByContext(p *GroupByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupBy
}

func (*GroupByContext) IsGroupByContext() {}

func NewGroupByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByContext {
	var p = new(GroupByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupBy

	return p
}

func (s *GroupByContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByContext) AllGroupingElement() []IGroupingElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingElementContext); ok {
			len++
		}
	}

	tst := make([]IGroupingElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingElementContext); ok {
			tst[i] = t.(IGroupingElementContext)
			i++
		}
	}

	return tst
}

func (s *GroupByContext) GroupingElement(i int) IGroupingElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *GroupByContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *GroupByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGroupBy(s)
	}
}

func (s *GroupByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGroupBy(s)
	}
}

func (p *SqlBaseParser) GroupBy() (localctx IGroupByContext) {
	localctx = NewGroupByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SqlBaseParserRULE_groupBy)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1264)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1263)
			p.SetQuantifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1266)
		p.GroupingElement()
	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1267)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1268)
				p.GroupingElement()
			}

		}
		p.SetState(1273)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) CopyAll(ctx *GroupingElementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MultipleGroupingSetsContext struct {
	GroupingElementContext
}

func NewMultipleGroupingSetsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleGroupingSetsContext {
	var p = new(MultipleGroupingSetsContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *MultipleGroupingSetsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleGroupingSetsContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUPING, 0)
}

func (s *MultipleGroupingSetsContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETS, 0)
}

func (s *MultipleGroupingSetsContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *MultipleGroupingSetsContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *MultipleGroupingSetsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitMultipleGroupingSets(s)
	}
}

type SingleGroupingSetContext struct {
	GroupingElementContext
}

func NewSingleGroupingSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleGroupingSetContext {
	var p = new(SingleGroupingSetContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *SingleGroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleGroupingSetContext) GroupingSet() IGroupingSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *SingleGroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSingleGroupingSet(s)
	}
}

type CubeContext struct {
	GroupingElementContext
}

func NewCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CubeContext {
	var p = new(CubeContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *CubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCUBE, 0)
}

func (s *CubeContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CubeContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCube(s)
	}
}

func (s *CubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCube(s)
	}
}

type RollupContext struct {
	GroupingElementContext
}

func NewRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollupContext {
	var p = new(RollupContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *RollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLUP, 0)
}

func (s *RollupContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RollupContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRollup(s)
	}
}

func (s *RollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRollup(s)
	}
}

func (p *SqlBaseParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SqlBaseParserRULE_groupingElement)
	var _la int

	p.SetState(1314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 160, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSingleGroupingSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1274)
			p.GroupingSet()
		}

	case 2:
		localctx = NewRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1275)
			p.Match(SqlBaseParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1276)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7962443031269037020) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-76652614883829763) != 0) || ((int64((_la-133)) & ^0x3f) == 0 && ((int64(1)<<(_la-133))&-2450029150218524225) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&5763534400207532863) != 0) {
			{
				p.SetState(1277)
				p.Expression()
			}
			p.SetState(1282)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1278)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1279)
					p.Expression()
				}

				p.SetState(1284)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1287)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1288)
			p.Match(SqlBaseParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1289)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7962443031269037020) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-76652614883829763) != 0) || ((int64((_la-133)) & ^0x3f) == 0 && ((int64(1)<<(_la-133))&-2450029150218524225) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&5763534400207532863) != 0) {
			{
				p.SetState(1290)
				p.Expression()
			}
			p.SetState(1295)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1291)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1292)
					p.Expression()
				}

				p.SetState(1297)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1300)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewMultipleGroupingSetsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1301)
			p.Match(SqlBaseParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1302)
			p.Match(SqlBaseParserSETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1303)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1304)
			p.GroupingSet()
		}
		p.SetState(1309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1305)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1306)
				p.GroupingSet()
			}

			p.SetState(1311)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1312)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingSet
	return p
}

func InitEmptyGroupingSetContext(p *GroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupingSet
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (p *SqlBaseParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SqlBaseParserRULE_groupingSet)
	var _la int

	p.SetState(1329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1316)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7962443031269037020) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-76652614883829763) != 0) || ((int64((_la-133)) & ^0x3f) == 0 && ((int64(1)<<(_la-133))&-2450029150218524225) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&5763534400207532863) != 0) {
			{
				p.SetState(1317)
				p.Expression()
			}
			p.SetState(1322)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1318)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1319)
					p.Expression()
				}

				p.SetState(1324)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1327)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1328)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICubeGroupContext is an interface to support dynamic dispatch.
type ICubeGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsCubeGroupContext differentiates from other interfaces.
	IsCubeGroupContext()
}

type CubeGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCubeGroupContext() *CubeGroupContext {
	var p = new(CubeGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_cubeGroup
	return p
}

func InitEmptyCubeGroupContext(p *CubeGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_cubeGroup
}

func (*CubeGroupContext) IsCubeGroupContext() {}

func NewCubeGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CubeGroupContext {
	var p = new(CubeGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_cubeGroup

	return p
}

func (s *CubeGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *CubeGroupContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CubeGroupContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CubeGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubeGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CubeGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCubeGroup(s)
	}
}

func (s *CubeGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCubeGroup(s)
	}
}

func (p *SqlBaseParser) CubeGroup() (localctx ICubeGroupContext) {
	localctx = NewCubeGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SqlBaseParserRULE_cubeGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7963480973466883072) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-77497039822350423) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-306253643777315529) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&67553994443182899) != 0) {
		{
			p.SetState(1331)
			p.Identifier()
		}
		p.SetState(1336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1332)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1333)
				p.Identifier()
			}

			p.SetState(1338)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceFilterContext is an interface to support dynamic dispatch.
type ISourceFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsSourceFilterContext differentiates from other interfaces.
	IsSourceFilterContext()
}

type SourceFilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceFilterContext() *SourceFilterContext {
	var p = new(SourceFilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sourceFilter
	return p
}

func InitEmptySourceFilterContext(p *SourceFilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sourceFilter
}

func (*SourceFilterContext) IsSourceFilterContext() {}

func NewSourceFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceFilterContext {
	var p = new(SourceFilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sourceFilter

	return p
}

func (s *SourceFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceFilterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SourceFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSourceFilter(s)
	}
}

func (s *SourceFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSourceFilter(s)
	}
}

func (p *SqlBaseParser) SourceFilter() (localctx ISourceFilterContext) {
	localctx = NewSourceFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SqlBaseParserRULE_sourceFilter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1341)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedQueryContext is an interface to support dynamic dispatch.
type INamedQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	AS() antlr.TerminalNode
	Query() IQueryContext
	Identifier() IIdentifierContext
	ColumnAliases() IColumnAliasesContext

	// IsNamedQueryContext differentiates from other interfaces.
	IsNamedQueryContext()
}

type NamedQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyNamedQueryContext() *NamedQueryContext {
	var p = new(NamedQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedQuery
	return p
}

func InitEmptyNamedQueryContext(p *NamedQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_namedQuery
}

func (*NamedQueryContext) IsNamedQueryContext() {}

func NewNamedQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedQueryContext {
	var p = new(NamedQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_namedQuery

	return p
}

func (s *NamedQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedQueryContext) GetName() IIdentifierContext { return s.name }

func (s *NamedQueryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *NamedQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *NamedQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *NamedQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedQueryContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NamedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNamedQuery(s)
	}
}

func (s *NamedQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNamedQuery(s)
	}
}

func (p *SqlBaseParser) NamedQuery() (localctx INamedQueryContext) {
	localctx = NewNamedQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SqlBaseParserRULE_namedQuery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1343)

		var _x = p.Identifier()

		localctx.(*NamedQueryContext).name = _x
	}
	p.SetState(1345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserT__1 {
		{
			p.SetState(1344)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(1347)
		p.Match(SqlBaseParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1348)
		p.Match(SqlBaseParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1349)
		p.Query()
	}
	{
		p.SetState(1350)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (p *SqlBaseParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SqlBaseParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1352)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserALL || _la == SqlBaseParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_selectItem
	return p
}

func InitEmptySelectItemContext(p *SelectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_selectItem
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyAll(ctx *SelectItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SelectAllContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

type SelectSingleContext struct {
	SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (p *SqlBaseParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SqlBaseParserRULE_selectItem)
	var _la int

	p.SetState(1366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1354)
			p.Expression()
		}
		p.SetState(1359)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) == 1 {
			p.SetState(1356)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserAS {
				{
					p.SetState(1355)
					p.Match(SqlBaseParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1358)
				p.Identifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1361)
			p.QualifiedName()
		}
		{
			p.SetState(1362)
			p.Match(SqlBaseParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1363)
			p.Match(SqlBaseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1365)
			p.Match(SqlBaseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyAll(ctx *RelationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RelationDefaultContext struct {
	RelationContext
}

func NewRelationDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationDefaultContext {
	var p = new(RelationDefaultContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *RelationDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationDefaultContext) SampledRelation() ISampledRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampledRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *RelationDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRelationDefault(s)
	}
}

func (s *RelationDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRelationDefault(s)
	}
}

type JoinRelationContext struct {
	RelationContext
	left          IRelationContext
	right         ISampledRelationContext
	rightRelation IRelationContext
}

func NewJoinRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinRelationContext {
	var p = new(JoinRelationContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *JoinRelationContext) GetLeft() IRelationContext { return s.left }

func (s *JoinRelationContext) GetRight() ISampledRelationContext { return s.right }

func (s *JoinRelationContext) GetRightRelation() IRelationContext { return s.rightRelation }

func (s *JoinRelationContext) SetLeft(v IRelationContext) { s.left = v }

func (s *JoinRelationContext) SetRight(v ISampledRelationContext) { s.right = v }

func (s *JoinRelationContext) SetRightRelation(v IRelationContext) { s.rightRelation = v }

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *JoinRelationContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *JoinRelationContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCROSS, 0)
}

func (s *JoinRelationContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJOIN, 0)
}

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNATURAL, 0)
}

func (s *JoinRelationContext) SampledRelation() ISampledRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampledRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampledRelationContext)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *SqlBaseParser) Relation() (localctx IRelationContext) {
	return p.relation(0)
}

func (p *SqlBaseParser) relation(_p int) (localctx IRelationContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewRelationContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelationContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 84
	p.EnterRecursionRule(localctx, 84, SqlBaseParserRULE_relation, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewRelationDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(1369)
		p.SampledRelation()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewJoinRelationContext(p, NewRelationContext(p, _parentctx, _parentState))
			localctx.(*JoinRelationContext).left = _prevctx

			p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_relation)
			p.SetState(1371)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			p.SetState(1385)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case SqlBaseParserCROSS:
				{
					p.SetState(1372)
					p.Match(SqlBaseParserCROSS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1373)
					p.Match(SqlBaseParserJOIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1374)

					var _x = p.SampledRelation()

					localctx.(*JoinRelationContext).right = _x
				}

			case SqlBaseParserFULL, SqlBaseParserINNER, SqlBaseParserJOIN, SqlBaseParserLEFT, SqlBaseParserRIGHT:
				{
					p.SetState(1375)
					p.JoinType()
				}
				{
					p.SetState(1376)
					p.Match(SqlBaseParserJOIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1377)

					var _x = p.relation(0)

					localctx.(*JoinRelationContext).rightRelation = _x
				}
				{
					p.SetState(1378)
					p.JoinCriteria()
				}

			case SqlBaseParserNATURAL:
				{
					p.SetState(1380)
					p.Match(SqlBaseParserNATURAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1381)
					p.JoinType()
				}
				{
					p.SetState(1382)
					p.Match(SqlBaseParserJOIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1383)

					var _x = p.SampledRelation()

					localctx.(*JoinRelationContext).right = _x
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(1391)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INNER() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinType
	return p
}

func InitEmptyJoinTypeContext(p *JoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinType
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINNER, 0)
}

func (s *JoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT, 0)
}

func (s *JoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTER, 0)
}

func (s *JoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT, 0)
}

func (s *JoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFULL, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinType(s)
	}
}

func (s *JoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinType(s)
	}
}

func (p *SqlBaseParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SqlBaseParserRULE_joinType)
	var _la int

	p.SetState(1407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserINNER, SqlBaseParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserINNER {
			{
				p.SetState(1392)
				p.Match(SqlBaseParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SqlBaseParserLEFT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1395)
			p.Match(SqlBaseParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(1396)
				p.Match(SqlBaseParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SqlBaseParserRIGHT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1399)
			p.Match(SqlBaseParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1401)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(1400)
				p.Match(SqlBaseParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SqlBaseParserFULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1403)
			p.Match(SqlBaseParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1405)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(1404)
				p.Match(SqlBaseParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	USING() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinCriteria
	return p
}

func InitEmptyJoinCriteriaContext(p *JoinCriteriaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinCriteria
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSING, 0)
}

func (s *JoinCriteriaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *JoinCriteriaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (p *SqlBaseParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SqlBaseParserRULE_joinCriteria)
	var _la int

	p.SetState(1423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1409)
			p.Match(SqlBaseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1410)
			p.booleanExpression(0)
		}

	case SqlBaseParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1411)
			p.Match(SqlBaseParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1412)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1413)
			p.Identifier()
		}
		p.SetState(1418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1414)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1415)
				p.Identifier()
			}

			p.SetState(1420)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1421)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampledRelationContext is an interface to support dynamic dispatch.
type ISampledRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPercentage returns the percentage rule contexts.
	GetPercentage() IExpressionContext

	// SetPercentage sets the percentage rule contexts.
	SetPercentage(IExpressionContext)

	// Getter signatures
	AliasedRelation() IAliasedRelationContext
	TABLESAMPLE() antlr.TerminalNode
	SampleType() ISampleTypeContext
	Expression() IExpressionContext

	// IsSampledRelationContext differentiates from other interfaces.
	IsSampledRelationContext()
}

type SampledRelationContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	percentage IExpressionContext
}

func NewEmptySampledRelationContext() *SampledRelationContext {
	var p = new(SampledRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sampledRelation
	return p
}

func InitEmptySampledRelationContext(p *SampledRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sampledRelation
}

func (*SampledRelationContext) IsSampledRelationContext() {}

func NewSampledRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampledRelationContext {
	var p = new(SampledRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sampledRelation

	return p
}

func (s *SampledRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *SampledRelationContext) GetPercentage() IExpressionContext { return s.percentage }

func (s *SampledRelationContext) SetPercentage(v IExpressionContext) { s.percentage = v }

func (s *SampledRelationContext) AliasedRelation() IAliasedRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *SampledRelationContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLESAMPLE, 0)
}

func (s *SampledRelationContext) SampleType() ISampleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleTypeContext)
}

func (s *SampledRelationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampledRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampledRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampledRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSampledRelation(s)
	}
}

func (s *SampledRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSampledRelation(s)
	}
}

func (p *SqlBaseParser) SampledRelation() (localctx ISampledRelationContext) {
	localctx = NewSampledRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SqlBaseParserRULE_sampledRelation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1425)
		p.AliasedRelation()
	}
	p.SetState(1432)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1426)
			p.Match(SqlBaseParserTABLESAMPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1427)
			p.SampleType()
		}
		{
			p.SetState(1428)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1429)

			var _x = p.Expression()

			localctx.(*SampledRelationContext).percentage = _x
		}
		{
			p.SetState(1430)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleTypeContext is an interface to support dynamic dispatch.
type ISampleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BERNOULLI() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode

	// IsSampleTypeContext differentiates from other interfaces.
	IsSampleTypeContext()
}

type SampleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleTypeContext() *SampleTypeContext {
	var p = new(SampleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sampleType
	return p
}

func InitEmptySampleTypeContext(p *SampleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sampleType
}

func (*SampleTypeContext) IsSampleTypeContext() {}

func NewSampleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleTypeContext {
	var p = new(SampleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sampleType

	return p
}

func (s *SampleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleTypeContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBERNOULLI, 0)
}

func (s *SampleTypeContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM, 0)
}

func (s *SampleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSampleType(s)
	}
}

func (s *SampleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSampleType(s)
	}
}

func (p *SqlBaseParser) SampleType() (localctx ISampleTypeContext) {
	localctx = NewSampleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SqlBaseParserRULE_sampleType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1434)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserBERNOULLI || _la == SqlBaseParserSYSTEM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasedRelationContext is an interface to support dynamic dispatch.
type IAliasedRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	Identifier() IIdentifierContext
	AS() antlr.TerminalNode
	ColumnAliases() IColumnAliasesContext

	// IsAliasedRelationContext differentiates from other interfaces.
	IsAliasedRelationContext()
}

type AliasedRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedRelationContext() *AliasedRelationContext {
	var p = new(AliasedRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_aliasedRelation
	return p
}

func InitEmptyAliasedRelationContext(p *AliasedRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_aliasedRelation
}

func (*AliasedRelationContext) IsAliasedRelationContext() {}

func NewAliasedRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedRelationContext {
	var p = new(AliasedRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_aliasedRelation

	return p
}

func (s *AliasedRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *AliasedRelationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasedRelationContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *AliasedRelationContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *AliasedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAliasedRelation(s)
	}
}

func (p *SqlBaseParser) AliasedRelation() (localctx IAliasedRelationContext) {
	localctx = NewAliasedRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SqlBaseParserRULE_aliasedRelation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1436)
		p.RelationPrimary()
	}
	p.SetState(1444)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) == 1 {
		p.SetState(1438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserAS {
			{
				p.SetState(1437)
				p.Match(SqlBaseParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1440)
			p.Identifier()
		}
		p.SetState(1442)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1441)
				p.ColumnAliases()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnAliases
	return p
}

func InitEmptyColumnAliasesContext(p *ColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnAliases
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (p *SqlBaseParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SqlBaseParserRULE_columnAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1446)
		p.Match(SqlBaseParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1447)
		p.Identifier()
	}
	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__3 {
		{
			p.SetState(1448)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1449)
			p.Identifier()
		}

		p.SetState(1454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1455)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryRelationContext struct {
	RelationPrimaryContext
}

func NewSubqueryRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryRelationContext {
	var p = new(SubqueryRelationContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *SubqueryRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryRelationContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubqueryRelation(s)
	}
}

func (s *SubqueryRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubqueryRelation(s)
	}
}

type ParenthesizedRelationContext struct {
	RelationPrimaryContext
}

func NewParenthesizedRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedRelationContext {
	var p = new(ParenthesizedRelationContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *ParenthesizedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedRelationContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *ParenthesizedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitParenthesizedRelation(s)
	}
}

type UnnestContext struct {
	RelationPrimaryContext
}

func NewUnnestContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnnestContext {
	var p = new(UnnestContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *UnnestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnnestContext) UNNEST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNNEST, 0)
}

func (s *UnnestContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *UnnestContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnnestContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *UnnestContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDINALITY, 0)
}

func (s *UnnestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnnest(s)
	}
}

func (s *UnnestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnnest(s)
	}
}

type LateralContext struct {
	RelationPrimaryContext
}

func NewLateralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LateralContext {
	var p = new(LateralContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *LateralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLATERAL, 0)
}

func (s *LateralContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *LateralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLateral(s)
	}
}

func (s *LateralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLateral(s)
	}
}

type TableNameContext struct {
	RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *SqlBaseParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SqlBaseParserRULE_relationPrimary)
	var _la int

	p.SetState(1486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1457)
			p.QualifiedName()
		}

	case 2:
		localctx = NewSubqueryRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1458)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1459)
			p.Query()
		}
		{
			p.SetState(1460)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewUnnestContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1462)
			p.Match(SqlBaseParserUNNEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1463)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1464)
			p.Expression()
		}
		p.SetState(1469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1465)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1466)
				p.Expression()
			}

			p.SetState(1471)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1472)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1475)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1473)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1474)
				p.Match(SqlBaseParserORDINALITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewLateralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1477)
			p.Match(SqlBaseParserLATERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1478)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1479)
			p.Query()
		}
		{
			p.SetState(1480)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewParenthesizedRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1482)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1483)
			p.relation(0)
		}
		{
			p.SetState(1484)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanExpression() IBooleanExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *SqlBaseParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SqlBaseParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1488)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type PredicatedContext struct {
	BooleanExpressionContext
	_valueExpression IValueExpressionContext
}

func NewPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicatedContext {
	var p = new(PredicatedContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *PredicatedContext) Get_valueExpression() IValueExpressionContext { return s._valueExpression }

func (s *PredicatedContext) Set_valueExpression(v IValueExpressionContext) { s._valueExpression = v }

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPredicated(s)
	}
}

type LogicalBinaryContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (p *SqlBaseParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *SqlBaseParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 102
	p.EnterRecursionRule(localctx, 102, SqlBaseParserRULE_booleanExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserT__1, SqlBaseParserT__4, SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCASE, SqlBaseParserCAST, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserCURRENT_DATE, SqlBaseParserCURRENT_PATH, SqlBaseParserCURRENT_TIME, SqlBaseParserCURRENT_TIMESTAMP, SqlBaseParserCURRENT_USER, SqlBaseParserDATA, SqlBaseParserDATABASE, SqlBaseParserDATABASES, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXISTS, SqlBaseParserEXPLAIN, SqlBaseParserEXTRACT, SqlBaseParserEXTERNAL, SqlBaseParserFALSE, SqlBaseParserFETCH, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserGROUPING, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOCALTIME, SqlBaseParserLOCALTIMESTAMP, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNEXT, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNORMALIZE, SqlBaseParserNULL, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPATH, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEXT, SqlBaseParserTIES, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRUE, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserVIEWS, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserINDEX, SqlBaseParserPLUS, SqlBaseParserMINUS, SqlBaseParserSTRING, SqlBaseParserUNICODE_STRING, SqlBaseParserBINARY_LITERAL, SqlBaseParserINTEGER_VALUE, SqlBaseParserDECIMAL_VALUE, SqlBaseParserDOUBLE_VALUE, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER, SqlBaseParserDOUBLE_PRECISION:
		localctx = NewPredicatedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1491)

			var _x = p.valueExpression(0)

			localctx.(*PredicatedContext)._valueExpression = _x
		}
		p.SetState(1493)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 187, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1492)
				p.Predicate(localctx.(*PredicatedContext).Get_valueExpression())
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case SqlBaseParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1495)
			p.Match(SqlBaseParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1496)
			p.booleanExpression(3)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1505)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_booleanExpression)
				p.SetState(1499)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1500)

					var _m = p.Match(SqlBaseParserAND)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1501)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_booleanExpression)
				p.SetState(1502)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1503)

					var _m = p.Match(SqlBaseParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1504)

					var _x = p.booleanExpression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1509)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value attribute.
	GetValue() antlr.ParserRuleContext

	// SetValue sets the value attribute.
	SetValue(antlr.ParserRuleContext)

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.ParserRuleContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, value antlr.ParserRuleContext) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_predicate

	p.value = value

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetValue() antlr.ParserRuleContext { return s.value }

func (s *PredicateContext) SetValue(v antlr.ParserRuleContext) { s.value = v }

func (s *PredicateContext) CopyAll(ctx *PredicateContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
	s.value = ctx.value
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	PredicateContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitComparison(s)
	}
}

type LikeContext struct {
	PredicateContext
	pattern IValueExpressionContext
	escape  IValueExpressionContext
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) GetEscape() IValueExpressionContext { return s.escape }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) SetEscape(v IValueExpressionContext) { s.escape = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *LikeContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LikeContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *LikeContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLike(s)
	}
}

type InSubqueryContext struct {
	PredicateContext
}

func NewInSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InSubqueryContext {
	var p = new(InSubqueryContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *InSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *InSubqueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *InSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInSubquery(s)
	}
}

func (s *InSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInSubquery(s)
	}
}

type DistinctFromContext struct {
	PredicateContext
	right IValueExpressionContext
}

func NewDistinctFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DistinctFromContext {
	var p = new(DistinctFromContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *DistinctFromContext) GetRight() IValueExpressionContext { return s.right }

func (s *DistinctFromContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *DistinctFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctFromContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *DistinctFromContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTINCT, 0)
}

func (s *DistinctFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *DistinctFromContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DistinctFromContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *DistinctFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDistinctFrom(s)
	}
}

func (s *DistinctFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDistinctFrom(s)
	}
}

type InListContext struct {
	PredicateContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *InListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInList(s)
	}
}

type NullPredicateContext struct {
	PredicateContext
}

func NewNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullPredicateContext {
	var p = new(NullPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *NullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *NullPredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *NullPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *NullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNullPredicate(s)
	}
}

func (s *NullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNullPredicate(s)
	}
}

type BetweenContext struct {
	PredicateContext
	lower IValueExpressionContext
	upper IValueExpressionContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *BetweenContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BetweenContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBetween(s)
	}
}

type QuantifiedComparisonContext struct {
	PredicateContext
}

func NewQuantifiedComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuantifiedComparisonContext {
	var p = new(QuantifiedComparisonContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *QuantifiedComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *QuantifiedComparisonContext) ComparisonQuantifier() IComparisonQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonQuantifierContext)
}

func (s *QuantifiedComparisonContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QuantifiedComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuantifiedComparison(s)
	}
}

func (s *QuantifiedComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuantifiedComparison(s)
	}
}

func (p *SqlBaseParser) Predicate(value antlr.ParserRuleContext) (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState(), value)
	p.EnterRule(localctx, 104, SqlBaseParserRULE_predicate)
	var _la int

	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1510)
			p.ComparisonOperator()
		}
		{
			p.SetState(1511)

			var _x = p.valueExpression(0)

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		localctx = NewQuantifiedComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1513)
			p.ComparisonOperator()
		}
		{
			p.SetState(1514)
			p.ComparisonQuantifier()
		}
		{
			p.SetState(1515)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1516)
			p.Query()
		}
		{
			p.SetState(1517)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(1519)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1522)
			p.Match(SqlBaseParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1523)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(1524)
			p.Match(SqlBaseParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1525)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).upper = _x
		}

	case 4:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(1527)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1530)
			p.Match(SqlBaseParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1531)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1532)
			p.Expression()
		}
		p.SetState(1537)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1533)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1534)
				p.Expression()
			}

			p.SetState(1539)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1540)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewInSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(1542)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1545)
			p.Match(SqlBaseParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1546)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1547)
			p.Query()
		}
		{
			p.SetState(1548)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1551)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(1550)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1553)
			p.Match(SqlBaseParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1554)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}
		p.SetState(1557)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1555)
				p.Match(SqlBaseParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1556)

				var _x = p.valueExpression(0)

				localctx.(*LikeContext).escape = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		localctx = NewNullPredicateContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1559)
			p.Match(SqlBaseParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(1560)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1563)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewDistinctFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1564)
			p.Match(SqlBaseParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1566)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(1565)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1568)
			p.Match(SqlBaseParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1569)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1570)

			var _x = p.valueExpression(0)

			localctx.(*DistinctFromContext).right = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ConcatenationContext struct {
	ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationContext {
	var p = new(ConcatenationContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConcatenationContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ConcatenationContext) GetRight() IValueExpressionContext { return s.right }

func (s *ConcatenationContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ConcatenationContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONCAT, 0)
}

func (s *ConcatenationContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConcatenationContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPERCENT, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type ArithmeticUnaryContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

type AtTimeZoneContext struct {
	ValueExpressionContext
}

func NewAtTimeZoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtTimeZoneContext {
	var p = new(AtTimeZoneContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *AtTimeZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtTimeZoneContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AtTimeZoneContext) AT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAT, 0)
}

func (s *AtTimeZoneContext) TimeZoneSpecifier() ITimeZoneSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeZoneSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeZoneSpecifierContext)
}

func (s *AtTimeZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAtTimeZone(s)
	}
}

func (p *SqlBaseParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *SqlBaseParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 106
	p.EnterRecursionRule(localctx, 106, SqlBaseParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1574)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1575)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1576)
			p.valueExpression(4)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1593)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1591)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(1579)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1580)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-243)) & ^0x3f) == 0 && ((int64(1)<<(_la-243))&7) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1581)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(1582)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1583)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1584)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewConcatenationContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatenationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(1585)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(1586)
					p.Match(SqlBaseParserCONCAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1587)

					var _x = p.valueExpression(2)

					localctx.(*ConcatenationContext).right = _x
				}

			case 4:
				localctx = NewAtTimeZoneContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(1588)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1589)
					p.Match(SqlBaseParserAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1590)
					p.TimeZoneSpecifier()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1595)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDereference(s)
	}
}

type TypeConstructorContext struct {
	PrimaryExpressionContext
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeConstructorContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *TypeConstructorContext) DOUBLE_PRECISION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE_PRECISION, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

type SpecialDateTimeFunctionContext struct {
	PrimaryExpressionContext
	name      antlr.Token
	precision antlr.Token
}

func NewSpecialDateTimeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDateTimeFunctionContext {
	var p = new(SpecialDateTimeFunctionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SpecialDateTimeFunctionContext) GetName() antlr.Token { return s.name }

func (s *SpecialDateTimeFunctionContext) GetPrecision() antlr.Token { return s.precision }

func (s *SpecialDateTimeFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *SpecialDateTimeFunctionContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *SpecialDateTimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeFunctionContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_DATE, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_TIME, 0)
}

func (s *SpecialDateTimeFunctionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *SpecialDateTimeFunctionContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_TIMESTAMP, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCALTIME, 0)
}

func (s *SpecialDateTimeFunctionContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOCALTIMESTAMP, 0)
}

func (s *SpecialDateTimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSpecialDateTimeFunction(s)
	}
}

func (s *SpecialDateTimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSpecialDateTimeFunction(s)
	}
}

type SubstringContext struct {
	PrimaryExpressionContext
}

func NewSubstringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstringContext {
	var p = new(SubstringContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstringContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBSTRING, 0)
}

func (s *SubstringContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubstringContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubstringContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *SubstringContext) FOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOR, 0)
}

func (s *SubstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubstring(s)
	}
}

func (s *SubstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubstring(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CastContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CastContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRY_CAST, 0)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCast(s)
	}
}

type LambdaContext struct {
	PrimaryExpressionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLambda(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type ParameterContext struct {
	PrimaryExpressionContext
}

func NewParameterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParameterContext {
	var p = new(ParameterContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitParameter(s)
	}
}

type NormalizeContext struct {
	PrimaryExpressionContext
}

func NewNormalizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NormalizeContext {
	var p = new(NormalizeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NormalizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizeContext) NORMALIZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNORMALIZE, 0)
}

func (s *NormalizeContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *NormalizeContext) NormalForm() INormalFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormalFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormalFormContext)
}

func (s *NormalizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNormalize(s)
	}
}

func (s *NormalizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNormalize(s)
	}
}

type IntervalLiteralContext struct {
	PrimaryExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

type NumericLiteralContext struct {
	PrimaryExpressionContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

type BooleanLiteralContext struct {
	PrimaryExpressionContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, 0)
}

func (s *SimpleCaseContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *SimpleCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type ColumnReferenceContext struct {
	PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type NullLiteralContext struct {
	PrimaryExpressionContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type RowConstructorContext struct {
	PrimaryExpressionContext
}

func NewRowConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RowConstructorContext {
	var p = new(RowConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RowConstructorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RowConstructorContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

type SubscriptContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubscript(s)
	}
}

type CurrentPathContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentPathContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentPathContext {
	var p = new(CurrentPathContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentPathContext) GetName() antlr.Token { return s.name }

func (s *CurrentPathContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentPathContext) CURRENT_PATH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_PATH, 0)
}

func (s *CurrentPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCurrentPath(s)
	}
}

func (s *CurrentPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCurrentPath(s)
	}
}

type SubqueryExpressionContext struct {
	PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

type BinaryLiteralContext struct {
	PrimaryExpressionContext
}

func NewBinaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryLiteralContext {
	var p = new(BinaryLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *BinaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryLiteralContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBINARY_LITERAL, 0)
}

func (s *BinaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBinaryLiteral(s)
	}
}

type CurrentUserContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserContext {
	var p = new(CurrentUserContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentUserContext) GetName() antlr.Token { return s.name }

func (s *CurrentUserContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_USER, 0)
}

func (s *CurrentUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCurrentUser(s)
	}
}

func (s *CurrentUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCurrentUser(s)
	}
}

type ExtractContext struct {
	PrimaryExpressionContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTRACT, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExtract(s)
	}
}

type StringLiteralContext struct {
	PrimaryExpressionContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type ArrayConstructorContext struct {
	PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *ArrayConstructorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayConstructorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

type FunctionCallContext struct {
	PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *FunctionCallContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *FunctionCallContext) Filter() IFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterContext)
}

func (s *FunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *FunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *FunctionCallContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *FunctionCallContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *FunctionCallContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *FunctionCallContext) NullTreatment() INullTreatmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullTreatmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullTreatmentContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type ExistsContext struct {
	PrimaryExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *ExistsContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExists(s)
	}
}

type PositionContext struct {
	PrimaryExpressionContext
}

func NewPositionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionContext {
	var p = new(PositionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *PositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPOSITION, 0)
}

func (s *PositionContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PositionContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PositionContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *PositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPosition(s)
	}
}

func (s *PositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPosition(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

type GroupingOperationContext struct {
	PrimaryExpressionContext
}

func NewGroupingOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupingOperationContext {
	var p = new(GroupingOperationContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *GroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingOperationContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUPING, 0)
}

func (s *GroupingOperationContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *GroupingOperationContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *GroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGroupingOperation(s)
	}
}

func (p *SqlBaseParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *SqlBaseParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 108
	p.EnterRecursionRule(localctx, 108, SqlBaseParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 231, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1597)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1598)
			p.Interval()
		}

	case 3:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1599)
			p.Identifier()
		}
		{
			p.SetState(1600)
			p.String_()
		}

	case 4:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1602)
			p.Match(SqlBaseParserDOUBLE_PRECISION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1603)
			p.String_()
		}

	case 5:
		localctx = NewNumericLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1604)
			p.Number()
		}

	case 6:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1605)
			p.BooleanValue()
		}

	case 7:
		localctx = NewStringLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1606)
			p.String_()
		}

	case 8:
		localctx = NewBinaryLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1607)
			p.Match(SqlBaseParserBINARY_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewParameterContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1608)
			p.Match(SqlBaseParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewPositionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1609)
			p.Match(SqlBaseParserPOSITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1610)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1611)
			p.valueExpression(0)
		}
		{
			p.SetState(1612)
			p.Match(SqlBaseParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1613)
			p.valueExpression(0)
		}
		{
			p.SetState(1614)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1616)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1617)
			p.Expression()
		}
		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserT__3 {
			{
				p.SetState(1618)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1619)
				p.Expression()
			}

			p.SetState(1622)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1624)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewRowConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1626)
			p.Match(SqlBaseParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1627)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1628)
			p.Expression()
		}
		p.SetState(1633)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1629)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1630)
				p.Expression()
			}

			p.SetState(1635)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1636)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1638)
			p.QualifiedName()
		}
		{
			p.SetState(1639)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1640)
			p.Match(SqlBaseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1641)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1643)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1642)
				p.Filter()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1646)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1645)
				p.Over()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 14:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1648)
			p.QualifiedName()
		}
		{
			p.SetState(1649)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3350757012841649116) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-76652614883829763) != 0) || ((int64((_la-133)) & ^0x3f) == 0 && ((int64(1)<<(_la-133))&-2450029150218524225) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&5763534400207532863) != 0) {
			p.SetState(1651)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1650)
					p.SetQuantifier()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1653)
				p.Expression()
			}
			p.SetState(1658)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1654)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1655)
					p.Expression()
				}

				p.SetState(1660)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserORDER {
			{
				p.SetState(1663)
				p.Match(SqlBaseParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1664)
				p.Match(SqlBaseParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1665)
				p.SortItem()
			}
			p.SetState(1670)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1666)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1667)
					p.SortItem()
				}

				p.SetState(1672)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1675)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1677)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1676)
				p.Filter()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1683)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext()) == 1 {
			p.SetState(1680)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserIGNORE || _la == SqlBaseParserRESPECT {
				{
					p.SetState(1679)
					p.NullTreatment()
				}

			}
			{
				p.SetState(1682)
				p.Over()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 15:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1685)
			p.Identifier()
		}
		{
			p.SetState(1686)
			p.Match(SqlBaseParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1687)
			p.Expression()
		}

	case 16:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1689)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7963480973466883072) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-77497039822350423) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-306253643777315529) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&67553994443182899) != 0) {
			{
				p.SetState(1690)
				p.Identifier()
			}
			p.SetState(1695)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1691)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1692)
					p.Identifier()
				}

				p.SetState(1697)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1700)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1701)
			p.Match(SqlBaseParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1702)
			p.Expression()
		}

	case 17:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1703)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1704)
			p.Query()
		}
		{
			p.SetState(1705)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1707)
			p.Match(SqlBaseParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1708)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1709)
			p.Query()
		}
		{
			p.SetState(1710)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1712)
			p.Match(SqlBaseParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1713)
			p.valueExpression(0)
		}
		p.SetState(1715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserWHEN {
			{
				p.SetState(1714)
				p.WhenClause()
			}

			p.SetState(1717)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserELSE {
			{
				p.SetState(1719)
				p.Match(SqlBaseParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1720)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(1723)
			p.Match(SqlBaseParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1725)
			p.Match(SqlBaseParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserWHEN {
			{
				p.SetState(1726)
				p.WhenClause()
			}

			p.SetState(1729)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserELSE {
			{
				p.SetState(1731)
				p.Match(SqlBaseParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1732)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(1735)
			p.Match(SqlBaseParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1737)
			p.Match(SqlBaseParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1738)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1739)
			p.Expression()
		}
		{
			p.SetState(1740)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1741)
			p.type_(0)
		}
		{
			p.SetState(1742)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1744)
			p.Match(SqlBaseParserTRY_CAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1745)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1746)
			p.Expression()
		}
		{
			p.SetState(1747)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1748)
			p.type_(0)
		}
		{
			p.SetState(1749)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1751)
			p.Match(SqlBaseParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1752)
			p.Match(SqlBaseParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7962443031269037020) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-76652614883829763) != 0) || ((int64((_la-133)) & ^0x3f) == 0 && ((int64(1)<<(_la-133))&-2450029150218524225) != 0) || ((int64((_la-197)) & ^0x3f) == 0 && ((int64(1)<<(_la-197))&5763534400207532863) != 0) {
			{
				p.SetState(1753)
				p.Expression()
			}
			p.SetState(1758)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1754)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1755)
					p.Expression()
				}

				p.SetState(1760)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1763)
			p.Match(SqlBaseParserT__7)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1764)
			p.Identifier()
		}

	case 25:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1765)

			var _m = p.Match(SqlBaseParserCURRENT_DATE)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1766)

			var _m = p.Match(SqlBaseParserCURRENT_TIME)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1770)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1767)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1768)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1769)
				p.Match(SqlBaseParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 27:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1772)

			var _m = p.Match(SqlBaseParserCURRENT_TIMESTAMP)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1776)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1773)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1774)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1775)
				p.Match(SqlBaseParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 28:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1778)

			var _m = p.Match(SqlBaseParserLOCALTIME)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1782)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1779)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1780)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1781)
				p.Match(SqlBaseParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 29:
		localctx = NewSpecialDateTimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1784)

			var _m = p.Match(SqlBaseParserLOCALTIMESTAMP)

			localctx.(*SpecialDateTimeFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1788)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 226, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1785)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1786)

				var _m = p.Match(SqlBaseParserINTEGER_VALUE)

				localctx.(*SpecialDateTimeFunctionContext).precision = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1787)
				p.Match(SqlBaseParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 30:
		localctx = NewCurrentUserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1790)

			var _m = p.Match(SqlBaseParserCURRENT_USER)

			localctx.(*CurrentUserContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 31:
		localctx = NewCurrentPathContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1791)

			var _m = p.Match(SqlBaseParserCURRENT_PATH)

			localctx.(*CurrentPathContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 32:
		localctx = NewSubstringContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1792)
			p.Match(SqlBaseParserSUBSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1793)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1794)
			p.valueExpression(0)
		}
		{
			p.SetState(1795)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1796)
			p.valueExpression(0)
		}
		p.SetState(1799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserFOR {
			{
				p.SetState(1797)
				p.Match(SqlBaseParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1798)
				p.valueExpression(0)
			}

		}
		{
			p.SetState(1801)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		localctx = NewNormalizeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1803)
			p.Match(SqlBaseParserNORMALIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1804)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1805)
			p.valueExpression(0)
		}
		p.SetState(1808)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__3 {
			{
				p.SetState(1806)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1807)
				p.NormalForm()
			}

		}
		{
			p.SetState(1810)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		localctx = NewExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1812)
			p.Match(SqlBaseParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1813)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1814)
			p.Identifier()
		}
		{
			p.SetState(1815)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1816)
			p.valueExpression(0)
		}
		{
			p.SetState(1817)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1819)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1820)
			p.Expression()
		}
		{
			p.SetState(1821)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		localctx = NewGroupingOperationContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1823)
			p.Match(SqlBaseParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1824)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1833)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7963480973466883072) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-77497039822350423) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-306253643777315529) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&67553994443182899) != 0) {
			{
				p.SetState(1825)
				p.QualifiedName()
			}
			p.SetState(1830)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1826)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1827)
					p.QualifiedName()
				}

				p.SetState(1832)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1835)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1846)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(1838)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(1839)
					p.Match(SqlBaseParserT__6)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1840)

					var _x = p.valueExpression(0)

					localctx.(*SubscriptContext).index = _x
				}
				{
					p.SetState(1841)
					p.Match(SqlBaseParserT__7)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(1843)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(1844)
					p.Match(SqlBaseParserT__0)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1845)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) CopyAll(ctx *StringContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnicodeStringLiteralContext struct {
	StringContext
}

func NewUnicodeStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnicodeStringLiteralContext {
	var p = new(UnicodeStringLiteralContext)

	InitEmptyStringContext(&p.StringContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringContext))

	return p
}

func (s *UnicodeStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnicodeStringLiteralContext) UNICODE_STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNICODE_STRING, 0)
}

func (s *UnicodeStringLiteralContext) UESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUESCAPE, 0)
}

func (s *UnicodeStringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *UnicodeStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnicodeStringLiteral(s)
	}
}

func (s *UnicodeStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnicodeStringLiteral(s)
	}
}

type BasicStringLiteralContext struct {
	StringContext
}

func NewBasicStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BasicStringLiteralContext {
	var p = new(BasicStringLiteralContext)

	InitEmptyStringContext(&p.StringContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringContext))

	return p
}

func (s *BasicStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicStringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *BasicStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBasicStringLiteral(s)
	}
}

func (s *BasicStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBasicStringLiteral(s)
	}
}

func (p *SqlBaseParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SqlBaseParserRULE_string)
	p.SetState(1857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserSTRING:
		localctx = NewBasicStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1851)
			p.Match(SqlBaseParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserUNICODE_STRING:
		localctx = NewUnicodeStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1852)
			p.Match(SqlBaseParserUNICODE_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1855)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 234, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1853)
				p.Match(SqlBaseParserUESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1854)
				p.Match(SqlBaseParserSTRING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullTreatmentContext is an interface to support dynamic dispatch.
type INullTreatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IGNORE() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	RESPECT() antlr.TerminalNode

	// IsNullTreatmentContext differentiates from other interfaces.
	IsNullTreatmentContext()
}

type NullTreatmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullTreatmentContext() *NullTreatmentContext {
	var p = new(NullTreatmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nullTreatment
	return p
}

func InitEmptyNullTreatmentContext(p *NullTreatmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nullTreatment
}

func (*NullTreatmentContext) IsNullTreatmentContext() {}

func NewNullTreatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullTreatmentContext {
	var p = new(NullTreatmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_nullTreatment

	return p
}

func (s *NullTreatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *NullTreatmentContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIGNORE, 0)
}

func (s *NullTreatmentContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *NullTreatmentContext) RESPECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESPECT, 0)
}

func (s *NullTreatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullTreatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullTreatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNullTreatment(s)
	}
}

func (s *NullTreatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNullTreatment(s)
	}
}

func (p *SqlBaseParser) NullTreatment() (localctx INullTreatmentContext) {
	localctx = NewNullTreatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SqlBaseParserRULE_nullTreatment)
	p.SetState(1863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserIGNORE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1859)
			p.Match(SqlBaseParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1860)
			p.Match(SqlBaseParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserRESPECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1861)
			p.Match(SqlBaseParserRESPECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1862)
			p.Match(SqlBaseParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeZoneSpecifierContext is an interface to support dynamic dispatch.
type ITimeZoneSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTimeZoneSpecifierContext differentiates from other interfaces.
	IsTimeZoneSpecifierContext()
}

type TimeZoneSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeZoneSpecifierContext() *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_timeZoneSpecifier
	return p
}

func InitEmptyTimeZoneSpecifierContext(p *TimeZoneSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_timeZoneSpecifier
}

func (*TimeZoneSpecifierContext) IsTimeZoneSpecifierContext() {}

func NewTimeZoneSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_timeZoneSpecifier

	return p
}

func (s *TimeZoneSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeZoneSpecifierContext) CopyAll(ctx *TimeZoneSpecifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TimeZoneSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TimeZoneIntervalContext struct {
	TimeZoneSpecifierContext
}

func NewTimeZoneIntervalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneIntervalContext {
	var p = new(TimeZoneIntervalContext)

	InitEmptyTimeZoneSpecifierContext(&p.TimeZoneSpecifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneIntervalContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *TimeZoneIntervalContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *TimeZoneIntervalContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *TimeZoneIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTimeZoneInterval(s)
	}
}

func (s *TimeZoneIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTimeZoneInterval(s)
	}
}

type TimeZoneStringContext struct {
	TimeZoneSpecifierContext
}

func NewTimeZoneStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneStringContext {
	var p = new(TimeZoneStringContext)

	InitEmptyTimeZoneSpecifierContext(&p.TimeZoneSpecifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneStringContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *TimeZoneStringContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *TimeZoneStringContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *TimeZoneStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTimeZoneString(s)
	}
}

func (p *SqlBaseParser) TimeZoneSpecifier() (localctx ITimeZoneSpecifierContext) {
	localctx = NewTimeZoneSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SqlBaseParserRULE_timeZoneSpecifier)
	p.SetState(1871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTimeZoneIntervalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1865)
			p.Match(SqlBaseParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1866)
			p.Match(SqlBaseParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1867)
			p.Interval()
		}

	case 2:
		localctx = NewTimeZoneStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1868)
			p.Match(SqlBaseParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1869)
			p.Match(SqlBaseParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1870)
			p.String_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GTE() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGTE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *SqlBaseParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SqlBaseParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1873)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-235)) & ^0x3f) == 0 && ((int64(1)<<(_la-235))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonQuantifierContext is an interface to support dynamic dispatch.
type IComparisonQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	SOME() antlr.TerminalNode
	ANY() antlr.TerminalNode

	// IsComparisonQuantifierContext differentiates from other interfaces.
	IsComparisonQuantifierContext()
}

type ComparisonQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonQuantifierContext() *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comparisonQuantifier
	return p
}

func InitEmptyComparisonQuantifierContext(p *ComparisonQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comparisonQuantifier
}

func (*ComparisonQuantifierContext) IsComparisonQuantifierContext() {}

func NewComparisonQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonQuantifierContext {
	var p = new(ComparisonQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_comparisonQuantifier

	return p
}

func (s *ComparisonQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *ComparisonQuantifierContext) SOME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOME, 0)
}

func (s *ComparisonQuantifierContext) ANY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANY, 0)
}

func (s *ComparisonQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterComparisonQuantifier(s)
	}
}

func (s *ComparisonQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitComparisonQuantifier(s)
	}
}

func (p *SqlBaseParser) ComparisonQuantifier() (localctx IComparisonQuantifierContext) {
	localctx = NewComparisonQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SqlBaseParserRULE_comparisonQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1875)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserALL || _la == SqlBaseParserANY || _la == SqlBaseParserSOME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregationsContext is an interface to support dynamic dispatch.
type IAggregationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsAggregationsContext differentiates from other interfaces.
	IsAggregationsContext()
}

type AggregationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationsContext() *AggregationsContext {
	var p = new(AggregationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_aggregations
	return p
}

func InitEmptyAggregationsContext(p *AggregationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_aggregations
}

func (*AggregationsContext) IsAggregationsContext() {}

func NewAggregationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationsContext {
	var p = new(AggregationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_aggregations

	return p
}

func (s *AggregationsContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AggregationsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AggregationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAggregations(s)
	}
}

func (s *AggregationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAggregations(s)
	}
}

func (p *SqlBaseParser) Aggregations() (localctx IAggregationsContext) {
	localctx = NewAggregationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SqlBaseParserRULE_aggregations)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1877)
		p.Expression()
	}
	p.SetState(1882)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__3 {
		{
			p.SetState(1878)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1879)
			p.Expression()
		}

		p.SetState(1884)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *SqlBaseParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SqlBaseParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1885)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserFALSE || _la == SqlBaseParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BITMAP() antlr.TerminalNode
	BLOOM() antlr.TerminalNode
	MINMAX() antlr.TerminalNode
	BTREE() antlr.TerminalNode

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBITMAP, 0)
}

func (s *IndexTypeContext) BLOOM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBLOOM, 0)
}

func (s *IndexTypeContext) MINMAX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINMAX, 0)
}

func (s *IndexTypeContext) BTREE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBTREE, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (p *SqlBaseParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SqlBaseParserRULE_indexType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1887)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-226)) & ^0x3f) == 0 && ((int64(1)<<(_la-226))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSign returns the sign token.
	GetSign() antlr.Token

	// SetSign sets the sign token.
	SetSign(antlr.Token)

	// GetFrom returns the from rule contexts.
	GetFrom() IIntervalFieldContext

	// GetTo returns the to rule contexts.
	GetTo() IIntervalFieldContext

	// SetFrom sets the from rule contexts.
	SetFrom(IIntervalFieldContext)

	// SetTo sets the to rule contexts.
	SetTo(IIntervalFieldContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	String_() IStringContext
	AllIntervalField() []IIntervalFieldContext
	IntervalField(i int) IIntervalFieldContext
	TO() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	sign   antlr.Token
	from   IIntervalFieldContext
	to     IIntervalFieldContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetSign() antlr.Token { return s.sign }

func (s *IntervalContext) SetSign(v antlr.Token) { s.sign = v }

func (s *IntervalContext) GetFrom() IIntervalFieldContext { return s.from }

func (s *IntervalContext) GetTo() IIntervalFieldContext { return s.to }

func (s *IntervalContext) SetFrom(v IIntervalFieldContext) { s.from = v }

func (s *IntervalContext) SetTo(v IIntervalFieldContext) { s.to = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *IntervalContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *IntervalContext) AllIntervalField() []IIntervalFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalFieldContext); ok {
			len++
		}
	}

	tst := make([]IIntervalFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalFieldContext); ok {
			tst[i] = t.(IIntervalFieldContext)
			i++
		}
	}

	return tst
}

func (s *IntervalContext) IntervalField(i int) IIntervalFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalFieldContext)
}

func (s *IntervalContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *IntervalContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *IntervalContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (p *SqlBaseParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SqlBaseParserRULE_interval)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1889)
		p.Match(SqlBaseParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS {
		{
			p.SetState(1890)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IntervalContext).sign = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IntervalContext).sign = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1893)
		p.String_()
	}
	{
		p.SetState(1894)

		var _x = p.IntervalField()

		localctx.(*IntervalContext).from = _x
	}
	p.SetState(1897)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1895)
			p.Match(SqlBaseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1896)

			var _x = p.IntervalField()

			localctx.(*IntervalContext).to = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalFieldContext is an interface to support dynamic dispatch.
type IIntervalFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode

	// IsIntervalFieldContext differentiates from other interfaces.
	IsIntervalFieldContext()
}

type IntervalFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalFieldContext() *IntervalFieldContext {
	var p = new(IntervalFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_intervalField
	return p
}

func InitEmptyIntervalFieldContext(p *IntervalFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_intervalField
}

func (*IntervalFieldContext) IsIntervalFieldContext() {}

func NewIntervalFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalFieldContext {
	var p = new(IntervalFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_intervalField

	return p
}

func (s *IntervalFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalFieldContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *IntervalFieldContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, 0)
}

func (s *IntervalFieldContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *IntervalFieldContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *IntervalFieldContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *IntervalFieldContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *IntervalFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIntervalField(s)
	}
}

func (s *IntervalFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIntervalField(s)
	}
}

func (p *SqlBaseParser) IntervalField() (localctx IIntervalFieldContext) {
	localctx = NewIntervalFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SqlBaseParserRULE_intervalField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1899)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserDAY || ((int64((_la-94)) & ^0x3f) == 0 && ((int64(1)<<(_la-94))&805306369) != 0) || _la == SqlBaseParserSECOND || _la == SqlBaseParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INormalFormContext is an interface to support dynamic dispatch.
type INormalFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NFD() antlr.TerminalNode
	NFC() antlr.TerminalNode
	NFKD() antlr.TerminalNode
	NFKC() antlr.TerminalNode

	// IsNormalFormContext differentiates from other interfaces.
	IsNormalFormContext()
}

type NormalFormContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalFormContext() *NormalFormContext {
	var p = new(NormalFormContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_normalForm
	return p
}

func InitEmptyNormalFormContext(p *NormalFormContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_normalForm
}

func (*NormalFormContext) IsNormalFormContext() {}

func NewNormalFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalFormContext {
	var p = new(NormalFormContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_normalForm

	return p
}

func (s *NormalFormContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalFormContext) NFD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFD, 0)
}

func (s *NormalFormContext) NFC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFC, 0)
}

func (s *NormalFormContext) NFKD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFKD, 0)
}

func (s *NormalFormContext) NFKC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFKC, 0)
}

func (s *NormalFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNormalForm(s)
	}
}

func (s *NormalFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNormalForm(s)
	}
}

func (p *SqlBaseParser) NormalForm() (localctx INormalFormContext) {
	localctx = NewNormalFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SqlBaseParserRULE_normalForm)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1901)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-127)) & ^0x3f) == 0 && ((int64(1)<<(_la-127))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypesContext is an interface to support dynamic dispatch.
type ITypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext

	// IsTypesContext differentiates from other interfaces.
	IsTypesContext()
}

type TypesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypesContext() *TypesContext {
	var p = new(TypesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_types
	return p
}

func InitEmptyTypesContext(p *TypesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_types
}

func (*TypesContext) IsTypesContext() {}

func NewTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypesContext {
	var p = new(TypesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_types

	return p
}

func (s *TypesContext) GetParser() antlr.Parser { return s.parser }

func (s *TypesContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *TypesContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTypes(s)
	}
}

func (s *TypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTypes(s)
	}
}

func (p *SqlBaseParser) Types() (localctx ITypesContext) {
	localctx = NewTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SqlBaseParserRULE_types)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1903)
		p.Match(SqlBaseParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7963480973466883072) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-77497039822350423) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-306253643777315529) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&571957152708678451) != 0) {
		{
			p.SetState(1904)
			p.type_(0)
		}
		p.SetState(1909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1905)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1906)
				p.type_(0)
			}

			p.SetState(1911)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1914)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrom returns the from rule contexts.
	GetFrom() IIntervalFieldContext

	// GetTo returns the to rule contexts.
	GetTo() IIntervalFieldContext

	// SetFrom sets the from rule contexts.
	SetFrom(IIntervalFieldContext)

	// SetTo sets the to rule contexts.
	SetTo(IIntervalFieldContext)

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LT() antlr.TerminalNode
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	GT() antlr.TerminalNode
	MAP() antlr.TerminalNode
	ROW() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	BaseType() IBaseTypeContext
	AllTypeParameter() []ITypeParameterContext
	TypeParameter(i int) ITypeParameterContext
	INTERVAL() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllIntervalField() []IIntervalFieldContext
	IntervalField(i int) IIntervalFieldContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	from   IIntervalFieldContext
	to     IIntervalFieldContext
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) GetFrom() IIntervalFieldContext { return s.from }

func (s *TypeContext) GetTo() IIntervalFieldContext { return s.to }

func (s *TypeContext) SetFrom(v IIntervalFieldContext) { s.from = v }

func (s *TypeContext) SetTo(v IIntervalFieldContext) { s.to = v }

func (s *TypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *TypeContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLT, 0)
}

func (s *TypeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGT, 0)
}

func (s *TypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *TypeContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *TypeContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeContext) BaseType() IBaseTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *TypeContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *TypeContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *TypeContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *TypeContext) AllIntervalField() []IIntervalFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalFieldContext); ok {
			len++
		}
	}

	tst := make([]IIntervalFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalFieldContext); ok {
			tst[i] = t.(IIntervalFieldContext)
			i++
		}
	}

	return tst
}

func (s *TypeContext) IntervalField(i int) IIntervalFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalFieldContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitType(s)
	}
}

func (p *SqlBaseParser) Type_() (localctx ITypeContext) {
	return p.type_(0)
}

func (p *SqlBaseParser) type_(_p int) (localctx ITypeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewTypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 134
	p.EnterRecursionRule(localctx, 134, SqlBaseParserRULE_type, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1917)
			p.Match(SqlBaseParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1918)
			p.Match(SqlBaseParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1919)
			p.type_(0)
		}
		{
			p.SetState(1920)
			p.Match(SqlBaseParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(1922)
			p.Match(SqlBaseParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1923)
			p.Match(SqlBaseParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1924)
			p.type_(0)
		}
		{
			p.SetState(1925)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1926)
			p.type_(0)
		}
		{
			p.SetState(1927)
			p.Match(SqlBaseParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(1929)
			p.Match(SqlBaseParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1930)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1931)
			p.Identifier()
		}
		{
			p.SetState(1932)
			p.type_(0)
		}
		p.SetState(1939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1933)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1934)
				p.Identifier()
			}
			{
				p.SetState(1935)
				p.type_(0)
			}

			p.SetState(1941)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1942)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(1944)
			p.BaseType()
		}
		p.SetState(1956)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1945)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1946)
				p.TypeParameter()
			}
			p.SetState(1951)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__3 {
				{
					p.SetState(1947)
					p.Match(SqlBaseParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1948)
					p.TypeParameter()
				}

				p.SetState(1953)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1954)
				p.Match(SqlBaseParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		{
			p.SetState(1958)
			p.Match(SqlBaseParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1959)

			var _x = p.IntervalField()

			localctx.(*TypeContext).from = _x
		}
		{
			p.SetState(1960)
			p.Match(SqlBaseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1961)

			var _x = p.IntervalField()

			localctx.(*TypeContext).to = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1969)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 247, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTypeContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_type)
			p.SetState(1965)

			if !(p.Precpred(p.GetParserRuleContext(), 6)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				goto errorExit
			}
			{
				p.SetState(1966)
				p.Match(SqlBaseParserARRAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 247, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	Type_() ITypeContext

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *SqlBaseParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SqlBaseParserRULE_typeParameter)
	p.SetState(1974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1972)
			p.Match(SqlBaseParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserDATA, SqlBaseParserDATABASE, SqlBaseParserDATABASES, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserEXTERNAL, SqlBaseParserFETCH, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNEXT, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPATH, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEXT, SqlBaseParserTIES, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserVIEWS, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserINDEX, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER, SqlBaseParserTIME_WITH_TIME_ZONE, SqlBaseParserTIMESTAMP_WITH_TIME_ZONE, SqlBaseParserDOUBLE_PRECISION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1973)
			p.type_(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TIME_WITH_TIME_ZONE() antlr.TerminalNode
	TIMESTAMP_WITH_TIME_ZONE() antlr.TerminalNode
	DOUBLE_PRECISION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_baseType
	return p
}

func InitEmptyBaseTypeContext(p *BaseTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_baseType
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) TIME_WITH_TIME_ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME_WITH_TIME_ZONE, 0)
}

func (s *BaseTypeContext) TIMESTAMP_WITH_TIME_ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP_WITH_TIME_ZONE, 0)
}

func (s *BaseTypeContext) DOUBLE_PRECISION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE_PRECISION, 0)
}

func (s *BaseTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (p *SqlBaseParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SqlBaseParserRULE_baseType)
	p.SetState(1980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserTIME_WITH_TIME_ZONE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1976)
			p.Match(SqlBaseParserTIME_WITH_TIME_ZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserTIMESTAMP_WITH_TIME_ZONE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1977)
			p.Match(SqlBaseParserTIMESTAMP_WITH_TIME_ZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserDOUBLE_PRECISION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1978)
			p.Match(SqlBaseParserDOUBLE_PRECISION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserDATA, SqlBaseParserDATABASE, SqlBaseParserDATABASES, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserEXTERNAL, SqlBaseParserFETCH, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNEXT, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPATH, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEXT, SqlBaseParserTIES, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserVIEWS, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserINDEX, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1979)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *SqlBaseParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SqlBaseParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1982)
		p.Match(SqlBaseParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1983)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(1984)
		p.Match(SqlBaseParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1985)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterContext is an interface to support dynamic dispatch.
type IFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILTER() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsFilterContext differentiates from other interfaces.
	IsFilterContext()
}

type FilterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterContext() *FilterContext {
	var p = new(FilterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_filter
	return p
}

func InitEmptyFilterContext(p *FilterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_filter
}

func (*FilterContext) IsFilterContext() {}

func NewFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterContext {
	var p = new(FilterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_filter

	return p
}

func (s *FilterContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILTER, 0)
}

func (s *FilterContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *FilterContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *FilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterFilter(s)
	}
}

func (s *FilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitFilter(s)
	}
}

func (p *SqlBaseParser) Filter() (localctx IFilterContext) {
	localctx = NewFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SqlBaseParserRULE_filter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1987)
		p.Match(SqlBaseParserFILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1988)
		p.Match(SqlBaseParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1989)
		p.Match(SqlBaseParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1990)
		p.booleanExpression(0)
	}
	{
		p.SetState(1991)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverContext is an interface to support dynamic dispatch.
type IOverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetPartition returns the partition rule context list.
	GetPartition() []IExpressionContext

	// SetPartition sets the partition rule context list.
	SetPartition([]IExpressionContext)

	// Getter signatures
	OVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	ORDER() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	WindowFrame() IWindowFrameContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsOverContext differentiates from other interfaces.
	IsOverContext()
}

type OverContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	partition   []IExpressionContext
}

func NewEmptyOverContext() *OverContext {
	var p = new(OverContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_over
	return p
}

func InitEmptyOverContext(p *OverContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_over
}

func (*OverContext) IsOverContext() {}

func NewOverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverContext {
	var p = new(OverContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_over

	return p
}

func (s *OverContext) GetParser() antlr.Parser { return s.parser }

func (s *OverContext) Get_expression() IExpressionContext { return s._expression }

func (s *OverContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *OverContext) GetPartition() []IExpressionContext { return s.partition }

func (s *OverContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *OverContext) OVER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVER, 0)
}

func (s *OverContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *OverContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserBY)
}

func (s *OverContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, i)
}

func (s *OverContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDER, 0)
}

func (s *OverContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *OverContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *OverContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *OverContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OverContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterOver(s)
	}
}

func (s *OverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitOver(s)
	}
}

func (p *SqlBaseParser) Over() (localctx IOverContext) {
	localctx = NewOverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SqlBaseParserRULE_over)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1993)
		p.Match(SqlBaseParserOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1994)
		p.Match(SqlBaseParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserPARTITION {
		{
			p.SetState(1995)
			p.Match(SqlBaseParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1996)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1997)

			var _x = p.Expression()

			localctx.(*OverContext)._expression = _x
		}
		localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)
		p.SetState(2002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(1998)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1999)

				var _x = p.Expression()

				localctx.(*OverContext)._expression = _x
			}
			localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)

			p.SetState(2004)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserORDER {
		{
			p.SetState(2007)
			p.Match(SqlBaseParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2008)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2009)
			p.SortItem()
		}
		p.SetState(2014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__3 {
			{
				p.SetState(2010)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2011)
				p.SortItem()
			}

			p.SetState(2016)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserRANGE || _la == SqlBaseParserROWS {
		{
			p.SetState(2019)
			p.WindowFrame()
		}

	}
	{
		p.SetState(2022)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrameType returns the frameType token.
	GetFrameType() antlr.Token

	// SetFrameType sets the frameType token.
	SetFrameType(antlr.Token)

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IFrameBoundContext

	// GetEnd returns the end rule contexts.
	GetEnd() IFrameBoundContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IFrameBoundContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IFrameBoundContext)

	// Getter signatures
	RANGE() antlr.TerminalNode
	AllFrameBound() []IFrameBoundContext
	FrameBound(i int) IFrameBoundContext
	ROWS() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	frameType antlr.Token
	start_    IFrameBoundContext
	end       IFrameBoundContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetFrameType() antlr.Token { return s.frameType }

func (s *WindowFrameContext) SetFrameType(v antlr.Token) { s.frameType = v }

func (s *WindowFrameContext) GetStart_() IFrameBoundContext { return s.start_ }

func (s *WindowFrameContext) GetEnd() IFrameBoundContext { return s.end }

func (s *WindowFrameContext) SetStart_(v IFrameBoundContext) { s.start_ = v }

func (s *WindowFrameContext) SetEnd(v IFrameBoundContext) { s.end = v }

func (s *WindowFrameContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRANGE, 0)
}

func (s *WindowFrameContext) AllFrameBound() []IFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameBoundContext); ok {
			tst[i] = t.(IFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBound(i int) IFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *WindowFrameContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROWS, 0)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (p *SqlBaseParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SqlBaseParserRULE_windowFrame)
	p.SetState(2040)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2024)

			var _m = p.Match(SqlBaseParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2025)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2026)

			var _m = p.Match(SqlBaseParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2027)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2028)

			var _m = p.Match(SqlBaseParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2029)
			p.Match(SqlBaseParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2030)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(2031)
			p.Match(SqlBaseParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2032)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2034)

			var _m = p.Match(SqlBaseParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2035)
			p.Match(SqlBaseParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2036)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(2037)
			p.Match(SqlBaseParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2038)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundContext is an interface to support dynamic dispatch.
type IFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFrameBoundContext differentiates from other interfaces.
	IsFrameBoundContext()
}

type FrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBoundContext() *FrameBoundContext {
	var p = new(FrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_frameBound
	return p
}

func InitEmptyFrameBoundContext(p *FrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_frameBound
}

func (*FrameBoundContext) IsFrameBoundContext() {}

func NewFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundContext {
	var p = new(FrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_frameBound

	return p
}

func (s *FrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundContext) CopyAll(ctx *FrameBoundContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BoundedFrameContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewBoundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoundedFrameContext {
	var p = new(BoundedFrameContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *BoundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *BoundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *BoundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoundedFrameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BoundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECEDING, 0)
}

func (s *BoundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOLLOWING, 0)
}

func (s *BoundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBoundedFrame(s)
	}
}

type UnboundedFrameContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewUnboundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnboundedFrameContext {
	var p = new(UnboundedFrameContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *UnboundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *UnboundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *UnboundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnboundedFrameContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNBOUNDED, 0)
}

func (s *UnboundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECEDING, 0)
}

func (s *UnboundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOLLOWING, 0)
}

func (s *UnboundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnboundedFrame(s)
	}
}

type CurrentRowBoundContext struct {
	FrameBoundContext
}

func NewCurrentRowBoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRowBoundContext {
	var p = new(CurrentRowBoundContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *CurrentRowBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRowBoundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT, 0)
}

func (s *CurrentRowBoundContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *CurrentRowBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCurrentRowBound(s)
	}
}

func (p *SqlBaseParser) FrameBound() (localctx IFrameBoundContext) {
	localctx = NewFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SqlBaseParserRULE_frameBound)
	var _la int

	p.SetState(2051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2042)
			p.Match(SqlBaseParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2043)

			var _m = p.Match(SqlBaseParserPRECEDING)

			localctx.(*UnboundedFrameContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2044)
			p.Match(SqlBaseParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2045)

			var _m = p.Match(SqlBaseParserFOLLOWING)

			localctx.(*UnboundedFrameContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCurrentRowBoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2046)
			p.Match(SqlBaseParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2047)
			p.Match(SqlBaseParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewBoundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2048)
			p.Expression()
		}
		{
			p.SetState(2049)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BoundedFrameContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserFOLLOWING || _la == SqlBaseParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BoundedFrameContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainOptionContext is an interface to support dynamic dispatch.
type IExplainOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExplainOptionContext differentiates from other interfaces.
	IsExplainOptionContext()
}

type ExplainOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainOptionContext() *ExplainOptionContext {
	var p = new(ExplainOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_explainOption
	return p
}

func InitEmptyExplainOptionContext(p *ExplainOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_explainOption
}

func (*ExplainOptionContext) IsExplainOptionContext() {}

func NewExplainOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainOptionContext {
	var p = new(ExplainOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_explainOption

	return p
}

func (s *ExplainOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainOptionContext) CopyAll(ctx *ExplainOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExplainOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExplainFormatContext struct {
	ExplainOptionContext
	value antlr.Token
}

func NewExplainFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainFormatContext {
	var p = new(ExplainFormatContext)

	InitEmptyExplainOptionContext(&p.ExplainOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExplainOptionContext))

	return p
}

func (s *ExplainFormatContext) GetValue() antlr.Token { return s.value }

func (s *ExplainFormatContext) SetValue(v antlr.Token) { s.value = v }

func (s *ExplainFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMAT, 0)
}

func (s *ExplainFormatContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEXT, 0)
}

func (s *ExplainFormatContext) GRAPHVIZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRAPHVIZ, 0)
}

func (s *ExplainFormatContext) JSON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJSON, 0)
}

func (s *ExplainFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExplainFormat(s)
	}
}

func (s *ExplainFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExplainFormat(s)
	}
}

type ExplainTypeContext struct {
	ExplainOptionContext
	value antlr.Token
}

func NewExplainTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainTypeContext {
	var p = new(ExplainTypeContext)

	InitEmptyExplainOptionContext(&p.ExplainOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExplainOptionContext))

	return p
}

func (s *ExplainTypeContext) GetValue() antlr.Token { return s.value }

func (s *ExplainTypeContext) SetValue(v antlr.Token) { s.value = v }

func (s *ExplainTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *ExplainTypeContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOGICAL, 0)
}

func (s *ExplainTypeContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTRIBUTED, 0)
}

func (s *ExplainTypeContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALIDATE, 0)
}

func (s *ExplainTypeContext) IO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIO, 0)
}

func (s *ExplainTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExplainType(s)
	}
}

func (s *ExplainTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExplainType(s)
	}
}

func (p *SqlBaseParser) ExplainOption() (localctx IExplainOptionContext) {
	localctx = NewExplainOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SqlBaseParserRULE_explainOption)
	var _la int

	p.SetState(2057)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserFORMAT:
		localctx = NewExplainFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2053)
			p.Match(SqlBaseParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2054)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExplainFormatContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserGRAPHVIZ || _la == SqlBaseParserJSON || _la == SqlBaseParserTEXT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExplainFormatContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SqlBaseParserTYPE:
		localctx = NewExplainTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2055)
			p.Match(SqlBaseParserTYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2056)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExplainTypeContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-63)) & ^0x3f) == 0 && ((int64(1)<<(_la-63))&72061992084439041) != 0) || _la == SqlBaseParserVALIDATE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExplainTypeContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionModeContext is an interface to support dynamic dispatch.
type ITransactionModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTransactionModeContext differentiates from other interfaces.
	IsTransactionModeContext()
}

type TransactionModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionModeContext() *TransactionModeContext {
	var p = new(TransactionModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_transactionMode
	return p
}

func InitEmptyTransactionModeContext(p *TransactionModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_transactionMode
}

func (*TransactionModeContext) IsTransactionModeContext() {}

func NewTransactionModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionModeContext {
	var p = new(TransactionModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_transactionMode

	return p
}

func (s *TransactionModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionModeContext) CopyAll(ctx *TransactionModeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TransactionModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TransactionAccessModeContext struct {
	TransactionModeContext
	accessMode antlr.Token
}

func NewTransactionAccessModeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	InitEmptyTransactionModeContext(&p.TransactionModeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TransactionModeContext))

	return p
}

func (s *TransactionAccessModeContext) GetAccessMode() antlr.Token { return s.accessMode }

func (s *TransactionAccessModeContext) SetAccessMode(v antlr.Token) { s.accessMode = v }

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAD, 0)
}

func (s *TransactionAccessModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserONLY, 0)
}

func (s *TransactionAccessModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWRITE, 0)
}

func (s *TransactionAccessModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTransactionAccessMode(s)
	}
}

type IsolationLevelContext struct {
	TransactionModeContext
}

func NewIsolationLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsolationLevelContext {
	var p = new(IsolationLevelContext)

	InitEmptyTransactionModeContext(&p.TransactionModeContext)
	p.parser = parser
	p.CopyAll(ctx.(*TransactionModeContext))

	return p
}

func (s *IsolationLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsolationLevelContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserISOLATION, 0)
}

func (s *IsolationLevelContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEVEL, 0)
}

func (s *IsolationLevelContext) LevelOfIsolation() ILevelOfIsolationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelOfIsolationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelOfIsolationContext)
}

func (s *IsolationLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIsolationLevel(s)
	}
}

func (p *SqlBaseParser) TransactionMode() (localctx ITransactionModeContext) {
	localctx = NewTransactionModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SqlBaseParserRULE_transactionMode)
	var _la int

	p.SetState(2064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserISOLATION:
		localctx = NewIsolationLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2059)
			p.Match(SqlBaseParserISOLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2060)
			p.Match(SqlBaseParserLEVEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2061)
			p.LevelOfIsolation()
		}

	case SqlBaseParserREAD:
		localctx = NewTransactionAccessModeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2062)
			p.Match(SqlBaseParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2063)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TransactionAccessModeContext).accessMode = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserONLY || _la == SqlBaseParserWRITE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TransactionAccessModeContext).accessMode = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILevelOfIsolationContext is an interface to support dynamic dispatch.
type ILevelOfIsolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLevelOfIsolationContext differentiates from other interfaces.
	IsLevelOfIsolationContext()
}

type LevelOfIsolationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelOfIsolationContext() *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_levelOfIsolation
	return p
}

func InitEmptyLevelOfIsolationContext(p *LevelOfIsolationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_levelOfIsolation
}

func (*LevelOfIsolationContext) IsLevelOfIsolationContext() {}

func NewLevelOfIsolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_levelOfIsolation

	return p
}

func (s *LevelOfIsolationContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelOfIsolationContext) CopyAll(ctx *LevelOfIsolationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LevelOfIsolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelOfIsolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ReadUncommittedContext struct {
	LevelOfIsolationContext
}

func NewReadUncommittedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReadUncommittedContext {
	var p = new(ReadUncommittedContext)

	InitEmptyLevelOfIsolationContext(&p.LevelOfIsolationContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *ReadUncommittedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadUncommittedContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAD, 0)
}

func (s *ReadUncommittedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNCOMMITTED, 0)
}

func (s *ReadUncommittedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterReadUncommitted(s)
	}
}

func (s *ReadUncommittedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitReadUncommitted(s)
	}
}

type SerializableContext struct {
	LevelOfIsolationContext
}

func NewSerializableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SerializableContext {
	var p = new(SerializableContext)

	InitEmptyLevelOfIsolationContext(&p.LevelOfIsolationContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *SerializableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerializableContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERIALIZABLE, 0)
}

func (s *SerializableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSerializable(s)
	}
}

func (s *SerializableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSerializable(s)
	}
}

type ReadCommittedContext struct {
	LevelOfIsolationContext
}

func NewReadCommittedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReadCommittedContext {
	var p = new(ReadCommittedContext)

	InitEmptyLevelOfIsolationContext(&p.LevelOfIsolationContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *ReadCommittedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadCommittedContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAD, 0)
}

func (s *ReadCommittedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMITTED, 0)
}

func (s *ReadCommittedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterReadCommitted(s)
	}
}

func (s *ReadCommittedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitReadCommitted(s)
	}
}

type RepeatableReadContext struct {
	LevelOfIsolationContext
}

func NewRepeatableReadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RepeatableReadContext {
	var p = new(RepeatableReadContext)

	InitEmptyLevelOfIsolationContext(&p.LevelOfIsolationContext)
	p.parser = parser
	p.CopyAll(ctx.(*LevelOfIsolationContext))

	return p
}

func (s *RepeatableReadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatableReadContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPEATABLE, 0)
}

func (s *RepeatableReadContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAD, 0)
}

func (s *RepeatableReadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRepeatableRead(s)
	}
}

func (s *RepeatableReadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRepeatableRead(s)
	}
}

func (p *SqlBaseParser) LevelOfIsolation() (localctx ILevelOfIsolationContext) {
	localctx = NewLevelOfIsolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SqlBaseParserRULE_levelOfIsolation)
	p.SetState(2073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 259, p.GetParserRuleContext()) {
	case 1:
		localctx = NewReadUncommittedContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2066)
			p.Match(SqlBaseParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2067)
			p.Match(SqlBaseParserUNCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewReadCommittedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2068)
			p.Match(SqlBaseParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2069)
			p.Match(SqlBaseParserCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewRepeatableReadContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2070)
			p.Match(SqlBaseParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2071)
			p.Match(SqlBaseParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewSerializableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2072)
			p.Match(SqlBaseParserSERIALIZABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallArgumentContext is an interface to support dynamic dispatch.
type ICallArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCallArgumentContext differentiates from other interfaces.
	IsCallArgumentContext()
}

type CallArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallArgumentContext() *CallArgumentContext {
	var p = new(CallArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_callArgument
	return p
}

func InitEmptyCallArgumentContext(p *CallArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_callArgument
}

func (*CallArgumentContext) IsCallArgumentContext() {}

func NewCallArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallArgumentContext {
	var p = new(CallArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_callArgument

	return p
}

func (s *CallArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *CallArgumentContext) CopyAll(ctx *CallArgumentContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CallArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PositionalArgumentContext struct {
	CallArgumentContext
}

func NewPositionalArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionalArgumentContext {
	var p = new(PositionalArgumentContext)

	InitEmptyCallArgumentContext(&p.CallArgumentContext)
	p.parser = parser
	p.CopyAll(ctx.(*CallArgumentContext))

	return p
}

func (s *PositionalArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionalArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PositionalArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPositionalArgument(s)
	}
}

func (s *PositionalArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPositionalArgument(s)
	}
}

type NamedArgumentContext struct {
	CallArgumentContext
}

func NewNamedArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NamedArgumentContext {
	var p = new(NamedArgumentContext)

	InitEmptyCallArgumentContext(&p.CallArgumentContext)
	p.parser = parser
	p.CopyAll(ctx.(*CallArgumentContext))

	return p
}

func (s *NamedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNamedArgument(s)
	}
}

func (s *NamedArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNamedArgument(s)
	}
}

func (p *SqlBaseParser) CallArgument() (localctx ICallArgumentContext) {
	localctx = NewCallArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SqlBaseParserRULE_callArgument)
	p.SetState(2080)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPositionalArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2075)
			p.Expression()
		}

	case 2:
		localctx = NewNamedArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2076)
			p.Identifier()
		}
		{
			p.SetState(2077)
			p.Match(SqlBaseParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2078)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathElementContext is an interface to support dynamic dispatch.
type IPathElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPathElementContext differentiates from other interfaces.
	IsPathElementContext()
}

type PathElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathElementContext() *PathElementContext {
	var p = new(PathElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_pathElement
	return p
}

func InitEmptyPathElementContext(p *PathElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_pathElement
}

func (*PathElementContext) IsPathElementContext() {}

func NewPathElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathElementContext {
	var p = new(PathElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_pathElement

	return p
}

func (s *PathElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PathElementContext) CopyAll(ctx *PathElementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PathElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QualifiedArgumentContext struct {
	PathElementContext
}

func NewQualifiedArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedArgumentContext {
	var p = new(QualifiedArgumentContext)

	InitEmptyPathElementContext(&p.PathElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathElementContext))

	return p
}

func (s *QualifiedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedArgumentContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedArgumentContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQualifiedArgument(s)
	}
}

func (s *QualifiedArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQualifiedArgument(s)
	}
}

type UnqualifiedArgumentContext struct {
	PathElementContext
}

func NewUnqualifiedArgumentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnqualifiedArgumentContext {
	var p = new(UnqualifiedArgumentContext)

	InitEmptyPathElementContext(&p.PathElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathElementContext))

	return p
}

func (s *UnqualifiedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnqualifiedArgumentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnqualifiedArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnqualifiedArgument(s)
	}
}

func (s *UnqualifiedArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnqualifiedArgument(s)
	}
}

func (p *SqlBaseParser) PathElement() (localctx IPathElementContext) {
	localctx = NewPathElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SqlBaseParserRULE_pathElement)
	p.SetState(2087)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 261, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQualifiedArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2082)
			p.Identifier()
		}
		{
			p.SetState(2083)
			p.Match(SqlBaseParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2084)
			p.Identifier()
		}

	case 2:
		localctx = NewUnqualifiedArgumentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2086)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathSpecificationContext is an interface to support dynamic dispatch.
type IPathSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPathElement() []IPathElementContext
	PathElement(i int) IPathElementContext

	// IsPathSpecificationContext differentiates from other interfaces.
	IsPathSpecificationContext()
}

type PathSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathSpecificationContext() *PathSpecificationContext {
	var p = new(PathSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_pathSpecification
	return p
}

func InitEmptyPathSpecificationContext(p *PathSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_pathSpecification
}

func (*PathSpecificationContext) IsPathSpecificationContext() {}

func NewPathSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathSpecificationContext {
	var p = new(PathSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_pathSpecification

	return p
}

func (s *PathSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *PathSpecificationContext) AllPathElement() []IPathElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathElementContext); ok {
			len++
		}
	}

	tst := make([]IPathElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathElementContext); ok {
			tst[i] = t.(IPathElementContext)
			i++
		}
	}

	return tst
}

func (s *PathSpecificationContext) PathElement(i int) IPathElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathElementContext)
}

func (s *PathSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPathSpecification(s)
	}
}

func (s *PathSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPathSpecification(s)
	}
}

func (p *SqlBaseParser) PathSpecification() (localctx IPathSpecificationContext) {
	localctx = NewPathSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SqlBaseParserRULE_pathSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2089)
		p.PathElement()
	}
	p.SetState(2094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__3 {
		{
			p.SetState(2090)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2091)
			p.PathElement()
		}

		p.SetState(2096)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_privilege
	return p
}

func InitEmptyPrivilegeContext(p *PrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_privilege
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSELECT, 0)
}

func (s *PrivilegeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELETE, 0)
}

func (s *PrivilegeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUPDATE, 0)
}

func (s *PrivilegeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *PrivilegeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (p *SqlBaseParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SqlBaseParserRULE_privilege)
	p.SetState(2102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserSELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2097)
			p.Match(SqlBaseParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserDELETE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2098)
			p.Match(SqlBaseParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserUPDATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2099)
			p.Match(SqlBaseParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserINSERT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2100)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserDATA, SqlBaseParserDATABASE, SqlBaseParserDATABASES, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserEXTERNAL, SqlBaseParserFETCH, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNEXT, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPATH, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEXT, SqlBaseParserTIES, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserVIEWS, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserINDEX, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2101)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (p *SqlBaseParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SqlBaseParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2104)
		p.Identifier()
	}
	p.SetState(2109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2105)
				p.Match(SqlBaseParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2106)
				p.Identifier()
			}

		}
		p.SetState(2111)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantorContext is an interface to support dynamic dispatch.
type IGrantorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGrantorContext differentiates from other interfaces.
	IsGrantorContext()
}

type GrantorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantorContext() *GrantorContext {
	var p = new(GrantorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_grantor
	return p
}

func InitEmptyGrantorContext(p *GrantorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_grantor
}

func (*GrantorContext) IsGrantorContext() {}

func NewGrantorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantorContext {
	var p = new(GrantorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_grantor

	return p
}

func (s *GrantorContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantorContext) CopyAll(ctx *GrantorContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GrantorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CurrentUserGrantorContext struct {
	GrantorContext
}

func NewCurrentUserGrantorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserGrantorContext {
	var p = new(CurrentUserGrantorContext)

	InitEmptyGrantorContext(&p.GrantorContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantorContext))

	return p
}

func (s *CurrentUserGrantorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserGrantorContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_USER, 0)
}

func (s *CurrentUserGrantorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCurrentUserGrantor(s)
	}
}

func (s *CurrentUserGrantorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCurrentUserGrantor(s)
	}
}

type SpecifiedPrincipalContext struct {
	GrantorContext
}

func NewSpecifiedPrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecifiedPrincipalContext {
	var p = new(SpecifiedPrincipalContext)

	InitEmptyGrantorContext(&p.GrantorContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantorContext))

	return p
}

func (s *SpecifiedPrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecifiedPrincipalContext) Principal() IPrincipalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrincipalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrincipalContext)
}

func (s *SpecifiedPrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSpecifiedPrincipal(s)
	}
}

func (s *SpecifiedPrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSpecifiedPrincipal(s)
	}
}

type CurrentRoleGrantorContext struct {
	GrantorContext
}

func NewCurrentRoleGrantorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRoleGrantorContext {
	var p = new(CurrentRoleGrantorContext)

	InitEmptyGrantorContext(&p.GrantorContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantorContext))

	return p
}

func (s *CurrentRoleGrantorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRoleGrantorContext) CURRENT_ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT_ROLE, 0)
}

func (s *CurrentRoleGrantorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCurrentRoleGrantor(s)
	}
}

func (s *CurrentRoleGrantorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCurrentRoleGrantor(s)
	}
}

func (p *SqlBaseParser) Grantor() (localctx IGrantorContext) {
	localctx = NewGrantorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SqlBaseParserRULE_grantor)
	p.SetState(2115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserDATA, SqlBaseParserDATABASE, SqlBaseParserDATABASES, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserEXTERNAL, SqlBaseParserFETCH, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNEXT, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPATH, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEXT, SqlBaseParserTIES, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserVIEWS, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserINDEX, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER:
		localctx = NewSpecifiedPrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2112)
			p.Principal()
		}

	case SqlBaseParserCURRENT_USER:
		localctx = NewCurrentUserGrantorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2113)
			p.Match(SqlBaseParserCURRENT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserCURRENT_ROLE:
		localctx = NewCurrentRoleGrantorContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2114)
			p.Match(SqlBaseParserCURRENT_ROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrincipalContext is an interface to support dynamic dispatch.
type IPrincipalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrincipalContext differentiates from other interfaces.
	IsPrincipalContext()
}

type PrincipalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrincipalContext() *PrincipalContext {
	var p = new(PrincipalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_principal
	return p
}

func InitEmptyPrincipalContext(p *PrincipalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_principal
}

func (*PrincipalContext) IsPrincipalContext() {}

func NewPrincipalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrincipalContext {
	var p = new(PrincipalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_principal

	return p
}

func (s *PrincipalContext) GetParser() antlr.Parser { return s.parser }

func (s *PrincipalContext) CopyAll(ctx *PrincipalContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrincipalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnspecifiedPrincipalContext struct {
	PrincipalContext
}

func NewUnspecifiedPrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnspecifiedPrincipalContext {
	var p = new(UnspecifiedPrincipalContext)

	InitEmptyPrincipalContext(&p.PrincipalContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrincipalContext))

	return p
}

func (s *UnspecifiedPrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnspecifiedPrincipalContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnspecifiedPrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnspecifiedPrincipal(s)
	}
}

func (s *UnspecifiedPrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnspecifiedPrincipal(s)
	}
}

type UserPrincipalContext struct {
	PrincipalContext
}

func NewUserPrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserPrincipalContext {
	var p = new(UserPrincipalContext)

	InitEmptyPrincipalContext(&p.PrincipalContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrincipalContext))

	return p
}

func (s *UserPrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPrincipalContext) USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSER, 0)
}

func (s *UserPrincipalContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UserPrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUserPrincipal(s)
	}
}

func (s *UserPrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUserPrincipal(s)
	}
}

type RolePrincipalContext struct {
	PrincipalContext
}

func NewRolePrincipalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RolePrincipalContext {
	var p = new(RolePrincipalContext)

	InitEmptyPrincipalContext(&p.PrincipalContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrincipalContext))

	return p
}

func (s *RolePrincipalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RolePrincipalContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *RolePrincipalContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RolePrincipalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRolePrincipal(s)
	}
}

func (s *RolePrincipalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRolePrincipal(s)
	}
}

func (p *SqlBaseParser) Principal() (localctx IPrincipalContext) {
	localctx = NewPrincipalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SqlBaseParserRULE_principal)
	p.SetState(2122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnspecifiedPrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2117)
			p.Identifier()
		}

	case 2:
		localctx = NewUserPrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2118)
			p.Match(SqlBaseParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2119)
			p.Identifier()
		}

	case 3:
		localctx = NewRolePrincipalContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2120)
			p.Match(SqlBaseParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2121)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRolesContext is an interface to support dynamic dispatch.
type IRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsRolesContext differentiates from other interfaces.
	IsRolesContext()
}

type RolesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRolesContext() *RolesContext {
	var p = new(RolesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_roles
	return p
}

func InitEmptyRolesContext(p *RolesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_roles
}

func (*RolesContext) IsRolesContext() {}

func NewRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RolesContext {
	var p = new(RolesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_roles

	return p
}

func (s *RolesContext) GetParser() antlr.Parser { return s.parser }

func (s *RolesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RolesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRoles(s)
	}
}

func (s *RolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRoles(s)
	}
}

func (p *SqlBaseParser) Roles() (localctx IRolesContext) {
	localctx = NewRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SqlBaseParserRULE_roles)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2124)
		p.Identifier()
	}
	p.SetState(2129)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__3 {
		{
			p.SetState(2125)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2126)
			p.Identifier()
		}

		p.SetState(2131)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyAll(ctx *IdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BackQuotedIdentifierContext struct {
	IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

type QuotedIdentifierContext struct {
	IdentifierContext
}

func NewQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuotedIdentifier(s)
	}
}

func (s *QuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuotedIdentifier(s)
	}
}

type DigitIdentifierContext struct {
	IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

type UnquotedIdentifierContext struct {
	IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (p *SqlBaseParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SqlBaseParserRULE_identifier)
	p.SetState(2137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2132)
			p.Match(SqlBaseParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2133)
			p.Match(SqlBaseParserQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserADD, SqlBaseParserADMIN, SqlBaseParserALL, SqlBaseParserANALYZE, SqlBaseParserANY, SqlBaseParserARRAY, SqlBaseParserASC, SqlBaseParserAT, SqlBaseParserBERNOULLI, SqlBaseParserCALL, SqlBaseParserCALLED, SqlBaseParserCASCADE, SqlBaseParserCATALOGS, SqlBaseParserCOLUMN, SqlBaseParserCOLUMNS, SqlBaseParserCOMMENT, SqlBaseParserCOMMIT, SqlBaseParserCOMMITTED, SqlBaseParserCURRENT, SqlBaseParserDATA, SqlBaseParserDATABASE, SqlBaseParserDATABASES, SqlBaseParserDATE, SqlBaseParserDAY, SqlBaseParserDEFINER, SqlBaseParserDESC, SqlBaseParserDISTRIBUTED, SqlBaseParserEXCLUDING, SqlBaseParserEXPLAIN, SqlBaseParserEXTERNAL, SqlBaseParserFETCH, SqlBaseParserFILTER, SqlBaseParserFIRST, SqlBaseParserFOLLOWING, SqlBaseParserFORMAT, SqlBaseParserFUNCTION, SqlBaseParserFUNCTIONS, SqlBaseParserGRANT, SqlBaseParserGRANTED, SqlBaseParserGRANTS, SqlBaseParserGRAPHVIZ, SqlBaseParserHOUR, SqlBaseParserIF, SqlBaseParserINCLUDING, SqlBaseParserINPUT, SqlBaseParserINTERVAL, SqlBaseParserINVOKER, SqlBaseParserIO, SqlBaseParserISOLATION, SqlBaseParserJSON, SqlBaseParserLAST, SqlBaseParserLATERAL, SqlBaseParserLEVEL, SqlBaseParserLIMIT, SqlBaseParserLOGICAL, SqlBaseParserMAP, SqlBaseParserMINUTE, SqlBaseParserMONTH, SqlBaseParserNAME, SqlBaseParserNEXT, SqlBaseParserNFC, SqlBaseParserNFD, SqlBaseParserNFKC, SqlBaseParserNFKD, SqlBaseParserNO, SqlBaseParserNONE, SqlBaseParserNULLIF, SqlBaseParserNULLS, SqlBaseParserOFFSET, SqlBaseParserONLY, SqlBaseParserOPTION, SqlBaseParserORDINALITY, SqlBaseParserOUTPUT, SqlBaseParserOVER, SqlBaseParserPARTITION, SqlBaseParserPARTITIONS, SqlBaseParserPATH, SqlBaseParserPOSITION, SqlBaseParserPRECEDING, SqlBaseParserPRIVILEGES, SqlBaseParserPROPERTIES, SqlBaseParserRANGE, SqlBaseParserREAD, SqlBaseParserRENAME, SqlBaseParserREPEATABLE, SqlBaseParserREPLACE, SqlBaseParserRESET, SqlBaseParserRESTRICT, SqlBaseParserRETURN, SqlBaseParserRETURNS, SqlBaseParserREVOKE, SqlBaseParserROLE, SqlBaseParserROLES, SqlBaseParserROLLBACK, SqlBaseParserROW, SqlBaseParserROWS, SqlBaseParserSCHEMA, SqlBaseParserSCHEMAS, SqlBaseParserSECOND, SqlBaseParserSECURITY, SqlBaseParserSERIALIZABLE, SqlBaseParserSESSION, SqlBaseParserSET, SqlBaseParserSETS, SqlBaseParserSHOW, SqlBaseParserSOME, SqlBaseParserSTART, SqlBaseParserSTATS, SqlBaseParserSUBSTRING, SqlBaseParserSYSTEM, SqlBaseParserTABLES, SqlBaseParserTABLESAMPLE, SqlBaseParserTEXT, SqlBaseParserTIES, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserTO, SqlBaseParserTRANSACTION, SqlBaseParserTRY_CAST, SqlBaseParserTYPE, SqlBaseParserUNBOUNDED, SqlBaseParserUNCOMMITTED, SqlBaseParserUSE, SqlBaseParserUSER, SqlBaseParserVALIDATE, SqlBaseParserVERBOSE, SqlBaseParserVIEW, SqlBaseParserVIEWS, SqlBaseParserWORK, SqlBaseParserWRITE, SqlBaseParserYEAR, SqlBaseParserZONE, SqlBaseParserINDEX:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2134)
			p.NonReserved()
		}

	case SqlBaseParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2135)
			p.Match(SqlBaseParserBACKQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2136)
			p.Match(SqlBaseParserDIGIT_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

type DoubleLiteralContext struct {
	NumberContext
}

func NewDoubleLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoubleLiteralContext {
	var p = new(DoubleLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DoubleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleLiteralContext) DOUBLE_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDOUBLE_VALUE, 0)
}

func (s *DoubleLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *DoubleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDoubleLiteral(s)
	}
}

func (s *DoubleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDoubleLiteral(s)
	}
}

type IntegerLiteralContext struct {
	NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *SqlBaseParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SqlBaseParserRULE_number)
	var _la int

	p.SetState(2151)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 272, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(2139)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2142)
			p.Match(SqlBaseParserDECIMAL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewDoubleLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(2143)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2146)
			p.Match(SqlBaseParserDOUBLE_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2148)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(2147)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2150)
			p.Match(SqlBaseParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	ANY() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	ASC() antlr.TerminalNode
	AT() antlr.TerminalNode
	BERNOULLI() antlr.TerminalNode
	CALL() antlr.TerminalNode
	CALLED() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	EXCLUDING() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	FETCH() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	GRANTED() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	GRAPHVIZ() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	IF() antlr.TerminalNode
	INCLUDING() antlr.TerminalNode
	INPUT() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	IO() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	JSON() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LATERAL() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NFC() antlr.TerminalNode
	NFD() antlr.TerminalNode
	NFKC() antlr.TerminalNode
	NFKD() antlr.TerminalNode
	NO() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NULLIF() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	ORDINALITY() antlr.TerminalNode
	OUTPUT() antlr.TerminalNode
	OVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PATH() antlr.TerminalNode
	POSITION() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	READ() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	RETURN() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	REVOKE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLES() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROW() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SCHEMAS() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SET() antlr.TerminalNode
	SETS() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	SOME() antlr.TerminalNode
	START() antlr.TerminalNode
	STATS() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TABLESAMPLE() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	TIES() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TO() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRY_CAST() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	USE() antlr.TerminalNode
	USER() antlr.TerminalNode
	VALIDATE() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	WORK() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	ZONE() antlr.TerminalNode
	INDEX() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *NonReservedContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADMIN, 0)
}

func (s *NonReservedContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *NonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANALYZE, 0)
}

func (s *NonReservedContext) ANY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANY, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *NonReservedContext) ASC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASC, 0)
}

func (s *NonReservedContext) AT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAT, 0)
}

func (s *NonReservedContext) BERNOULLI() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBERNOULLI, 0)
}

func (s *NonReservedContext) CALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALL, 0)
}

func (s *NonReservedContext) CALLED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCALLED, 0)
}

func (s *NonReservedContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASCADE, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCATALOGS, 0)
}

func (s *NonReservedContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOMMITTED, 0)
}

func (s *NonReservedContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCURRENT, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATA, 0)
}

func (s *NonReservedContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASE, 0)
}

func (s *NonReservedContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATABASES, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *NonReservedContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINER, 0)
}

func (s *NonReservedContext) DESC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESC, 0)
}

func (s *NonReservedContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTRIBUTED, 0)
}

func (s *NonReservedContext) EXCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXCLUDING, 0)
}

func (s *NonReservedContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPLAIN, 0)
}

func (s *NonReservedContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTERNAL, 0)
}

func (s *NonReservedContext) FETCH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFETCH, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFIRST, 0)
}

func (s *NonReservedContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFOLLOWING, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFORMAT, 0)
}

func (s *NonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTIONS, 0)
}

func (s *NonReservedContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANT, 0)
}

func (s *NonReservedContext) GRANTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTED, 0)
}

func (s *NonReservedContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRANTS, 0)
}

func (s *NonReservedContext) GRAPHVIZ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRAPHVIZ, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *NonReservedContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *NonReservedContext) INCLUDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINCLUDING, 0)
}

func (s *NonReservedContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINPUT, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *NonReservedContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINVOKER, 0)
}

func (s *NonReservedContext) IO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIO, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserISOLATION, 0)
}

func (s *NonReservedContext) JSON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJSON, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAST, 0)
}

func (s *NonReservedContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLATERAL, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEVEL, 0)
}

func (s *NonReservedContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIMIT, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLOGICAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, 0)
}

func (s *NonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNAME, 0)
}

func (s *NonReservedContext) NEXT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNEXT, 0)
}

func (s *NonReservedContext) NFC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFC, 0)
}

func (s *NonReservedContext) NFD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFD, 0)
}

func (s *NonReservedContext) NFKC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFKC, 0)
}

func (s *NonReservedContext) NFKD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNFKD, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNO, 0)
}

func (s *NonReservedContext) NONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNONE, 0)
}

func (s *NonReservedContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLIF, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULLS, 0)
}

func (s *NonReservedContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOFFSET, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserONLY, 0)
}

func (s *NonReservedContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOPTION, 0)
}

func (s *NonReservedContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserORDINALITY, 0)
}

func (s *NonReservedContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTPUT, 0)
}

func (s *NonReservedContext) OVER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOVER, 0)
}

func (s *NonReservedContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONS, 0)
}

func (s *NonReservedContext) PATH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPATH, 0)
}

func (s *NonReservedContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPOSITION, 0)
}

func (s *NonReservedContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRECEDING, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, 0)
}

func (s *NonReservedContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRANGE, 0)
}

func (s *NonReservedContext) READ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREAD, 0)
}

func (s *NonReservedContext) RENAME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRENAME, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *NonReservedContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESET, 0)
}

func (s *NonReservedContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESTRICT, 0)
}

func (s *NonReservedContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURN, 0)
}

func (s *NonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETURNS, 0)
}

func (s *NonReservedContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREVOKE, 0)
}

func (s *NonReservedContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLE, 0)
}

func (s *NonReservedContext) ROLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLES, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROLLBACK, 0)
}

func (s *NonReservedContext) ROW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROW, 0)
}

func (s *NonReservedContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserROWS, 0)
}

func (s *NonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *NonReservedContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMAS, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *NonReservedContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECURITY, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *NonReservedContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *NonReservedContext) SETS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSETS, 0)
}

func (s *NonReservedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *NonReservedContext) SOME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOME, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTART, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTATS, 0)
}

func (s *NonReservedContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBSTRING, 0)
}

func (s *NonReservedContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLES, 0)
}

func (s *NonReservedContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLESAMPLE, 0)
}

func (s *NonReservedContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTEXT, 0)
}

func (s *NonReservedContext) TIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIES, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTO, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRANSACTION, 0)
}

func (s *NonReservedContext) TRY_CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRY_CAST, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *NonReservedContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNBOUNDED, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) USE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSE, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUSER, 0)
}

func (s *NonReservedContext) VALIDATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALIDATE, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVERBOSE, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEW, 0)
}

func (s *NonReservedContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVIEWS, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWORK, 0)
}

func (s *NonReservedContext) WRITE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWRITE, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *NonReservedContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *NonReservedContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINDEX, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (p *SqlBaseParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SqlBaseParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2153)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7963480973466883072) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-77497039822350423) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-306253643777315529) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&32625459) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *SqlBaseParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 30:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 42:
		var t *RelationContext = nil
		if localctx != nil {
			t = localctx.(*RelationContext)
		}
		return p.Relation_Sempred(t, predIndex)

	case 51:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 53:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 54:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	case 67:
		var t *TypeContext = nil
		if localctx != nil {
			t = localctx.(*TypeContext)
		}
		return p.Type__Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SqlBaseParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) Relation_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 13)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) Type__Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 6)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
