// Copyright The kweaver.ai Authors.
//
// Licensed under the Apache License, Version 2.0.
// See the LICENSE file in the project root for details.

// Code generated by MockGen. DO NOT EDIT.
// Source: ../interfaces/kafka_access.go

// Package mock_interfaces is a generated GoMock package.
package mock_interfaces

import (
	context "context"
	interfaces "data-model-job/interfaces"
	reflect "reflect"

	kafka "github.com/confluentinc/confluent-kafka-go/v2/kafka"
	gomock "github.com/golang/mock/gomock"
)

// MockKafkaAccess is a mock of KafkaAccess interface.
type MockKafkaAccess struct {
	ctrl     *gomock.Controller
	recorder *MockKafkaAccessMockRecorder
}

// MockKafkaAccessMockRecorder is the mock recorder for MockKafkaAccess.
type MockKafkaAccessMockRecorder struct {
	mock *MockKafkaAccess
}

// NewMockKafkaAccess creates a new mock instance.
func NewMockKafkaAccess(ctrl *gomock.Controller) *MockKafkaAccess {
	mock := &MockKafkaAccess{ctrl: ctrl}
	mock.recorder = &MockKafkaAccessMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockKafkaAccess) EXPECT() *MockKafkaAccessMockRecorder {
	return m.recorder
}

// CreateTopicOrPartition mocks base method.
func (m *MockKafkaAccess) CreateTopicOrPartition(ctx context.Context, topic interfaces.TopicMetadata) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTopicOrPartition", ctx, topic)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateTopicOrPartition indicates an expected call of CreateTopicOrPartition.
func (mr *MockKafkaAccessMockRecorder) CreateTopicOrPartition(ctx, topic interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTopicOrPartition", reflect.TypeOf((*MockKafkaAccess)(nil).CreateTopicOrPartition), ctx, topic)
}

// DeleteConsumerGroups mocks base method.
func (m *MockKafkaAccess) DeleteConsumerGroups(groupIds []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteConsumerGroups", groupIds)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteConsumerGroups indicates an expected call of DeleteConsumerGroups.
func (mr *MockKafkaAccessMockRecorder) DeleteConsumerGroups(groupIds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteConsumerGroups", reflect.TypeOf((*MockKafkaAccess)(nil).DeleteConsumerGroups), groupIds)
}

// DeleteTopic mocks base method.
func (m *MockKafkaAccess) DeleteTopic(ctx context.Context, topicNames []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteTopic", ctx, topicNames)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteTopic indicates an expected call of DeleteTopic.
func (mr *MockKafkaAccessMockRecorder) DeleteTopic(ctx, topicNames interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTopic", reflect.TypeOf((*MockKafkaAccess)(nil).DeleteTopic), ctx, topicNames)
}

// DescribeTopics mocks base method.
func (m *MockKafkaAccess) DescribeTopics(ctx context.Context, topics []string) ([]interfaces.TopicMetadata, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DescribeTopics", ctx, topics)
	ret0, _ := ret[0].([]interfaces.TopicMetadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DescribeTopics indicates an expected call of DescribeTopics.
func (mr *MockKafkaAccessMockRecorder) DescribeTopics(ctx, topics interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeTopics", reflect.TypeOf((*MockKafkaAccess)(nil).DescribeTopics), ctx, topics)
}

// DoConsume mocks base method.
func (m *MockKafkaAccess) DoConsume(c *kafka.Consumer) (*kafka.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoConsume", c)
	ret0, _ := ret[0].(*kafka.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DoConsume indicates an expected call of DoConsume.
func (mr *MockKafkaAccessMockRecorder) DoConsume(c interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoConsume", reflect.TypeOf((*MockKafkaAccess)(nil).DoConsume), c)
}

// DoProduce mocks base method.
func (m *MockKafkaAccess) DoProduce(kp *interfaces.KafkaProducer, c *kafka.Consumer, msgs []*kafka.Message) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoProduce", kp, c, msgs)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoProduce indicates an expected call of DoProduce.
func (mr *MockKafkaAccessMockRecorder) DoProduce(kp, c, msgs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoProduce", reflect.TypeOf((*MockKafkaAccess)(nil).DoProduce), kp, c, msgs)
}

// DoProduceMsgToKafka mocks base method.
func (m *MockKafkaAccess) DoProduceMsgToKafka(p *kafka.Producer, messages []*kafka.Message) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoProduceMsgToKafka", p, messages)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoProduceMsgToKafka indicates an expected call of DoProduceMsgToKafka.
func (mr *MockKafkaAccessMockRecorder) DoProduceMsgToKafka(p, messages interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoProduceMsgToKafka", reflect.TypeOf((*MockKafkaAccess)(nil).DoProduceMsgToKafka), p, messages)
}

// NewConsumer mocks base method.
func (m *MockKafkaAccess) NewConsumer(groupID string) (*kafka.Consumer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewConsumer", groupID)
	ret0, _ := ret[0].(*kafka.Consumer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewConsumer indicates an expected call of NewConsumer.
func (mr *MockKafkaAccessMockRecorder) NewConsumer(groupID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewConsumer", reflect.TypeOf((*MockKafkaAccess)(nil).NewConsumer), groupID)
}

// NewTransactionalProducer mocks base method.
func (m *MockKafkaAccess) NewTransactionalProducer(txId string) (*kafka.Producer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewTransactionalProducer", txId)
	ret0, _ := ret[0].(*kafka.Producer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewTransactionalProducer indicates an expected call of NewTransactionalProducer.
func (mr *MockKafkaAccessMockRecorder) NewTransactionalProducer(txId interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewTransactionalProducer", reflect.TypeOf((*MockKafkaAccess)(nil).NewTransactionalProducer), txId)
}

// NewTrxProducer mocks base method.
func (m *MockKafkaAccess) NewTrxProducer(uniqId string) (*kafka.Producer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewTrxProducer", uniqId)
	ret0, _ := ret[0].(*kafka.Producer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewTrxProducer indicates an expected call of NewTrxProducer.
func (mr *MockKafkaAccessMockRecorder) NewTrxProducer(uniqId interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewTrxProducer", reflect.TypeOf((*MockKafkaAccess)(nil).NewTrxProducer), uniqId)
}
