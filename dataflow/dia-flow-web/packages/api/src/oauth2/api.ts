// tslint:disable
/**
 * OAuth2.0
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthorizationCode
 */
export interface AuthorizationCode {
    /**
     * 许可类型： - `authorization_code` 授权码许可 - `client_credentials` 客户端凭据许可 - `refresh_token` 刷新令牌 
     * @type {string}
     * @memberof AuthorizationCode
     */
    grant_type: AuthorizationCodeGrantTypeEnum;
    /**
     * 使用授权码许可（authorization_code）时，会在redirect_uri处获得code。code用于换取令牌。
     * @type {string}
     * @memberof AuthorizationCode
     */
    code: string;
    /**
     * redirect_uri与注册时redirect_uri相同，如果在授权请求中指定了redirect_uri，那么令牌请求中也必须包含该redirect_uri。
     * @type {string}
     * @memberof AuthorizationCode
     */
    redirect_uri: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AuthorizationCodeGrantTypeEnum {
    AuthorizationCode = 'authorization_code',
    ClientCredentials = 'client_credentials',
    RefreshToken = 'refresh_token'
}

/**
 * 
 * @export
 * @interface AuthorizationCodeParameter
 */
export interface AuthorizationCodeParameter {
    /**
     * 使用授权码许可（authorization_code）时，会在redirect_uri处获得code。code用于换取令牌。
     * @type {string}
     * @memberof AuthorizationCodeParameter
     */
    code: string;
    /**
     * redirect_uri与注册时redirect_uri相同，如果在授权请求中指定了redirect_uri，那么令牌请求中也必须包含该redirect_uri。
     * @type {string}
     * @memberof AuthorizationCodeParameter
     */
    redirect_uri: string;
}
/**
 * 
 * @export
 * @interface ClientCredentials
 */
export interface ClientCredentials {
    /**
     * 许可类型： - `authorization_code` 授权码许可 - `client_credentials` 客户端凭据许可 - `refresh_token` 刷新令牌 
     * @type {string}
     * @memberof ClientCredentials
     */
    grant_type: ClientCredentialsGrantTypeEnum;
    /**
     * scope是一个空格分隔的字符串，客户端可以在使用客户端凭据许可（client_credentials）请求访问令牌时使用它们。权限范围字段参考Authentication章节。
     * @type {string}
     * @memberof ClientCredentials
     */
    scope: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ClientCredentialsGrantTypeEnum {
    AuthorizationCode = 'authorization_code',
    ClientCredentials = 'client_credentials',
    RefreshToken = 'refresh_token'
}

/**
 * 
 * @export
 * @interface ClientCredentialsParameter
 */
export interface ClientCredentialsParameter {
    /**
     * scope是一个空格分隔的字符串，客户端可以在使用客户端凭据许可（client_credentials）请求访问令牌时使用它们。权限范围字段参考Authentication章节。
     * @type {string}
     * @memberof ClientCredentialsParameter
     */
    scope: string;
}
/**
 * 设备信息
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 设备名称
     * @type {string}
     * @memberof Device
     */
    name?: string;
    /**
     * 客户端类型
     * @type {string}
     * @memberof Device
     */
    client_type: DeviceClientTypeEnum;
    /**
     * 设备描述，自定义。如： iphone5s ipad 联想一体机 mac
     * @type {string}
     * @memberof Device
     */
    description?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DeviceClientTypeEnum {
    Unknown = 'unknown',
    Ios = 'ios',
    Android = 'android',
    WindowsPhone = 'windows_phone',
    Windows = 'windows',
    MacOs = 'mac_os',
    Web = 'web',
    MobileWeb = 'mobile_web',
    ConsoleWeb = 'console_web',
    DeployWeb = 'deploy_web',
    Nas = 'nas'
}

/**
 * 
 * @export
 * @interface GrantType
 */
export interface GrantType {
    /**
     * 许可类型： - `authorization_code` 授权码许可 - `client_credentials` 客户端凭据许可 - `refresh_token` 刷新令牌 
     * @type {string}
     * @memberof GrantType
     */
    grant_type: GrantTypeGrantTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GrantTypeGrantTypeEnum {
    AuthorizationCode = 'authorization_code',
    ClientCredentials = 'client_credentials',
    RefreshToken = 'refresh_token'
}

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 要注销的令牌
     * @type {string}
     * @memberof InlineObject
     */
    token: string;
}
/**
 * 自定义的元数据。
 * @export
 * @interface Metadata
 */
export interface Metadata {
    [key: string]: object | any;

    /**
     * 
     * @type {Device}
     * @memberof Metadata
     */
    device: Device;
}
/**
 * @type NewTokenRequest
 * @export
 */
export type NewTokenRequest = AuthorizationCode | ClientCredentials | RefreshToken;

/**
 * 
 * @export
 * @interface RefreshToken
 */
export interface RefreshToken {
    /**
     * 许可类型： - `authorization_code` 授权码许可 - `client_credentials` 客户端凭据许可 - `refresh_token` 刷新令牌 
     * @type {string}
     * @memberof RefreshToken
     */
    grant_type: RefreshTokenGrantTypeEnum;
    /**
     * 使用授权码许可（authorization_code）获得code后，使用code在该端点申请令牌时会获得refresh_token。refresh_token用于刷新访问令牌（access_token）。使用刷新令牌刷新后，生成新的刷新令牌与访问令牌，旧的刷新令牌与访问令牌失效。
     * @type {string}
     * @memberof RefreshToken
     */
    refresh_token: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RefreshTokenGrantTypeEnum {
    AuthorizationCode = 'authorization_code',
    ClientCredentials = 'client_credentials',
    RefreshToken = 'refresh_token'
}

/**
 * 
 * @export
 * @interface RefreshTokenParameter
 */
export interface RefreshTokenParameter {
    /**
     * 使用授权码许可（authorization_code）获得code后，使用code在该端点申请令牌时会获得refresh_token。refresh_token用于刷新访问令牌（access_token）。使用刷新令牌刷新后，生成新的刷新令牌与访问令牌，旧的刷新令牌与访问令牌失效。
     * @type {string}
     * @memberof RefreshTokenParameter
     */
    refresh_token: string;
}
/**
 * 
 * @export
 * @interface RevokeTokenRequest
 */
export interface RevokeTokenRequest {
    /**
     * 要注销的令牌
     * @type {string}
     * @memberof RevokeTokenRequest
     */
    token: string;
}
/**
 * 
 * @export
 * @interface RootTypeFor500
 */
export interface RootTypeFor500 {
    /**
     * 错误名称
     * @type {string}
     * @memberof RootTypeFor500
     */
    error: string;
    /**
     * 描述包含有关错误性质的更多信息。
     * @type {string}
     * @memberof RootTypeFor500
     */
    error_description?: string;
    /**
     * 提示以帮助解决该错误。
     * @type {string}
     * @memberof RootTypeFor500
     */
    error_hint?: string;
    /**
     * 错误状态代码（404、403、401，...）。
     * @type {number}
     * @memberof RootTypeFor500
     */
    status_code?: number;
}
/**
 * 
 * @export
 * @interface RootTypeForCreateClient
 */
export interface RootTypeForCreateClient {
    /**
     * 一个URI字符串数组，在基于重定向的OAuth许可类型中使用，比如authorization_ code和implicit 
     * @type {Array<string>}
     * @memberof RootTypeForCreateClient
     */
    redirect_uris: Array<string>;
    /**
     * * 客户端获取令牌所使用的许可类型。该字段使用的值与令牌端点上grant_type 参数使用的值相同。   * 授权码许可（authorization_code），客户端将资源拥有者引导至授权端点，获取授权码，然后将授权码发回至令牌端点。需要对应使用的response_type为\"code\" * 隐式许可（implicit），客户端将资源拥有者引导至授权端点，直接获取令牌。需要对应使用的response_type为\"token id_token\" * 刷新令牌许可（refresh_token），在资源拥有者不在场的情况下，客户端使用刷新令牌获取新的访问令牌 * 注册时需要注册所有字段确保客户端功能完整
     * @type {Array<string>}
     * @memberof RootTypeForCreateClient
     */
    grant_types: Array<RootTypeForCreateClientGrantTypesEnum>;
    /**
     * 客户端使用的授权端点响应类型。客户端注册时需要注册全部字段确保客户端功能完整。
     * @type {Array<string>}
     * @memberof RootTypeForCreateClient
     */
    response_types: Array<RootTypeForCreateClientResponseTypesEnum>;
    /**
     * 可读的客户端显示名称 
     * @type {string}
     * @memberof RootTypeForCreateClient
     */
    client_name: string;
    /**
     * 客户端请求令牌时所有可用的权限范围。它的值是以空格分隔的字符串，与 OAuth协议中的同名字段一样。权限范围字段参考Authentication章节。注册时应包含\"offline\",\"openid\"和\"all\"。
     * @type {string}
     * @memberof RootTypeForCreateClient
     */
    scope: string;
    /**
     * 执行注销时，发送注销用户请求需要参数post_logout_redirect_uri与其他参数（参考\"注销用户\"请求）,客户端发送注销用户请求可以请求使用post_logout_redirect_uri参数将最终用户的用户代理（浏览器）重定向到的客户端注册时提供的post_logout_reditect_uris的URL数组中的一个url。post_logout_reditect_uris注册的值必须与至少一个已注册的redirect_uri的方案，域，端口匹配。
     * @type {Array<string>}
     * @memberof RootTypeForCreateClient
     */
    post_logout_redirect_uris: Array<string>;
    /**
     * 
     * @type {Metadata}
     * @memberof RootTypeForCreateClient
     */
    metadata: Metadata;
}

/**
    * @export
    * @enum {string}
    */
export enum RootTypeForCreateClientGrantTypesEnum {
    AuthorizationCode = 'authorization_code',
    Implicit = 'implicit',
    RefreshToken = 'refresh_token'
}
/**
    * @export
    * @enum {string}
    */
export enum RootTypeForCreateClientResponseTypesEnum {
    Code = 'code',
    Token = 'token',
    TokenIdToken = 'token id_token'
}

/**
 * 
 * @export
 * @interface RootTypeForOkListclient
 */
export interface RootTypeForOkListclient {
    /**
     * 此客户端的ID。
     * @type {string}
     * @memberof RootTypeForOkListclient
     */
    client_id: string;
    /**
     * secret是客户端的secret。secret将以明文形式包含在创建请求中，然后再也不会包含。secret使用BCrypt存储，因此无法恢复。对于客户端，他们需要写下secret，因为secret将不会再被返回。
     * @type {string}
     * @memberof RootTypeForOkListclient
     */
    client_secret: string;
}
/**
 * 
 * @export
 * @interface RootTypeForOkToken
 */
export interface RootTypeForOkToken {
    /**
     * 访问令牌
     * @type {string}
     * @memberof RootTypeForOkToken
     */
    access_token: string;
    /**
     * 令牌到期时间
     * @type {number}
     * @memberof RootTypeForOkToken
     */
    expires_in: number;
    /**
     * 刷新令牌，用于刷新访问令牌
     * @type {string}
     * @memberof RootTypeForOkToken
     */
    refresh_token?: string;
    /**
     * scope是一个空格分隔的字符串，客户端可以在使用客户端凭据许可（client_credentials）请求访问令牌时使用它们。权限范围字段参考Authentication章节。
     * @type {string}
     * @memberof RootTypeForOkToken
     */
    scope: string;
    /**
     * 令牌类型
     * @type {string}
     * @memberof RootTypeForOkToken
     */
    token_type: string;
    /**
     * id_token设置了OpenID Connect ID令牌的会话数据。
     * @type {string}
     * @memberof RootTypeForOkToken
     */
    id_token?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OAuth 2.0授权端点。    * 授权码模式：      * 发送授权请求示例：    `https://127.0.0.1:443/oauth2/auth?client_id=50a26fca-3ea3-48e0-8080-72831630a305&redirect_uri=https%3A%2F%2F127.0.0.1%3A9010%2Fcallback&response_type=code&scope=openid%20offline%20all&state=eopcgglerargnyobjbcbccuk`    * 在经过认证与授权操作后,最终会跳转到redirect_uri处,在redirect_uri处url中会包含code、scope、state。例如：    `https://127.0.0.1:9010/callback?code=fH2w0L-67T0rY9zZQazB36bisniO7jMErLY4ugJwWlw.7zGL-nwFXWPQUM2yARDQJi7_JR1Cn6nFoOKiKdrzzMk&scope=offline%20openid%20all&state=eopcgglerargnyobjbcbccuk`     * 隐式模式:      * 使用隐式流程时，response_type需要使用[\"token id_token\"]并且请求中需要携带nonce参数。      * 发送授权请求示例：    `https://127.0.0.1:443/oauth2/auth?client_id=50a26fca-3ea3-48e0-8080-72831630a305&nonce=hmtveagpyukgfkfqqwslxptb&redirect_uri=https%3A%2F%2F127.0.0.1%3A9010%2Fcallback&response_type=token%20id_token&scope=openid%20all&state=eopcgglerargnyobjbcbccuk`    * 在经过认证与授权操作后,最终会跳转到redirect_uri处,在redirect_uri处url中会包含access_token、expirses_in、scope、state、token_type、id_token,例如：    `https://127.0.0.1:9010/callback#access_token=JOt1Vxg9FEWPLgRO9Iv8gNdbWpFVRwtu9n69nbZzob4.b6Cr4yXyWLkuTIFumj8s6KiR_gvLkwPcTwxaK5jzmvk&expires_in=3599&id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6InB1YmxpYzozMjAzMTA2Ni0zMGMzLTQ1MTItYmM1NS05YzlmOGJhNDBmYzYiLCJ0eXAiOiJKV1QifQ.eyJhdF9oYXNoIjoicVM0ZlU3cEJnRS0zWDdOTTJrYlhadyIsImF1ZCI6WyJrZWh1Il0sImF1dGhfdGltZSI6MTU5MDExODczMCwiZXhwIjoxNTkwMTIyMzUxLCJpYXQiOjE1OTAxMTg3NTEsImlzcyI6Imh0dHA6Ly8xMC4yLjE3Ni4yMDQ6NDQ0NC8iLCJqdGkiOiJlMGM4OTgwMi1mOTRjLTRlOWMtOTg0ZS0xOWY2MzhkM2YyZjYiLCJub25jZSI6ImRjeG9tbnd5cmF4end3aG1uaGdmZGl0ZiIsInJhdCI6MTU5MDExODcyMiwic2lkIjoiYjA2MmM2YzMtNTE3Zi00NGJkLWI2YzYtMzJkZjc4OTQ5Y2RiIiwic3ViIjoiM2M3MWYyNWMtN2QyMS0xMWVhLThmZGEtMDA1MDU2ODIifQ.gZ3-j3bHSlqEexXH8iEMzuwUKAGQcYrQgzxu_QIEa_tzAiFGvFX_qQWW0kobZrmSMdBHy2qY_zOREcS-eJ1M6_5KQhz5M7llKU3gjUVwi7Pv_dFjp1tXopMSoQaID_LTX95qqczVNmGfoI3DKGvltDXJw0SXK6yXSkluyHbukLuH5X6TCozpfU1Wlh8PXFXU0G5Vr59MwrN2n3r_FQLg5IPQ4ctmmH34jsyXJWl_V1lZy4qSweVcVRyFRsAlzYFx2g3WvNie6BEnquiMVmNrZR5Y3KTQyUO35jhtxInfYDqstY3TAGbBY3xM2-uUK5oQtWWbe9Iy6x0mDDfs3S10gIE2leVUnS15YGuIT5mEkV_V9oCo3eLHNcxFsg55rWizjWg8Y9ZTFlHZsIH6l1-duQyFjeAX8ZgYQqfAUx4UIqzdNYzkMZEE5Ck2Ytylc8QwYRegWuKN2jlLuhGSl-YByRGgSt6jrWOpFsYR6_PUw_6D14ZrEvvQumNRAaMRqRQTLJ18c_0YGp1oelUtro1vt5KS6guXnZtrA6sJgFcc6HM06gvyKX5qs0WdrPWUh_7LgjnJ-IcP4Ck8jIiuhvPpuqD7gagk_gxfUDO1ktiR3P3a6MS7qwA5bq4CR1Egjgo2uiN8tGbd5V1zbEIDaaliJO1rW12KTqU_XsSarPM29FM&scope=openid%20all&state=eopcgglerargnyobjbcbccuk&token_type=bearer` 
         * @summary 请求授权
         * @param {string} clientId 客户端ID
         * @param {string} nonce 在请求身份认证时发送的字符串，与state参数类似，用于缓解重放攻击。
         * @param {string} redirectUri 注册客户端时填写的回调uri
         * @param {string} responseType 授权端点响应类型
         * @param {string} scope 申请的权限范围字段，权限范围字段参考Authentication章节。 * 授权码模式发送授权请求应包含\&quot;offline\&quot;，\&quot;openid\&quot;，\&quot;all\&quot;。 * 隐式模式下无需刷新令牌，应包含\&quot;openid\&quot;，\&quot;all\&quot;。 * \&quot;all\&quot;用于使令牌功能完整。
         * @param {string} state 随机生成的字符串
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthGet(clientId: string, nonce: string, redirectUri: string, responseType: string, scope: string, state: string, options: any = {}): RequestArgs {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling oauth2AuthGet.');
            }
            // verify required parameter 'nonce' is not null or undefined
            if (nonce === null || nonce === undefined) {
                throw new RequiredError('nonce','Required parameter nonce was null or undefined when calling oauth2AuthGet.');
            }
            // verify required parameter 'redirectUri' is not null or undefined
            if (redirectUri === null || redirectUri === undefined) {
                throw new RequiredError('redirectUri','Required parameter redirectUri was null or undefined when calling oauth2AuthGet.');
            }
            // verify required parameter 'responseType' is not null or undefined
            if (responseType === null || responseType === undefined) {
                throw new RequiredError('responseType','Required parameter responseType was null or undefined when calling oauth2AuthGet.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling oauth2AuthGet.');
            }
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new RequiredError('state','Required parameter state was null or undefined when calling oauth2AuthGet.');
            }
            const localVarPath = `/oauth2/auth`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            if (nonce !== undefined) {
                localVarQueryParameter['nonce'] = nonce;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete (localVarUrlObj as Partial<typeof localVarUrlObj>).search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 注册OAuth 2.0客户端。
         * @summary 动态注册
         * @param {RootTypeForCreateClient} [rootTypeForCreateClient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2ClientsPost(rootTypeForCreateClient?: RootTypeForCreateClient, options: any = {}): RequestArgs {
            const localVarPath = `/oauth2/clients`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete (localVarUrlObj as Partial<typeof localVarUrlObj>).search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof rootTypeForCreateClient !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(rootTypeForCreateClient !== undefined ? rootTypeForCreateClient : {}) : (rootTypeForCreateClient || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 注销访问令牌或刷新令牌都意味着令牌失效（注销刷新令牌访问令牌也会无效）。令牌只能由生成其的客户端注销。
         * @summary 注销令牌
         * @param {string} token 要注销的令牌
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2RevokePost(token: string, options: any = {}): RequestArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling oauth2RevokePost.');
            }
            const localVarPath = `/oauth2/revoke`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (token !== undefined) { 
                localVarFormParams.set('token', token as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete (localVarUrlObj as Partial<typeof localVarUrlObj>).search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 注销用户登录，该端点不会删除任何访问令牌（access_token）、刷新令牌（refresh_token）。
         * @summary 注销用户
         * @param {string} idTokenHint 使用openid权限获得的id_token
         * @param {string} postLogoutRedirectUri 执行注销时,客户端发送注销用户请求可以请求使用post_logout_redirect_uri参数将最终用户的用户代理（浏览器）重定向到的客户端注册时提供的post_logout_reditect_uris的URL数组中的一个url。post_logout_reditect_uris注册的值必须与至少一个已注册的redirect_uri的方案，域，端口匹配。
         * @param {string} state 随机生成的字符串
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2SessionsLogoutGet(idTokenHint: string, postLogoutRedirectUri: string, state: string, options: any = {}): RequestArgs {
            // verify required parameter 'idTokenHint' is not null or undefined
            if (idTokenHint === null || idTokenHint === undefined) {
                throw new RequiredError('idTokenHint','Required parameter idTokenHint was null or undefined when calling oauth2SessionsLogoutGet.');
            }
            // verify required parameter 'postLogoutRedirectUri' is not null or undefined
            if (postLogoutRedirectUri === null || postLogoutRedirectUri === undefined) {
                throw new RequiredError('postLogoutRedirectUri','Required parameter postLogoutRedirectUri was null or undefined when calling oauth2SessionsLogoutGet.');
            }
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new RequiredError('state','Required parameter state was null or undefined when calling oauth2SessionsLogoutGet.');
            }
            const localVarPath = `/oauth2/sessions/logout`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idTokenHint !== undefined) {
                localVarQueryParameter['id_token_hint'] = idTokenHint;
            }

            if (postLogoutRedirectUri !== undefined) {
                localVarQueryParameter['post_logout_redirect_uri'] = postLogoutRedirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete (localVarUrlObj as Partial<typeof localVarUrlObj>).search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OAuth 2.0令牌端点,用于获取令牌、刷新访问令牌、客户端凭据模式（client_credentials）换取令牌。
         * @summary 申请令牌
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2TokenPost(options: any = {}): RequestArgs {
            const localVarPath = `/oauth2/token`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete (localVarUrlObj as Partial<typeof localVarUrlObj>).search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * OAuth 2.0授权端点。    * 授权码模式：      * 发送授权请求示例：    `https://127.0.0.1:443/oauth2/auth?client_id=50a26fca-3ea3-48e0-8080-72831630a305&redirect_uri=https%3A%2F%2F127.0.0.1%3A9010%2Fcallback&response_type=code&scope=openid%20offline%20all&state=eopcgglerargnyobjbcbccuk`    * 在经过认证与授权操作后,最终会跳转到redirect_uri处,在redirect_uri处url中会包含code、scope、state。例如：    `https://127.0.0.1:9010/callback?code=fH2w0L-67T0rY9zZQazB36bisniO7jMErLY4ugJwWlw.7zGL-nwFXWPQUM2yARDQJi7_JR1Cn6nFoOKiKdrzzMk&scope=offline%20openid%20all&state=eopcgglerargnyobjbcbccuk`     * 隐式模式:      * 使用隐式流程时，response_type需要使用[\"token id_token\"]并且请求中需要携带nonce参数。      * 发送授权请求示例：    `https://127.0.0.1:443/oauth2/auth?client_id=50a26fca-3ea3-48e0-8080-72831630a305&nonce=hmtveagpyukgfkfqqwslxptb&redirect_uri=https%3A%2F%2F127.0.0.1%3A9010%2Fcallback&response_type=token%20id_token&scope=openid%20all&state=eopcgglerargnyobjbcbccuk`    * 在经过认证与授权操作后,最终会跳转到redirect_uri处,在redirect_uri处url中会包含access_token、expirses_in、scope、state、token_type、id_token,例如：    `https://127.0.0.1:9010/callback#access_token=JOt1Vxg9FEWPLgRO9Iv8gNdbWpFVRwtu9n69nbZzob4.b6Cr4yXyWLkuTIFumj8s6KiR_gvLkwPcTwxaK5jzmvk&expires_in=3599&id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6InB1YmxpYzozMjAzMTA2Ni0zMGMzLTQ1MTItYmM1NS05YzlmOGJhNDBmYzYiLCJ0eXAiOiJKV1QifQ.eyJhdF9oYXNoIjoicVM0ZlU3cEJnRS0zWDdOTTJrYlhadyIsImF1ZCI6WyJrZWh1Il0sImF1dGhfdGltZSI6MTU5MDExODczMCwiZXhwIjoxNTkwMTIyMzUxLCJpYXQiOjE1OTAxMTg3NTEsImlzcyI6Imh0dHA6Ly8xMC4yLjE3Ni4yMDQ6NDQ0NC8iLCJqdGkiOiJlMGM4OTgwMi1mOTRjLTRlOWMtOTg0ZS0xOWY2MzhkM2YyZjYiLCJub25jZSI6ImRjeG9tbnd5cmF4end3aG1uaGdmZGl0ZiIsInJhdCI6MTU5MDExODcyMiwic2lkIjoiYjA2MmM2YzMtNTE3Zi00NGJkLWI2YzYtMzJkZjc4OTQ5Y2RiIiwic3ViIjoiM2M3MWYyNWMtN2QyMS0xMWVhLThmZGEtMDA1MDU2ODIifQ.gZ3-j3bHSlqEexXH8iEMzuwUKAGQcYrQgzxu_QIEa_tzAiFGvFX_qQWW0kobZrmSMdBHy2qY_zOREcS-eJ1M6_5KQhz5M7llKU3gjUVwi7Pv_dFjp1tXopMSoQaID_LTX95qqczVNmGfoI3DKGvltDXJw0SXK6yXSkluyHbukLuH5X6TCozpfU1Wlh8PXFXU0G5Vr59MwrN2n3r_FQLg5IPQ4ctmmH34jsyXJWl_V1lZy4qSweVcVRyFRsAlzYFx2g3WvNie6BEnquiMVmNrZR5Y3KTQyUO35jhtxInfYDqstY3TAGbBY3xM2-uUK5oQtWWbe9Iy6x0mDDfs3S10gIE2leVUnS15YGuIT5mEkV_V9oCo3eLHNcxFsg55rWizjWg8Y9ZTFlHZsIH6l1-duQyFjeAX8ZgYQqfAUx4UIqzdNYzkMZEE5Ck2Ytylc8QwYRegWuKN2jlLuhGSl-YByRGgSt6jrWOpFsYR6_PUw_6D14ZrEvvQumNRAaMRqRQTLJ18c_0YGp1oelUtro1vt5KS6guXnZtrA6sJgFcc6HM06gvyKX5qs0WdrPWUh_7LgjnJ-IcP4Ck8jIiuhvPpuqD7gagk_gxfUDO1ktiR3P3a6MS7qwA5bq4CR1Egjgo2uiN8tGbd5V1zbEIDaaliJO1rW12KTqU_XsSarPM29FM&scope=openid%20all&state=eopcgglerargnyobjbcbccuk&token_type=bearer` 
         * @summary 请求授权
         * @param {string} clientId 客户端ID
         * @param {string} nonce 在请求身份认证时发送的字符串，与state参数类似，用于缓解重放攻击。
         * @param {string} redirectUri 注册客户端时填写的回调uri
         * @param {string} responseType 授权端点响应类型
         * @param {string} scope 申请的权限范围字段，权限范围字段参考Authentication章节。 * 授权码模式发送授权请求应包含\&quot;offline\&quot;，\&quot;openid\&quot;，\&quot;all\&quot;。 * 隐式模式下无需刷新令牌，应包含\&quot;openid\&quot;，\&quot;all\&quot;。 * \&quot;all\&quot;用于使令牌功能完整。
         * @param {string} state 随机生成的字符串
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthGet(clientId: string, nonce: string, redirectUri: string, responseType: string, scope: string, state: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).oauth2AuthGet(clientId, nonce, redirectUri, responseType, scope, state, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 注册OAuth 2.0客户端。
         * @summary 动态注册
         * @param {RootTypeForCreateClient} [rootTypeForCreateClient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2ClientsPost(rootTypeForCreateClient?: RootTypeForCreateClient, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootTypeForOkListclient> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).oauth2ClientsPost(rootTypeForCreateClient, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 注销访问令牌或刷新令牌都意味着令牌失效（注销刷新令牌访问令牌也会无效）。令牌只能由生成其的客户端注销。
         * @summary 注销令牌
         * @param {string} token 要注销的令牌
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2RevokePost(token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).oauth2RevokePost(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 注销用户登录，该端点不会删除任何访问令牌（access_token）、刷新令牌（refresh_token）。
         * @summary 注销用户
         * @param {string} idTokenHint 使用openid权限获得的id_token
         * @param {string} postLogoutRedirectUri 执行注销时,客户端发送注销用户请求可以请求使用post_logout_redirect_uri参数将最终用户的用户代理（浏览器）重定向到的客户端注册时提供的post_logout_reditect_uris的URL数组中的一个url。post_logout_reditect_uris注册的值必须与至少一个已注册的redirect_uri的方案，域，端口匹配。
         * @param {string} state 随机生成的字符串
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2SessionsLogoutGet(idTokenHint: string, postLogoutRedirectUri: string, state: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).oauth2SessionsLogoutGet(idTokenHint, postLogoutRedirectUri, state, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * OAuth 2.0令牌端点,用于获取令牌、刷新访问令牌、客户端凭据模式（client_credentials）换取令牌。
         * @summary 申请令牌
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2TokenPost(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootTypeForOkToken> {
            const localVarAxiosArgs = DefaultApiAxiosParamCreator(configuration).oauth2TokenPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * OAuth 2.0授权端点。    * 授权码模式：      * 发送授权请求示例：    `https://127.0.0.1:443/oauth2/auth?client_id=50a26fca-3ea3-48e0-8080-72831630a305&redirect_uri=https%3A%2F%2F127.0.0.1%3A9010%2Fcallback&response_type=code&scope=openid%20offline%20all&state=eopcgglerargnyobjbcbccuk`    * 在经过认证与授权操作后,最终会跳转到redirect_uri处,在redirect_uri处url中会包含code、scope、state。例如：    `https://127.0.0.1:9010/callback?code=fH2w0L-67T0rY9zZQazB36bisniO7jMErLY4ugJwWlw.7zGL-nwFXWPQUM2yARDQJi7_JR1Cn6nFoOKiKdrzzMk&scope=offline%20openid%20all&state=eopcgglerargnyobjbcbccuk`     * 隐式模式:      * 使用隐式流程时，response_type需要使用[\"token id_token\"]并且请求中需要携带nonce参数。      * 发送授权请求示例：    `https://127.0.0.1:443/oauth2/auth?client_id=50a26fca-3ea3-48e0-8080-72831630a305&nonce=hmtveagpyukgfkfqqwslxptb&redirect_uri=https%3A%2F%2F127.0.0.1%3A9010%2Fcallback&response_type=token%20id_token&scope=openid%20all&state=eopcgglerargnyobjbcbccuk`    * 在经过认证与授权操作后,最终会跳转到redirect_uri处,在redirect_uri处url中会包含access_token、expirses_in、scope、state、token_type、id_token,例如：    `https://127.0.0.1:9010/callback#access_token=JOt1Vxg9FEWPLgRO9Iv8gNdbWpFVRwtu9n69nbZzob4.b6Cr4yXyWLkuTIFumj8s6KiR_gvLkwPcTwxaK5jzmvk&expires_in=3599&id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6InB1YmxpYzozMjAzMTA2Ni0zMGMzLTQ1MTItYmM1NS05YzlmOGJhNDBmYzYiLCJ0eXAiOiJKV1QifQ.eyJhdF9oYXNoIjoicVM0ZlU3cEJnRS0zWDdOTTJrYlhadyIsImF1ZCI6WyJrZWh1Il0sImF1dGhfdGltZSI6MTU5MDExODczMCwiZXhwIjoxNTkwMTIyMzUxLCJpYXQiOjE1OTAxMTg3NTEsImlzcyI6Imh0dHA6Ly8xMC4yLjE3Ni4yMDQ6NDQ0NC8iLCJqdGkiOiJlMGM4OTgwMi1mOTRjLTRlOWMtOTg0ZS0xOWY2MzhkM2YyZjYiLCJub25jZSI6ImRjeG9tbnd5cmF4end3aG1uaGdmZGl0ZiIsInJhdCI6MTU5MDExODcyMiwic2lkIjoiYjA2MmM2YzMtNTE3Zi00NGJkLWI2YzYtMzJkZjc4OTQ5Y2RiIiwic3ViIjoiM2M3MWYyNWMtN2QyMS0xMWVhLThmZGEtMDA1MDU2ODIifQ.gZ3-j3bHSlqEexXH8iEMzuwUKAGQcYrQgzxu_QIEa_tzAiFGvFX_qQWW0kobZrmSMdBHy2qY_zOREcS-eJ1M6_5KQhz5M7llKU3gjUVwi7Pv_dFjp1tXopMSoQaID_LTX95qqczVNmGfoI3DKGvltDXJw0SXK6yXSkluyHbukLuH5X6TCozpfU1Wlh8PXFXU0G5Vr59MwrN2n3r_FQLg5IPQ4ctmmH34jsyXJWl_V1lZy4qSweVcVRyFRsAlzYFx2g3WvNie6BEnquiMVmNrZR5Y3KTQyUO35jhtxInfYDqstY3TAGbBY3xM2-uUK5oQtWWbe9Iy6x0mDDfs3S10gIE2leVUnS15YGuIT5mEkV_V9oCo3eLHNcxFsg55rWizjWg8Y9ZTFlHZsIH6l1-duQyFjeAX8ZgYQqfAUx4UIqzdNYzkMZEE5Ck2Ytylc8QwYRegWuKN2jlLuhGSl-YByRGgSt6jrWOpFsYR6_PUw_6D14ZrEvvQumNRAaMRqRQTLJ18c_0YGp1oelUtro1vt5KS6guXnZtrA6sJgFcc6HM06gvyKX5qs0WdrPWUh_7LgjnJ-IcP4Ck8jIiuhvPpuqD7gagk_gxfUDO1ktiR3P3a6MS7qwA5bq4CR1Egjgo2uiN8tGbd5V1zbEIDaaliJO1rW12KTqU_XsSarPM29FM&scope=openid%20all&state=eopcgglerargnyobjbcbccuk&token_type=bearer` 
         * @summary 请求授权
         * @param {string} clientId 客户端ID
         * @param {string} nonce 在请求身份认证时发送的字符串，与state参数类似，用于缓解重放攻击。
         * @param {string} redirectUri 注册客户端时填写的回调uri
         * @param {string} responseType 授权端点响应类型
         * @param {string} scope 申请的权限范围字段，权限范围字段参考Authentication章节。 * 授权码模式发送授权请求应包含\&quot;offline\&quot;，\&quot;openid\&quot;，\&quot;all\&quot;。 * 隐式模式下无需刷新令牌，应包含\&quot;openid\&quot;，\&quot;all\&quot;。 * \&quot;all\&quot;用于使令牌功能完整。
         * @param {string} state 随机生成的字符串
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2AuthGet(clientId: string, nonce: string, redirectUri: string, responseType: string, scope: string, state: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).oauth2AuthGet(clientId, nonce, redirectUri, responseType, scope, state, options)(axios, basePath);
        },
        /**
         * 注册OAuth 2.0客户端。
         * @summary 动态注册
         * @param {RootTypeForCreateClient} [rootTypeForCreateClient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2ClientsPost(rootTypeForCreateClient?: RootTypeForCreateClient, options?: any): AxiosPromise<RootTypeForOkListclient> {
            return DefaultApiFp(configuration).oauth2ClientsPost(rootTypeForCreateClient, options)(axios, basePath);
        },
        /**
         * 注销访问令牌或刷新令牌都意味着令牌失效（注销刷新令牌访问令牌也会无效）。令牌只能由生成其的客户端注销。
         * @summary 注销令牌
         * @param {string} token 要注销的令牌
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2RevokePost(token: string, options?: any): AxiosPromise<object> {
            return DefaultApiFp(configuration).oauth2RevokePost(token, options)(axios, basePath);
        },
        /**
         * 注销用户登录，该端点不会删除任何访问令牌（access_token）、刷新令牌（refresh_token）。
         * @summary 注销用户
         * @param {string} idTokenHint 使用openid权限获得的id_token
         * @param {string} postLogoutRedirectUri 执行注销时,客户端发送注销用户请求可以请求使用post_logout_redirect_uri参数将最终用户的用户代理（浏览器）重定向到的客户端注册时提供的post_logout_reditect_uris的URL数组中的一个url。post_logout_reditect_uris注册的值必须与至少一个已注册的redirect_uri的方案，域，端口匹配。
         * @param {string} state 随机生成的字符串
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2SessionsLogoutGet(idTokenHint: string, postLogoutRedirectUri: string, state: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).oauth2SessionsLogoutGet(idTokenHint, postLogoutRedirectUri, state, options)(axios, basePath);
        },
        /**
         * OAuth 2.0令牌端点,用于获取令牌、刷新访问令牌、客户端凭据模式（client_credentials）换取令牌。
         * @summary 申请令牌
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth2TokenPost(options?: any): AxiosPromise<RootTypeForOkToken> {
            return DefaultApiFp(configuration).oauth2TokenPost(options)(axios, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * OAuth 2.0授权端点。    * 授权码模式：      * 发送授权请求示例：    `https://127.0.0.1:443/oauth2/auth?client_id=50a26fca-3ea3-48e0-8080-72831630a305&redirect_uri=https%3A%2F%2F127.0.0.1%3A9010%2Fcallback&response_type=code&scope=openid%20offline%20all&state=eopcgglerargnyobjbcbccuk`    * 在经过认证与授权操作后,最终会跳转到redirect_uri处,在redirect_uri处url中会包含code、scope、state。例如：    `https://127.0.0.1:9010/callback?code=fH2w0L-67T0rY9zZQazB36bisniO7jMErLY4ugJwWlw.7zGL-nwFXWPQUM2yARDQJi7_JR1Cn6nFoOKiKdrzzMk&scope=offline%20openid%20all&state=eopcgglerargnyobjbcbccuk`     * 隐式模式:      * 使用隐式流程时，response_type需要使用[\"token id_token\"]并且请求中需要携带nonce参数。      * 发送授权请求示例：    `https://127.0.0.1:443/oauth2/auth?client_id=50a26fca-3ea3-48e0-8080-72831630a305&nonce=hmtveagpyukgfkfqqwslxptb&redirect_uri=https%3A%2F%2F127.0.0.1%3A9010%2Fcallback&response_type=token%20id_token&scope=openid%20all&state=eopcgglerargnyobjbcbccuk`    * 在经过认证与授权操作后,最终会跳转到redirect_uri处,在redirect_uri处url中会包含access_token、expirses_in、scope、state、token_type、id_token,例如：    `https://127.0.0.1:9010/callback#access_token=JOt1Vxg9FEWPLgRO9Iv8gNdbWpFVRwtu9n69nbZzob4.b6Cr4yXyWLkuTIFumj8s6KiR_gvLkwPcTwxaK5jzmvk&expires_in=3599&id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6InB1YmxpYzozMjAzMTA2Ni0zMGMzLTQ1MTItYmM1NS05YzlmOGJhNDBmYzYiLCJ0eXAiOiJKV1QifQ.eyJhdF9oYXNoIjoicVM0ZlU3cEJnRS0zWDdOTTJrYlhadyIsImF1ZCI6WyJrZWh1Il0sImF1dGhfdGltZSI6MTU5MDExODczMCwiZXhwIjoxNTkwMTIyMzUxLCJpYXQiOjE1OTAxMTg3NTEsImlzcyI6Imh0dHA6Ly8xMC4yLjE3Ni4yMDQ6NDQ0NC8iLCJqdGkiOiJlMGM4OTgwMi1mOTRjLTRlOWMtOTg0ZS0xOWY2MzhkM2YyZjYiLCJub25jZSI6ImRjeG9tbnd5cmF4end3aG1uaGdmZGl0ZiIsInJhdCI6MTU5MDExODcyMiwic2lkIjoiYjA2MmM2YzMtNTE3Zi00NGJkLWI2YzYtMzJkZjc4OTQ5Y2RiIiwic3ViIjoiM2M3MWYyNWMtN2QyMS0xMWVhLThmZGEtMDA1MDU2ODIifQ.gZ3-j3bHSlqEexXH8iEMzuwUKAGQcYrQgzxu_QIEa_tzAiFGvFX_qQWW0kobZrmSMdBHy2qY_zOREcS-eJ1M6_5KQhz5M7llKU3gjUVwi7Pv_dFjp1tXopMSoQaID_LTX95qqczVNmGfoI3DKGvltDXJw0SXK6yXSkluyHbukLuH5X6TCozpfU1Wlh8PXFXU0G5Vr59MwrN2n3r_FQLg5IPQ4ctmmH34jsyXJWl_V1lZy4qSweVcVRyFRsAlzYFx2g3WvNie6BEnquiMVmNrZR5Y3KTQyUO35jhtxInfYDqstY3TAGbBY3xM2-uUK5oQtWWbe9Iy6x0mDDfs3S10gIE2leVUnS15YGuIT5mEkV_V9oCo3eLHNcxFsg55rWizjWg8Y9ZTFlHZsIH6l1-duQyFjeAX8ZgYQqfAUx4UIqzdNYzkMZEE5Ck2Ytylc8QwYRegWuKN2jlLuhGSl-YByRGgSt6jrWOpFsYR6_PUw_6D14ZrEvvQumNRAaMRqRQTLJ18c_0YGp1oelUtro1vt5KS6guXnZtrA6sJgFcc6HM06gvyKX5qs0WdrPWUh_7LgjnJ-IcP4Ck8jIiuhvPpuqD7gagk_gxfUDO1ktiR3P3a6MS7qwA5bq4CR1Egjgo2uiN8tGbd5V1zbEIDaaliJO1rW12KTqU_XsSarPM29FM&scope=openid%20all&state=eopcgglerargnyobjbcbccuk&token_type=bearer` 
     * @summary 请求授权
     * @param {string} clientId 客户端ID
     * @param {string} nonce 在请求身份认证时发送的字符串，与state参数类似，用于缓解重放攻击。
     * @param {string} redirectUri 注册客户端时填写的回调uri
     * @param {string} responseType 授权端点响应类型
     * @param {string} scope 申请的权限范围字段，权限范围字段参考Authentication章节。 * 授权码模式发送授权请求应包含\&quot;offline\&quot;，\&quot;openid\&quot;，\&quot;all\&quot;。 * 隐式模式下无需刷新令牌，应包含\&quot;openid\&quot;，\&quot;all\&quot;。 * \&quot;all\&quot;用于使令牌功能完整。
     * @param {string} state 随机生成的字符串
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public oauth2AuthGet(clientId: string, nonce: string, redirectUri: string, responseType: string, scope: string, state: string, options?: any) {
        return DefaultApiFp(this.configuration).oauth2AuthGet(clientId, nonce, redirectUri, responseType, scope, state, options)(this.axios, this.basePath);
    }

    /**
     * 注册OAuth 2.0客户端。
     * @summary 动态注册
     * @param {RootTypeForCreateClient} [rootTypeForCreateClient] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public oauth2ClientsPost(rootTypeForCreateClient?: RootTypeForCreateClient, options?: any) {
        return DefaultApiFp(this.configuration).oauth2ClientsPost(rootTypeForCreateClient, options)(this.axios, this.basePath);
    }

    /**
     * 注销访问令牌或刷新令牌都意味着令牌失效（注销刷新令牌访问令牌也会无效）。令牌只能由生成其的客户端注销。
     * @summary 注销令牌
     * @param {string} token 要注销的令牌
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public oauth2RevokePost(token: string, options?: any) {
        return DefaultApiFp(this.configuration).oauth2RevokePost(token, options)(this.axios, this.basePath);
    }

    /**
     * 注销用户登录，该端点不会删除任何访问令牌（access_token）、刷新令牌（refresh_token）。
     * @summary 注销用户
     * @param {string} idTokenHint 使用openid权限获得的id_token
     * @param {string} postLogoutRedirectUri 执行注销时,客户端发送注销用户请求可以请求使用post_logout_redirect_uri参数将最终用户的用户代理（浏览器）重定向到的客户端注册时提供的post_logout_reditect_uris的URL数组中的一个url。post_logout_reditect_uris注册的值必须与至少一个已注册的redirect_uri的方案，域，端口匹配。
     * @param {string} state 随机生成的字符串
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public oauth2SessionsLogoutGet(idTokenHint: string, postLogoutRedirectUri: string, state: string, options?: any) {
        return DefaultApiFp(this.configuration).oauth2SessionsLogoutGet(idTokenHint, postLogoutRedirectUri, state, options)(this.axios, this.basePath);
    }

    /**
     * OAuth 2.0令牌端点,用于获取令牌、刷新访问令牌、客户端凭据模式（client_credentials）换取令牌。
     * @summary 申请令牌
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public oauth2TokenPost(options?: any) {
        return DefaultApiFp(this.configuration).oauth2TokenPost(options)(this.axios, this.basePath);
    }

}


