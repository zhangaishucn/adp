// Code generated by MockGen. DO NOT EDIT.
// Source: ../interfaces/mq_access.go

// Package mock_interfaces is a generated GoMock package.
package mock_interfaces

import (
	interfaces "flow-stream-data-pipeline/pipeline-worker/interfaces"
	reflect "reflect"

	kafka "github.com/confluentinc/confluent-kafka-go/v2/kafka"
	gomock "github.com/golang/mock/gomock"
)

// MockMQAccess is a mock of MQAccess interface.
type MockMQAccess struct {
	ctrl     *gomock.Controller
	recorder *MockMQAccessMockRecorder
}

// MockMQAccessMockRecorder is the mock recorder for MockMQAccess.
type MockMQAccessMockRecorder struct {
	mock *MockMQAccess
}

// NewMockMQAccess creates a new mock instance.
func NewMockMQAccess(ctrl *gomock.Controller) *MockMQAccess {
	mock := &MockMQAccess{ctrl: ctrl}
	mock.recorder = &MockMQAccessMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMQAccess) EXPECT() *MockMQAccessMockRecorder {
	return m.recorder
}

// DoCommit mocks base method.
func (m *MockMQAccess) DoCommit(c *kafka.Consumer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoCommit", c)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoCommit indicates an expected call of DoCommit.
func (mr *MockMQAccessMockRecorder) DoCommit(c interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoCommit", reflect.TypeOf((*MockMQAccess)(nil).DoCommit), c)
}

// DoConsume mocks base method.
func (m *MockMQAccess) DoConsume(c *kafka.Consumer) (*kafka.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoConsume", c)
	ret0, _ := ret[0].(*kafka.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DoConsume indicates an expected call of DoConsume.
func (mr *MockMQAccessMockRecorder) DoConsume(c interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoConsume", reflect.TypeOf((*MockMQAccess)(nil).DoConsume), c)
}

// DoProduceAndCommit mocks base method.
func (m *MockMQAccess) DoProduceAndCommit(kp *interfaces.KafkaProducer, c *kafka.Consumer, msgs []*kafka.Message) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoProduceAndCommit", kp, c, msgs)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoProduceAndCommit indicates an expected call of DoProduceAndCommit.
func (mr *MockMQAccessMockRecorder) DoProduceAndCommit(kp, c, msgs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoProduceAndCommit", reflect.TypeOf((*MockMQAccess)(nil).DoProduceAndCommit), kp, c, msgs)
}

// NewConsumer mocks base method.
func (m *MockMQAccess) NewConsumer(groupID string) (*kafka.Consumer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewConsumer", groupID)
	ret0, _ := ret[0].(*kafka.Consumer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewConsumer indicates an expected call of NewConsumer.
func (mr *MockMQAccessMockRecorder) NewConsumer(groupID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewConsumer", reflect.TypeOf((*MockMQAccess)(nil).NewConsumer), groupID)
}

// NewTransactionalProducer mocks base method.
func (m *MockMQAccess) NewTransactionalProducer(txId string) (*kafka.Producer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewTransactionalProducer", txId)
	ret0, _ := ret[0].(*kafka.Producer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewTransactionalProducer indicates an expected call of NewTransactionalProducer.
func (mr *MockMQAccessMockRecorder) NewTransactionalProducer(txId interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewTransactionalProducer", reflect.TypeOf((*MockMQAccess)(nil).NewTransactionalProducer), txId)
}
