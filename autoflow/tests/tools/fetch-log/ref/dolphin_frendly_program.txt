DolphinLanguage语法规范（友好版）

阅读提示：本文档在保留完整技术规范的基础上，为非编程背景的业务人员提供了通俗易懂的解释说明。
✅ 正确写法：标记为正式语法，必须严格遵守
💡 可以这样理解：用生活化的比喻帮助理解概念


目录
1. 变量
2. 控制流
3. 函数调用
4. 自然语言指令
5. 嵌入代码块
6. 特殊指令
7. 函数封装
8. Agent初始化
9. 特殊代码块
10. 注释和文档
11. 输出格式控制
12. 高级语法特性
13. 最佳实践
14. 实际应用示例


1. 变量

1.1 定义变量

正确写法：
- 赋值：表达式  -> 变量名
- 追加：表达式  >> 变量名

可以这样理解：
- → 就像把东西放进一个贴了标签的箱子里
- >> 就像往箱子里继续添加更多东西
- 变量名就是箱子的标签，方便你找到它

示例：

@web_search(query="天气") -> result
@web_search(query="天气") >> result
"Hello World" -> greeting
["第一项", "第二项", "第三项"] -> test_array
{"user": {"name": "张三", "age": 25}} -> user_data

示例说明：
- 第1行：搜索天气，结果存入 result 箱子
- 第2行：再次搜索天气，结果追加到 result 箱子里
- 第3行：把问候语存入 greeting 箱子
- 第4行：把一个列表存入 test_array 箱子
- 第5行：把一个复杂的用户信息存入 user_data 箱子

1.2 使用变量

正确写法：
变量以 $ 开头，支持以下形式：
- 简单变量：$变量名
- 数组索引：$变量名[index]
- 嵌套属性：$变量名.key1.key2

可以这样理解：
- $ 表示"打开这个箱子看看里面有什么"
- [index] 表示"取第几个"（从0开始数）
- .key 表示"打开里面的小抽屉"

示例：

$x
$result[0]
$a.b.c
$test_array[0]  # 数组索引访问
$user_data.user.name  # 嵌套对象属性访问
$user_data.user.profile.city  # 深层嵌套访问

示例说明：
- $x：查看 x 箱子里的内容
- $result[0]：取 result 箱子里的第1项
- $a.b.c：打开 a 箱子，找到里面的 b，再找到 b 里面的 c
- $user_data.user.name：从用户数据中找到用户的姓名

1.3 变量运算

正确写法：
支持简单的字符串拼接和基本运算：

$greeting + " from Dolphin Language" -> finalMessage

可以这样理解：
- 就像把两个词拼在一起组成一个完整的句子
- + 表示"连接在一起"


2. 控制流

2.1 循环

正确写法：

/for/ $变量名 in $可迭代对象:
    语句块
/end/

可以这样理解：
- 就像说"对清单里的每一项，都做这些事"
- /for/ ... /end/ 之间的内容会重复执行
- 类似于生活中的"批量处理"

示例：

/for/ $text in $x:
    @web_search(query=$text) -> news
    总结一下$news >> summary_list
/end/

示例说明：
- 对于 x 箱子里的每一项文本
- 搜索相关信息并存入 news
- 总结后追加到 summary_list 清单中

2.2 条件判断

正确写法：

/if/ 条件表达式:
    语句块
elif 条件表达式:
    语句块
else:
    语句块
/end/

可以这样理解：
- if 就是"如果..."
- elif 就是"或者如果..."
- else 就是"否则..."
- 根据不同情况做不同处理，就像分支路口

示例：

@fetch_shopping_list(user_id="12345") -> shopping_list
/if/ len($shopping_list) > 10:
    @send_alert("购物清单太长了，需要精简一下！") -> alert_result
elif len($shopping_list) > 5:
    @send_alert("购物清单长度适中，可以直接执行采购。") -> alert_result
else:
    @send_alert("购物清单很短，轻松完成！") -> alert_result
/end/

示例说明：
- 如果购物清单超过10项：提醒太长
- 如果5-10项：提醒适中
- 如果少于5项：说很简单


3. 函数调用

正确写法：
使用 @函数名(参数列表) 调用函数，结果通过 -> 或 >> 赋值。(目前参数列表仅支持关键字参数)

@函数名(参数1, 参数2, ...) -> 变量名

可以这样理解：
- @函数名 就像是使用一个工具或APP
- 参数 就是告诉工具要做什么
- -> 变量名 就是把工具执行结果存起来

示例：

@news_search(query=$x) -> result
@llm_tagger($x, ['财经', '科技', '其它']) -> tag_result
@concepts(query=$query) -> conceptDescs
@getDataSourcesFromConcepts(conceptNames=$conceptInfos) -> datasources

示例说明：
- @news_search：使用新闻搜索工具
- @llm_tagger：使用AI分类工具
- @concepts：获取相关概念
- @getDataSourcesFromConcepts：根据概念获取数据源


4. 自然语言指令

4.1 基本语法

正确写法：
在 Dolphin Language 中，自然语言指令可以单独使用或与其他语法元素结合：

计算 5 + 3 的结果
-> result

可以这样理解：
- 可以直接用中文描述要做什么
- AI 会理解你的意思并执行

4.2 与变量结合

正确写法：

$result + 10
-> new_result

可以这样理解：
- 先用之前的结果
- 再做一些计算
- 存成新的结果

4.3 多行指令

正确写法：

第一步：获取用户输入
第二步：处理数据
第三步：返回结果
-> task_result

可以这样理解：
- 可以一步步描述任务流程
- 就像写工作计划


5. 嵌入代码块

5.1 Python 代码嵌入

正确写法：
使用三重引号嵌入 Python 代码：

'''
import json
data = {"key": "value"}
print(json.dumps(data))
''' -> code_result

可以这样理解：
- 三个引号之间的内容会被当作代码执行
- 适合做一些复杂的计算或数据处理

5.2 SQL 代码嵌入

正确写法：

'''
SELECT * FROM users WHERE age > 18;
''' -> query_result

可以这样理解：
- 可以直接写数据库查询语句
- 从数据库中提取需要的数据


6. 特殊指令

6.1 @DESC 指令

正确写法：
用于添加文档说明：

@DESC
这是一个数据处理Agent，用于清洗和转换数据
@DESC

可以这样理解：
- 就像是给AI助手写"工作说明书"
- 告诉AI它的职责是什么

6.2 @ASSIGN 指令

正确写法：
用于变量赋值：

@ASSIGN($source_data, "processed") -> data

可以这样理解：
- 对源数据进行标记
- 表示这是"已处理"的数据

6.3 @RUN 指令

正确写法：
用于执行代码块：

@RUN($python_code) -> execution_result

可以这样理解：
- 运行一段预先准备好的代码
- 保存执行结果


7. 函数封装

7.1 定义函数

正确写法：
虽然 Dolphin Language 主要用于工作流编排，但支持代码块封装：

/def/ process_data(input_data):
    @clean_data($input_data) -> cleaned
    @transform_data($cleaned) -> transformed
    return $transformed
/end/

可以这样理解：
- 把一系列操作打包成一个"套餐"
- 之后可以直接调用这个套餐
- 类似于录制一个"宏"或"快捷操作"

7.2 调用封装函数

正确写法：

@process_data($raw_data) -> processed_result

可以这样理解：
- 使用之前定义好的"套餐"
- 一键完成多个步骤

7.3 内置函数

正确写法：
Dolphin Language 提供多种内置函数：

@_date() -> current_date
@_time() -> current_time
@_random() -> random_value

可以这样理解：
- 系统自带的快捷工具
- @_date()：获取今天的日期
- @_time()：获取现在的时间
- @_random()：生成一个随机数


8. Agent初始化

8.1 使用 @DESC 初始化智能体

正确写法：

@DESC
这是一个专业的代码审查Agent，负责检查代码质量和安全漏洞
@DESC

可以这样理解：
- 就像招聘时写"职位描述"
- 告诉AI助手它要扮演什么角色

8.2 配置智能体参数

正确写法：

@DESC
名称：数据分析师
角色：分析数据趋势
工具：SQL, Python, 可视化
@DESC

可以这样理解：
- 详细描述AI助手的"人设"和"技能"
- 让AI知道应该如何工作

8.3 智能体间通信

正确写法：

@send_message(agent="analyzer", message=$analysis_request) -> response

可以这样理解：
- 让不同的AI助手之间互相协作
- 一个助手可以请求另一个助手帮忙


9. 特殊代码块

9.1 /prompt/ 代码块

正确写法：
用于直接调用LLM进行对话生成，支持多种参数配置。

/prompt/(参数列表) 提示内容 -> 变量名

支持的参数：
- model: 指定使用的模型
- system_prompt: 系统提示词
- output: 输出格式（"json", "jsonl", "list_str", "obj/ObjectType"）

可以这样理解：
- 直接和AI对话
- 可以指定AI的角色和输出格式
- 就像给AI下达一个明确的任务

示例：

/prompt/(model="v3", output="list_str") 根据问题描述返回相关概念 -> concepts
/prompt/(system_prompt="你是一个AI助手", model="qwen-plus") 创作一首诗 -> poem
/prompt/(output="json") 生成用户信息 -> user_info
/prompt/(output="jsonl") 生成三个用户记录 -> users

示例说明：
- 第1行：让AI列出相关概念
- 第2行：让AI写诗
- 第3行：让AI生成一个JSON格式的用户信息
- 第4行：让AI生成多个用户的JSONL格式数据

9.2 /explore/ 代码块

正确写法：
用于智能体探索和工具调用，支持多步推理。

/explore/(参数列表) 任务描述 -> 变量名

支持的参数：
- tools: 可用工具列表（支持通配符匹配：fnmatch/glob 语法 *、?、[abc]；也支持按 skillkit 命名空间：<skillkit>.<pattern>，如 resource_skillkit.*）
- model: 指定使用的模型
- system_prompt: 系统提示词
- enable_skill_deduplicator: 是否启用技能调用去重器，默认为 true。当设置为 false 时，将关闭技能去重逻辑（仅受最大调用次数限制）。

返回类型：Dict[str, Any] - 返回包含推理过程和最终答案的字典，通常包含"think"和"answer"字段

可以这样理解：
- 告诉AI要做什么，让AI自己想办法
- AI会自主选择合适的工具
- 支持多步推理和思考
- 就像给AI一个任务，让它自己规划怎么做

示例：

/explore/(tools=[executeSQL, _python, _search], model="v3") 解决数据分析问题 -> result
/explore/(tools=[_search, _python], model="v3") 搜索并分析信息 -> analysis
/explore/(tools=[resource_skillkit.*]) 仅暴露 ResourceSkillkit 工具 -> result

示例说明：
- 第1行：AI可以使用SQL、Python、搜索工具来解决问题
- 第2行：AI可以搜索并分析信息
- 第3行：只允许AI使用ResourceSkillkit相关的工具

9.3 /judge/ 代码块

正确写法：
用于判断和评估任务。

/judge/(参数列表) 判断内容 -> 变量名

支持的参数：
- system_prompt: 系统提示词
- model: 指定使用的模型
- tools: 可用工具列表

返回类型：Dict[str, Any] - 返回包含判断结果的字典，通常包含工具调用信息或评估结果

可以这样理解：
- 让AI对内容进行判断或评估
- 类似于"评审"或"打分"
- 返回评估结果

示例：

/judge/(system_prompt="", model="qwen-plus", tools=[]) 总结以上内容 -> summary

示例说明：
- 让AI对前面的内容进行总结
- 使用指定的模型


10. 注释和文档

10.1 行注释

正确写法：
使用 # 开头的行为注释行，会被解析器忽略。

# 这是一个注释
@web_search(query="天气") -> result

可以这样理解：
- 就像在笔记本上写批注
- 给自己或别人看的说明
- 不会被执行，只是说明

10.2 文档注释

正确写法：
使用 @DESC 标记来添加文档说明。

@DESC
记忆压缩Agent：从用户的最近N天记忆中提取关键知识点并保存
@DESC

可以这样理解：
- 给整个Agent写"产品说明书"
- 说明这个Agent是做什么的

10.3 多行字符串文档

正确写法：
使用三重引号定义多行字符串，常用于提示和规则定义。

'''
1. 不同年份的销售数据在不同表中
2. 计算类型任务可以使用 Python 代码
3. SQL 执行结果为空时需要检查字段名
''' -> hints

可以这样理解：
- 可以写多行的提示信息
- 存成一个变量，后面可以反复使用


11. 输出格式控制

11.1 JSON 格式

正确写法：

/prompt/(output="json") 生成用户信息 -> user_info

返回类型：Dict[str, Any] - 返回单个JSON对象，包含键值对数据

可以这样理解：
- 让AI生成结构化的数据
- 就像填写表格，有明确的字段名

11.2 JSONL 格式

正确写法：

/prompt/(output="jsonl") 生成多个用户记录 -> users_list

返回类型：List[Dict[str, Any]] - 返回JSON对象的列表，每个元素都是一个字典

可以这样理解：
- 生成多条记录
- 每条记录都是独立的JSON对象

11.3 列表字符串格式

正确写法：

/prompt/(output="list_str") 返回概念名称列表 -> concept_names

返回类型：List[str] - 返回字符串列表，元素类型为字符串

可以这样理解：
- 让AI返回一个清单
- 每项都是纯文本

11.4 对象类型格式

正确写法：

/prompt/(output="obj/UserProfile") 生成用户档案 -> profile

返回类型：Dict[str, Any] - 返回符合指定对象类型定义的字典结构

可以这样理解：
- 生成特定类型的数据
- 符合预定义的格式要求


12. 高级语法特性

12.1 函数参数传递

正确写法：
支持在函数调用中使用变量作为参数：

@concepts(query=$query) -> conceptDescs
@getDataSourcesFromConcepts(conceptNames=$conceptInfos) -> datasources
@getSampleData(conceptNames=$conceptInfos) -> sampledData

可以这样理解：
- 把之前的结果作为新任务的输入
- 就像流水线，一环扣一环

12.2 多行提示模板

正确写法：
支持复杂的多行提示模板，包含变量插值：

今天是【$date】
请一步步思考，使用工具及进行推理计算，得到最后的结果。

要解决的问题

$query


datasource:

$datasources


现在请开始： -> result

可以这样理解：
- 可以写一个详细的"工作指导书"
- 里面可以插入变量
- AI会根据这个模板来工作

12.3 内置函数调用

正确写法：
支持调用内置函数获取系统信息：

@_date() -> date
@_write_jsonl(file_path="data/file.jsonl", content=$data) -> outputPath

可以这样理解：
- 使用系统提供的快捷功能
- @_date()：获取日期
- @_write_jsonl()：保存数据到文件

12.4 复杂数据结构处理

正确写法：
支持处理复杂的嵌套数据结构：

# 定义复杂对象
{"user": {"name": "张三", "profile": {"age": 25, "city": "北京"}}} -> user_data

# 访问嵌套属性
$user_data.user.name -> user_name
$user_data.user.profile.city -> user_city

可以这样理解：
- 数据可以像套娃一样一层层包含
- 用点号可以逐层深入访问


13. 最佳实践

13.1 变量命名

正确写法：
- 使用有意义的变量名
- 使用下划线分隔多个单词
- 避免使用保留字

可以这样理解：
- 给箱子起个好名字，让自己一看就知道里面装的什么
- 好的命名像：用户姓名、订单金额
- 不好的命名像：a、b、temp

13.2 代码组织

正确写法：
- 适当使用注释说明复杂逻辑
- 使用 @DESC 为文件添加文档
- 将相关操作组织在一起

可以这样理解：
- 写清楚说明，方便自己和别人理解
- 把相关的步骤放在一起
- 就像整理文件，分类存放

13.3 工具调用

正确写法：
- 在 /explore/ 块中明确指定需要的工具
- 使用合适的模型版本
- 为复杂任务提供详细的提示

可以这样理解：
- 明确告诉AI可以用哪些工具
- 根据任务难度选择合适的AI模型
- 任务说明越详细，AI做得越好

13.4 错误处理

正确写法：
- 确保所有表达式都有输出变量（使用 -> 或 >>）
- 检查变量是否存在再使用
- 适当处理可能的空值情况

可以这样理解：
- 每个操作的结果都要保存
- 使用数据前先确认数据存在
- 考虑可能出现的异常情况


14. 实际应用示例

14.1 数据分析任务

完整代码示例：

@DESC
ChatBI数据探索Agent：使用SQL和Python工具进行数据分析
@DESC

@_date() -> date
@hints() -> hints
@concepts(query=$query) -> conceptDescs
@getDataSourcesFromConcepts(conceptNames=$conceptInfos) -> datasources

/explore/(tools=[executeSQL, _python, _search], model="v3")
今天是【$date】
请一步步思考，使用工具及进行推理计算，得到最后的结果。

要解决的问题

$query


datasource:

$datasources


关于任务的提示：

$taskHints


请注意!
(1)不要使用假设的数据进行计算，假设的数据对我毫无意义。
(2)sql 语句撰写后就请立即执行
(3)如果工具执行出现错误，请调整工具参数并重新进行生成和执行。

现在请开始： -> result

业务场景说明：
这是一个数据分析师Agent的工作流程：
1. 初始化：告诉AI这是一个数据分析助手
2. 准备阶段：获取日期、提示信息、相关概念和数据源
3. 执行阶段：
   - AI可以使用SQL查询数据库
   - AI可以使用Python进行计算
   - AI可以搜索额外信息
   - 根据查询结果进行分析和推理
4. 注意事项：
   - 必须使用真实数据，不能假设
   - SQL写完就执行
   - 出错要调整参数重试

适用场景：
- 销售数据分析
- 用户行为分析
- 财务报表分析
- 业务指标监控

14.2 记忆压缩任务

完整代码示例：

@DESC
记忆压缩Agent：从用户的最近N天记忆中提取关键知识点并保存
@DESC

#读取用户最近N天的记忆数据
@readRecentMemoryData(userId="chatbi_user", recentDays=$recent_days) -> memoryData

#从记忆数据中提取10条最重要的知识点
/prompt/(model="v3", output="jsonl")根据以下用户的记忆数据，提取出最重要的10条知识点。

用户记忆数据：

$memoryData


请从这些记忆中提取最重要的10条知识点，每条知识点应该：
1. 是具体的、有价值的信息
2. 对用户未来的决策或行为有帮助
3. 具有一定的普遍性或重要性

输出格式为JSON数组，每个元素包含以下字段：
- content: 知识点内容（字符串）
- score: 重要性评分（1-100整数）

请开始：-> knowledgePoints

#将压缩后的知识写入knowledge文件
@_write_jsonl(file_path="data/memory/user_chatbi_user/knowledge.jsonl", content=$knowledgePoints) -> outputPath

业务场景说明：
这是一个智能笔记整理助手：
1. 读取记忆：获取用户最近几天的对话或操作记录
2. 智能提取：AI从中筛选出最重要的10条知识点
3. 评分保存：给每条知识打分（1-100分），然后保存到文件

适用场景：
- 会议纪要整理
- 学习笔记提炼
- 客户对话总结
- 项目经验沉淀

14.3 简单搜索任务

完整代码示例：

/explore/(tools=[_search, _python], model="v3")
今天是 2025.7.1，请一步步思考，使用工具及进行推理计算，得到最后的结果
任务是：$query
现在请开始： -> result

业务场景说明：
这是一个简单的信息搜索和分析助手：
1. 工具能力：AI可以搜索网络、使用Python计算
2. 任务执行：根据用户的问题去搜索、分析、计算
3. 返回结果：给出最终的答案

适用场景：
- 快速问答
- 信息查询
- 简单计算
- 数据核实

14.4 概念提取和数据获取

完整代码示例：

@getAllConcepts() -> allConcepts

/prompt/(model="v3", output="list_str")根据要解决问题的描述以及concepts描述，返回所【有可能】要用到的 concepts 信息

要解决的问题：
$query

concepts描述：
$allConcepts

关于任务的提示：
$taskHints

要解决的问题：
$query

只输出 concept 名称，请开始 -> conceptInfos

@getSampleData(conceptNames=$conceptInfos) -> sampledData
@getDataSourceSchemas(conceptNames=$conceptInfos) -> schemas

业务场景说明：
这是一个智能数据检索助手：
1. 获取所有概念：先了解系统里有哪些数据概念（如表、字段等）
2. 概念匹配：根据用户问题，找出可能需要用到的概念
3. 数据获取：根据选定的概念，获取示例数据和数据结构

适用场景：
- 数据库查询辅助
- BI报表生成
- 数据探索分析
- 自助数据分析

14.5 Agent质量分析专家（真实业务案例）

业务场景说明：
这是一个AI Agent质量分析专家，用于分析智能体运行的日志和性能指标，找出问题并给出优化建议。

核心功能：
1. 数据验证：检查输入参数是否完整
2. 数据查询：调用可观测数据工具获取日志和指标
3. 分级分析：支持Agent级、Session级、Run级三种分析粒度
4. 智能诊断：AI自动识别性能、质量、效率、稳定性问题
5. 优化建议：给出具体的改进方案和预期收益

适用场景：
- Agent性能监控和优化
- 智能体故障排查
- 用户体验质量分析
- A/B测试效果评估

完整代码示例：

# 第一步：参数验证
/if/ $id == "" or $analysis_level not in ["agent", "session", "run"] or $start_time == "" or $end_time == "":
    '{"error": {"code": "INVALID_DATA_SOURCE"}}' -> rt
else:
    @查询可观测数据(id=$id, analysis_level=$analysis_level, start_time=$start_time, end_time=$end_time) -> o11y_data

    # 第二步：检查查询结果
    /if/ "answer" not in $o11y_data or "data" not in $o11y_data["answer"]:
        '{"error": {"code": "FAILED_O11Y_DATA"}}' -> rt
    else:
        $o11y_data.answer.data -> data_source

        # 第三步：根据分析级别准备说明
        /if/ $analysis_level == "agent":
            'Agent级分析：从宏观角度分析整体表现' -> input_param_description
        elif $analysis_level == "session":
            'Session级分析：分析单次会话的完整流程' -> input_param_description
        elif $analysis_level == "run":
            'Run级分析：深度分析单次执行' -> input_param_description
        /end/

        # 第四步：构建系统提示词并执行分析
        f'你是AI Agent质量分析专家，分析：{$data_source}，级别：{$analysis_level}' -> sys_prompt
        /prompt/(system_prompt=$sys_prompt, output="json") 开始分析 -> rt
    /end/
/end/


通俗解释：
- 第一步：就像买票前检查身份证
- 第二步：就像收快递先检查是否损坏
- 第三步：就像选择体检类型（全身/局部/细胞）
- 第四步：就像给医生写检查要求
- 最终：得到包含评分、问题、建议的诊断报告


14.6 业务知识网络问答助手（真实业务案例）

业务场景说明：
这是一个基于知识图谱的智能问答系统，可以从企业的业务知识网络中查询和推理出答案。

核心功能：
1. 实体识别：从问题中提取关键实体（人名、物名等）
2. 消歧处理：区分同名实体，确定具体指代
3. 关系查询：沿着知识图谱的关系链查找相关信息
4. 智能推理：基于多跳关系找到答案
5. 自然回答：用易懂的语言返回答案

适用场景：
- 企业组织架构查询（"张三是哪个部门的？"）
- 客户关系管理（"A公司的采购经理是谁？"）
- 产品知识问答（"这款产品有哪些配件？"）


完整代码示例：

# 第一步：获取知识图谱结构
@关键词上下文召回(query=$query) -> schema

# 第二步：构建系统提示词
f'''
你是业务知识网络问答专家。

【知识图谱结构】
{$schema}

【工具1：关键词上下文召回】
用于识别和消歧实体。比如找到正确的"张三"

【工具2：单对象查询】
查询单个实体的详细信息。比如查询"张三"的邮箱

【工具3：路径查询】
通过关系链查询。比如张三 → 部门 → 专业

使用提示：先用工具1识别实体，再用工具2或工具3查询信息
''' -> system_prompt

# 第三步：让AI自主选择工具回答
/explore/(history=true, system_prompt=$system_prompt, tools=["关键词上下文召回", "根据单个对象类查询对象实例", "基于路径查询对象子图"])
【问题】$query

请选择合适的工具调用，每次调用前说明原因，最后总结答案。
-> answer


通俗解释：

第一步：获取知识图谱结构
就像去图书馆前先查看索引

第二步：构建工作指南
告诉AI有三个工具可用：
  - 工具1：识别实体（找对"张三"）
  - 工具2：查详细信息（查邮箱）
  - 工具3：查关系链（查"张三"的"部门"的"专业"）

第三步：AI自主工作
AI会自己判断：
  1. 分析问题："张三的部门有哪些专业？"
  2. 选择工具：先用工具1找到"张三"，再用工具3查询关系
  3. 执行查询并返回答案

为什么用/explore/：
- 让AI自己决定用什么工具、怎么查、怎么组合
- 适合需要多步推理的复杂查询


学习这两个真实案例的建议

关键要点：
✅ 示例14.5展示了 /if/ 条件判断和 /prompt/ 结构化输出
✅ 示例14.6展示了 /explore/ 让AI自主选择工具
✅ 都有详细的系统提示词指导AI工作
✅ 都包含了错误处理逻辑

学习建议：
1. 先理解业务：搞清楚要解决什么问题
2. 画流程图：把Agent的工作流程画出来
3. 模仿写法：参考示例结构，写自己的Agent


快速参考卡片

核心符号速查

符号   名称       作用                       记忆方法
→     赋值箭头   把结果存入变量             箭头指向箱子
>>    追加箭头   往变量里添加内容           双箭头表示"再加一点"
$     变量符号   使用变量的内容             美元符号表示"值钱的东西"
#     注释符号   添加说明文字               就像社交媒体的标签
@     函数符号   调用工具或函数             像邮箱的@，表示"呼叫"

三大控制块

块名   开始标记   结束标记   用途         生活比喻
循环块 /for/     /end/      重复处理     批量处理清单
判断块 /if/      /end/      条件分支     根据情况选择
函数块 /def/     /end/      封装代码     录制快捷操作

三大智能块

块名      用途                 何时使用
/prompt/  直接对话AI           需要AI生成内容、分类、总结
/explore/ AI自主探索           复杂任务，让AI自己选择工具
/judge/   AI评估判断           需要AI对内容进行评审或打分


学习建议

对于完全没有编程基础的业务人员：

第1天：理解核心概念
- 重点阅读：第1章（变量）、第2章（控制流）
- 练习：尝试写几个简单的变量赋值

第2天：学习函数调用
- 重点阅读：第3章（函数调用）、第6章（特殊指令）
- 练习：尝试调用几个内置函数

第3天：掌握智能块
- 重点阅读：第9章（特殊代码块）
- 练习：写一个简单的 /prompt/ 任务

第4天：实战应用
- 重点阅读：第14章（实际应用示例）
- 练习：复制一个示例，修改成自己的需求

第5天：综合运用
- 尝试完成一个完整的业务场景
- 遇到问题查阅相关章节

学习技巧：

1. 从模仿开始：先复制示例代码，运行成功后再修改
2. 分步验证：每写一步就测试，不要一次写太多
3. 善用注释：给自己的代码加注释，方便理解和修改
4. 保存模版：把常用的代码保存起来，下次直接用


常见问题

Q: 我完全没有编程基础，能学会吗？
A: 可以！Dolphin 语言就是为非技术人员设计的。从简单的示例开始，逐步练习，几天就能掌握基本用法。

Q: 写错了会怎么样？
A: 系统会提示错误信息。仔细检查：变量名是否一致、是否忘记写 /end/、箭头方向是否正确。

Q: 必须记住所有语法吗？
A: 不需要。记住核心概念（变量、箭头、控制块）就行，详细语法可以随时查阅本文档。

Q: 如何知道该用哪个智能块？
A: 简单记：
- 要生成内容用 /prompt/
- 要解决问题用 /explore/
- 要评估判断用 /judge/

Q: 可以把代码给别人用吗？
A: 可以！Dolphin 代码可以直接复制分享。建议加注释说明用途。


结语

Dolphin 语言的设计理念是：让业务人员能用自然语言的方式指挥 AI 完成复杂任务。

- 不需要懂编程
- 不需要关注技术细节
- 只需要清晰的业务逻辑

记住三个核心：
1. 存结果：用 → 把结果存起来
2. 用结果：用 $变量名 使用之前的结果
3. 写清楚：用注释和文档说明你的意图

祝你成为 Dolphin 语言高手！

本文档基于官方语法规范编写，保留了所有技术细节，同时为非编程人员提供了易懂的解释。
