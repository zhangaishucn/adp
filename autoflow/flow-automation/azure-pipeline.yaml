trigger:
  branches:
    include:
      - MISSION
      - feature/*
      - hotfix/*

parameters:
  - name: TRIVY_EXIT_CODE
    displayName: trivy exit code
    type: number
    default: 1
    values:
      - 0
      - 1
  - name: SKIP_SONARQUBE
    displayName: skip sonarqube
    type: number
    default: 0
    values:
      - 0
      - 1

variables:
  - group: global-dip
  - name: imageRegistry
    value: acr.aishu.cn
  - name: imageRepository
    value: dip/flow-automation
  - name: buildImage
    value: "acr.aishu.cn/public/golang:1.23.7-ubuntu22.04.20241202-2-20250319.1"
  - name: baseImage
    value: "acr.aishu.cn/public/ubuntu:22.04.20241202"
  - name: lintReportName
    value: lint_report.xml
  - name: utReportName
    value: ut_report.xml
  - name: coverageReportName
    value: coverage_report.xml
  - name: chartRepo
    value: "https://acr.aishu.cn/api/chartrepo/dip/charts"
  - name: chartName
    value: "flow-automation"
  - name: yqImage
    value: "acr.aishu.cn/public/mikefarah/yq:4.26.1"
  - name: poolNameAMD64
    value: "anydata-centos7.7-x86_64"
  - name: poolNameARM64
    value: "anydata-centos7-arm"
  - name: artifactName
    value: Distribute

resources:
  containers:
    - container: builder
      endpoint: acr.aishu.cn
      image: public/golang:1.23.7-ubuntu22.04.20241202-2-20250319.1
    - container: dotnet
      endpoint: acr.aishu.cn
      image: wing-biz/euop/dotnet-runtime:3.1
  repositories:
    - repository: templatesAlias
      type: git
      name: ONE-Architecture\Yaml-Templates
      ref: "refs/heads/main"
    - repository: arPipelineTemplates
      type: git
      name: AnyRobot\PipelineTemplates
      ref: "refs/heads/develop"

stages:
  - stage: InitVariable
    displayName: 初始化
    jobs:
      - job: InitVariable
        pool: $(poolNameAMD64)
        workspace:
          clean: all
        steps:
          - checkout: self
          - bash: |
              set -ex
              VERSION=`cat VERSION`

              gitCommit="$(git rev-parse --short HEAD 2>/dev/null)"
              
              # 处理分支名称，将/替换为-
              # 从refs/heads/feature/12345中提取feature/12345，然后将/替换为-
              BRANCH_NAME=$(echo $(Build.SourceBranch) | sed 's#refs/heads/##' | tr '/' '-')
              CURRENT_TAG="${VERSION}-${BRANCH_NAME}.${gitCommit}.$(Build.BuildId)"
              LATEST_TAG="${VERSION}-${BRANCH_NAME}.${gitCommit}"

              set +x
              echo "##vso[task.setvariable variable=VERSION;isoutput=true]$VERSION"
              set +x
              echo "##vso[task.setvariable variable=CURRENT_TAG;isoutput=true]$CURRENT_TAG"
              set +x
              echo "##vso[task.setvariable variable=LATEST_TAG;isoutput=true]$LATEST_TAG"
              set +x
              echo "##vso[task.setvariable variable=COMMIT_ID;isoutput=true]$gitCommit"
              
            name: MyOutputVar
  
  - stage: CodeCheck
    dependsOn:
      - InitVariable
    displayName: 代码检查
    jobs:
      - job: PullDependencyRepo
        displayName: 拉取依赖仓库代码
        workspace:
          clean: all
        pool:
          name: $(poolNameAMD64)
        container: builder
        steps:
          - checkout: none
          - script: |
              set -ex
              git clone --depth=3 -b $(apiBranchName) ssh://devops.aishu.cn:22/AISHUDevOps/AnyShareFamily/_git/API
              pwd && ls
            displayName: Pull Repo
            condition: succeeded()
          - task: CopyFiles@2
            inputs:
              contents: |
                API/**
              targetFolder: $(Build.SourcesDirectory)
          - task: PublishBuildArtifacts@1
            displayName: Upload Code To PrepareArtifacts
            inputs:
              pathToPublish: $(Build.SourcesDirectory)
              artifactName: DependencyRepo
          - script: |
              rm -rf ./**
              ls -l
            condition: always()
            displayName: Remove Source
      - template: devops/azure_templates/ut_test.yml
        parameters:
          name: CodeCheck
          displayName: 代码检查
          pool: $(poolNameAMD64)
          containerName: builder
          artifactName: $(artifactName)
          downloadPerparePath: DependencyRepo
          dependOn: PullDependencyRepo
      
      - job: SonarQube
        displayName: SonarQube扫描
        workspace:
          clean: all
        pool:
          name: $(poolNameAMD64)
        dependsOn: CodeCheck
        steps:
          - checkout: self
          - template: sonarqube-setps.yml@arPipelineTemplates
            parameters:
              SKIP_SONARQUBE: ${{ parameters.SKIP_SONARQUBE }}

      - job: UploadReport
        displayName: 上传检查报告
        container: dotnet
        dependsOn: CodeCheck
        pool:
          name: anydata-centos7.7-x86_64
          demands:
            - Agent.OSArchitecture -equals X64
            - Agent.OS -equals Linux
            - docker
        steps:
          - checkout: none
          - task: DownloadBuildArtifacts@0
            inputs:
              buildType: 'current'
              downloadType: 'single'
              artifactName: $(artifactName)
              downloadPath:  $(Build.SourcesDirectory)
            displayName: Download binaryFileX86Artifact

          - script: |
              echo "Checking lint_report.xml..."
              ls -l $(Build.SourcesDirectory)/$(artifactName)/report
              cat $(Build.SourcesDirectory)/$(artifactName)/report/lint_report.xml
            displayName: 'Validate lint_report.xml'

          - task: PublishTestResults@2
            displayName: Publish Lint Report
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '**/lint_report.xml'
              searchFolder: '$(Build.SourcesDirectory)/$(artifactName)/report'
              testRunTitle: 'Lint'
              failTaskOnFailedTests: false
          - task: BuildQualityChecks@8
            displayName: Quality Gate Lint
            inputs:
              checkWarnings: true
              warningFailOption: 'fixed'
              warningThreshold: '10'
              showStatistics: false
              evaluateTaskWarnings: false
              evaluateFileWarnings: true
              warningFilesFolder: '$(Build.SourcesDirectory)/$(artifactName)'
              warningFiles: '**/$(LintReportName)'
              warningFileFilters: '/^.+<\/failure>.*?$/'
              warningFilesArtifact: '$(artifactName)'

          - task: PublishTestResults@2        # 发布单元测试报告
            displayName: Publish UT Report
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: /$(Build.SourcesDirectory)/$(artifactName)/report/$(UTReportName)
              testRunTitle: 'UT'
              failTaskOnFailedTests: true
          - task: BuildQualityChecks@8        # 设置UT质量卡点
            displayName: Quality Gate UT
            inputs:
              checkWarnings: true
              warningFailOption: 'fixed'
              warningThreshold: '0'
              showStatistics: false
              evaluateTaskWarnings: false
              evaluateFileWarnings: true
              warningFilesFolder: '$(Build.SourcesDirectory)/$(artifactName)'
              warningFiles: '**/$(UTReportName)'
              warningFileFilters: '/^.+<\/failure>.*?$/'
              warningFilesArtifact: '$(artifactName)'

          - task: PublishCodeCoverageResults@1 # 发布代码覆盖率报告
            displayName: Publish Coverage Report
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: $(Build.SourcesDirectory)/$(artifactName)/report/$(CoverageReportName)
          - task: BuildQualityChecks@8         # 代码覆盖率质量卡点
            displayName: Quality Gate Coverage
            inputs:
              coverageType: 'lines'
              coverageFailOption: 'fixed'
              checkCoverage: true
              coverageThreshold: '60.0'

          - script: |
              cd $(Build.BinariesDirectory) && rm -rf ./**
              cd $(Build.SourcesDirectory) && rm -rf ./**
            condition: always()
            displayName: Remove Resource
  - stage: BuildImage
    displayName: 镜像构建
    dependsOn:
      - InitVariable
      - CodeCheck
    variables:
      VERSION: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.VERSION']]
      CURRENT_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.CURRENT_TAG']]
      LATEST_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.LATEST_TAG']]
    jobs:
      - template: devops/azure_templates/azure-template.yaml
        parameters:
          name: DockerJobX86_Build
          pool: $(poolNameAMD64)
          containerName: builder
          registry: $(imageRegistry)
          imageRepository: $(imageRepository)
          artifactName: $(artifactName)
          dependencyArtifact: DependencyRepo
          arch: 'amd64'
          buildImageJobName: 'DockerJobX86_ImageBuild'

      - template: devops/azure_templates/azure-template.yaml
        parameters:
          name: DockerJobARM_Build
          pool: $(poolNameARM64)
          containerName: builder
          registry: $(imageRegistry)
          imageRepository: $(imageRepository)
          artifactName: $(artifactName)
          dependencyArtifact: DependencyRepo
          arch: 'arm64'
          buildImageJobName: 'DockerJobARM_ImageBuild'

      - template: scan-and-push-image.yml@templatesAlias # 保持一致
        parameters:
          arch: amd64 # 可选值 amd64,arm64
          pool: $(poolNameAMD64) # 代理池
          dependsOnName: DockerJobX86_ImageBuild # 构建docker镜像步骤所在job的名称，即getAgentName task所在job的名称，此示例中为BuildImage
          imageName: $[ dependencies.DockerJobX86_ImageBuild.outputs['getAgentName.LATEST_IMAGE'] ] # 本地构建完镜像之后的全名
          registry: ACRDockerRegistry # 连接到harbor的服务连接名
          scanTimeout: 11m # trivy扫描的超时设置，默认值为5分钟(5m)
          templateNo: 1 # 若同一个yaml中多次引用此template，此字段需要以1,2,3...的形式区分开来。为了保证template yml中job id的唯一性
          hasSecondImage: 1 # 1代表同一个镜像存在第二个不同tag，此参数为可选参数，不填写时默认值为0
          secondImageName: $[ dependencies.DockerJobX86_ImageBuild.outputs['getAgentName.CURRENT_IMAGE'] ] # 此参数为可选参数，hasSecondImage为1时需要填写此字段，为镜像包含第二个tag的全名
          exitCode: ${{ parameters.TRIVY_EXIT_CODE }}

      - template: scan-and-push-image.yml@templatesAlias # 保持一致
        parameters:
          arch: arm64 # 可选值 amd64,arm64
          pool: $(poolNameARM64) # 代理池
          dependsOnName: DockerJobARM_ImageBuild # 构建docker镜像步骤所在job的名称，即getAgentName task所在job的名称，此示例中为BuildImage
          imageName: $[ dependencies.DockerJobARM_ImageBuild.outputs['getAgentName.LATEST_IMAGE'] ] # 本地构建完镜像之后的全名
          registry: ACRDockerRegistry # 连接到harbor的服务连接名
          scanTimeout: 11m # trivy扫描的超时设置，默认值为5分钟(5m)
          templateNo: 2 # 若同一个yaml中多次引用此template，此字段需要以1,2,3...的形式区分开来。为了保证template yml中job id的唯一性
          hasSecondImage: 1 # 1代表同一个镜像存在第二个不同tag，此参数为可选参数，不填写时默认值为0
          secondImageName: $[ dependencies.DockerJobARM_ImageBuild.outputs['getAgentName.CURRENT_IMAGE'] ] # 此参数为可选参数，hasSecondImage为1时需要填写此字段，为镜像包含第二个tag的全名
          exitCode: ${{ parameters.TRIVY_EXIT_CODE }}

  - stage: MakeManifest
    displayName: 制作多架构镜像
    dependsOn: 
      - InitVariable
      - BuildImage
    condition: succeeded()
    variables:
      CURRENT_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.CURRENT_TAG']]
      LATEST_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.LATEST_TAG']]
      LATEST_IMAGE_AMD64: $[ stageDependencies.BuildImage.DockerJobX86_ImageBuild.outputs['getAgentName.LATEST_IMAGE'] ]
      LATEST_IMAGE_ARM64: $[ stageDependencies.BuildImage.DockerJobARM_ImageBuild.outputs['getAgentName.LATEST_IMAGE'] ]
      CURRENT_IMAGE_AMD64: $[ stageDependencies.BuildImage.DockerJobX86_ImageBuild.outputs['getAgentName.CURRENT_IMAGE'] ]
      CURRENT_IMAGE_ARM64: $[ stageDependencies.BuildImage.DockerJobARM_ImageBuild.outputs['getAgentName.CURRENT_IMAGE'] ]
    jobs:
      - job: MakeManifest
        displayName: 制作多架构镜像
        workspace:
          clean: all
        pool: $(poolNameAMD64)
        steps:
          - checkout: none
          - task: Docker@2
            inputs:
              command: login
              containerRegistry: ACRDockerRegistry
          - script: |
              set -e
              CURRENT_IMAGE="$(imageRegistry)/$(imageRepository):$(CURRENT_TAG)"
              LATEST_IMAGE="$(imageRegistry)/$(imageRepository):$(LATEST_TAG)"

              docker manifest create --amend $LATEST_IMAGE $(LATEST_IMAGE_AMD64) $(LATEST_IMAGE_ARM64)
              docker manifest push --purge $LATEST_IMAGE
              docker manifest create --amend $CURRENT_IMAGE $(CURRENT_IMAGE_AMD64) $(CURRENT_IMAGE_ARM64)
              docker manifest push --purge $CURRENT_IMAGE

  - stage: ChartPush
    displayName: Chart构建
    dependsOn:
      - InitVariable
    variables:
        CURRENT_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.CURRENT_TAG']]
        LATEST_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.LATEST_TAG']]
        COMMIT_ID: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.COMMIT_ID']]

    jobs:
      - job: ChartPush
        displayName: Chart构建
        workspace:
          clean: all
        pool:
          name: anydata-centos7.7-x86_64
          demands:
            - Agent.OSArchitecture -equals X64
            - Agent.OS -equals Linux
            - docker
        steps:
          - checkout: self
          - task: Bash@3
            displayName: Chart构建
            inputs:
              targetType: inline
              script: |
                #!/usr/bin/env
                set -ex

                chartCurrentTag=$(echo '$(CURRENT_TAG)' | sed 's/$(COMMIT_ID)/git+$(COMMIT_ID)/g')
                chartLatestTag=$(echo '$(LATEST_TAG)' | sed 's/$(COMMIT_ID)/git+$(COMMIT_ID)/g')

                chmod 777 -R $(pwd)/helm
                docker run --rm \
                      -v $(pwd)/helm:/chart \
                      --entrypoint='' \
                      $(yqImage) sh -c "
                  set -ex

                  yq eval -i '.image.registry = \"$(imageRegistry)\"' /chart/$(chartName)/values.yaml
                  yq eval -i '.image.repository = \"$(imageRepository)\"' /chart/$(chartName)/values.yaml
                  yq eval -i '.image.tag = \"$(LATEST_TAG)\"' /chart/$(chartName)/values.yaml

                  yq eval -i '.name = \"$(chartName)\"' /chart/$(chartName)/Chart.yaml
                  yq eval -i '.appVersion = \"$(CURRENT_TAG)\"' /chart/$(chartName)/Chart.yaml
                  sed -i 's/\"version\": .*/\"version\": \"$chartCurrentTag\",/g' /chart/$(chartName)/_componentMeta.json
                  yq eval -i '.version = \"$chartCurrentTag\"' /chart/$(chartName)/Chart.yaml
                  cd /chart && tar -czf $(chartName)-$chartCurrentTag.tar.gz $(chartName)
                  yq eval -i '.version = \"$chartLatestTag\"' /chart/$(chartName)/Chart.yaml
                  cd /chart && tar -czf $(chartName)-$chartLatestTag.tar.gz $(chartName)
                  "

                cd helm
                curlOptions="-s -u $(registry.username):$(registry.password) -H \"Content-Type:multipart/form-data\""
                curl ${curlOptions} -F "chart=@$(chartName)-$chartCurrentTag.tar.gz;type=application/x-compressed-tar" -X POST "$(chartRepo)"
                curl ${curlOptions} -F "chart=@$(chartName)-$chartLatestTag.tar.gz;type=application/x-compressed-tar" -X POST "$(chartRepo)"

          - task: Post-Bash@3
            inputs:
              targetType: inline
              script: |
                rm -rf $(Build.SourcesDirectory)/**
                ls -lah $(Agent.BuildDirectory)
