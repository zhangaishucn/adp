trigger:
  branches:
    include:
      - MISSION
      - feature/*
      - hotfix/*

parameters:
  - name: mqSDKBranch
    displayName: 'proton-mq-python 分支'
    type: string
    default: '1.7.4'

  - name: TIMEOUT_IN_MINUTES
    displayName: '构建超时时间'
    type: number
    default: 90

  - name: TRIVY_EXIT_CODE
    displayName: trivy exit code
    type: number
    default: 1
    values:
      - 0
      - 1

  - name: SKIP_SONARQUBE
    displayName: skip sonarqube
    type: number
    default: 0
    values:
      - 0
      - 1

variables:
  # 针对服务的全局配置
  - group: global-dip
  - name: imageRegistry
    value: acr.aishu.cn
  - name: imageCRRepository
    value: dip/coderunner
  - name: imageDFTRepository
    value: dip/dataflowtools
  - name: UTReportName
    value: ut_report.xml
  - name: CoverageReportName
    value: coverage_report.xml
  - name: LintReportName
    value: lint_report.xml
  - name: chartRepo
    value: "https://acr.aishu.cn/api/chartrepo/dip/charts"
  - name: chartName
    value: coderunner
  - name: yqImage
    value: "acr.aishu.cn/public/mikefarah/yq:4.26.1"
  - name: poolNameAMD64
    value: "anydata-centos7.7-x86_64"
  - name: poolNameARM64
    value: "anydata-centos7-arm"
  - name: artifactNameCodeRunner
    value: DistributeCodeRunner
  - name: artifactNameDataFlowTools
    value: DistributeDataFlowTools

resources:
  containers:
    - container: builder
      endpoint: acr.aishu.cn
      image: acr.aishu.cn/dip/python:3.9.13-ubuntu22.04.20251014-1
    - container: dotnet
      endpoint: acr.aishu.cn
      image: as/dotnet-runtime:universal
      options: --privileged
  repositories:
    - repository: templatesAlias
      type: git
      name: ONE-Architecture\Yaml-Templates
      ref: "refs/heads/main"

stages:
  - stage: InitVariable
    displayName: 初始化
    jobs:
      - job: InitVariable
        pool: $(poolNameAMD64)
        workspace:
          clean: all
        steps:
          - checkout: self
          - bash: |
              set -ex
              VERSION=`cat VERSION`

              gitCommit="$(git rev-parse --short HEAD 2>/dev/null)"
              
              # 处理分支名称，将/替换为-
              # 从refs/heads/feature/12345中提取feature/12345，然后将/替换为-
              BRANCH_NAME=$(echo $(Build.SourceBranch) | sed 's#refs/heads/##' | tr '/' '-')
              CURRENT_TAG="${VERSION}-${BRANCH_NAME}.${gitCommit}.$(Build.BuildId)"
              LATEST_TAG="${VERSION}-${BRANCH_NAME}.${gitCommit}"

              set +x
              echo "##vso[task.setvariable variable=VERSION;isoutput=true]$VERSION"
              set +x
              echo "##vso[task.setvariable variable=CURRENT_TAG;isoutput=true]$CURRENT_TAG"
              set +x
              echo "##vso[task.setvariable variable=LATEST_TAG;isoutput=true]$LATEST_TAG"
              set +x
              echo "##vso[task.setvariable variable=COMMIT_ID;isoutput=true]$gitCommit"
              
            name: MyOutputVar
  - stage: CodeCheck
    dependsOn:
      - InitVariable
    displayName: 代码检查
    jobs:
      - job: PullDependencyRepo
        displayName: 拉取依赖仓库代码
        workspace:
          clean: all
        pool:
          name: $(poolNameAMD64)
        container: builder
        steps:
          - checkout: none
          - checkout: git://ONE-Architecture/proton-mq-python@${{ parameters.mqSDKBranch }}
            fetchDepth: 1
          
          - task: PublishBuildArtifacts@1
            displayName: Upload Code To PrepareArtifacts
            inputs:
              PathtoPublish: "$(Build.SourcesDirectory)"
              ArtifactName: DependencyRepo
              publishLocation: "Container"
          - script: |
              rm -rf ./**
              ls -l
            condition: always()
            displayName: Remove Source
  
  - stage: BuildImage
    displayName: 镜像构建
    dependsOn:
      - InitVariable
      - CodeCheck
    variables:
      VERSION: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.VERSION']]
      CURRENT_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.CURRENT_TAG']]
      LATEST_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.LATEST_TAG']]
    jobs:
      - template: devops/azure_templates/coderunner.yaml
        parameters:
          name: DockerJobX86_CodeRunner_Build
          pool: $(poolNameAMD64)
          containerName: builder
          registry: $(image.registry)
          imageRepository: $(image.imageCRRepository)
          artifactName: $(artifactNameCodeRunner)
          dependencyArtifact: DependencyRepo
          arch: 'amd64'
          buildImageJobName: 'DockerJobX86_CodeRunner_ImageBuild'

      - template: devops/azure_templates/coderunner.yaml
        parameters:
          name: DockerJobARM_CodeRunner_Build
          pool: $(poolNameARM64)
          containerName: builder
          registry: $(image.registry)
          imageRepository: $(image.imageCRRepository)
          artifactName: $(artifactNameCodeRunner)
          dependencyArtifact: DependencyRepo
          arch: 'arm64'
          buildImageJobName: 'DockerJobARM_CodeRunner_ImageBuild'

      - template: devops/azure_templates/dataflowtools.yaml
        parameters:
          name: DockerJobX86_DataFlowTools_Build
          pool: $(poolNameAMD64)
          containerName: builder
          registry: $(image.registry)
          imageRepository: $(image.imageDFTRepository)
          artifactName: $(artifactNameDataFlowTools)
          dependencyArtifact: DependencyRepo
          arch: 'amd64'
          buildImageJobName: 'DockerJobX86_DataFlowTools_ImageBuild'
          timeoutInMinutes: ${{ parameters.TIMEOUT_IN_MINUTES }}

      - template: devops/azure_templates/dataflowtools.yaml
        parameters:
          name: DockerJobARM_DataFlowTools_Build
          pool: $(poolNameARM64)
          containerName: builder
          registry: $(image.registry)
          imageRepository: $(image.imageDFTRepository)
          artifactName: $(artifactNameDataFlowTools)
          dependencyArtifact: DependencyRepo
          arch: 'arm64'
          buildImageJobName: 'DockerJobARM_DataFlowTools_ImageBuild'
          timeoutInMinutes: ${{ parameters.TIMEOUT_IN_MINUTES }}

      - template: scan-and-push-image.yml@templatesAlias # 保持一致
        parameters:
          arch: amd64 # 可选值 amd64,arm64
          pool: $(poolNameAMD64) # 代理池
          dependsOnName: DockerJobX86_CodeRunner_ImageBuild # 构建docker镜像步骤所在job的名称，即getAgentName task所在job的名称，此示例中为BuildImage
          imageName: $[ dependencies.DockerJobX86_CodeRunner_ImageBuild.outputs['getAgentName.LATEST_IMAGE'] ] # 本地构建完镜像之后的全名
          registry: ACRDockerRegistry # 连接到harbor的服务连接名
          scanTimeout: 11m # trivy扫描的超时设置，默认值为5分钟(5m)
          templateNo: 1 # 若同一个yaml中多次引用此template，此字段需要以1,2,3...的形式区分开来。为了保证template yml中job id的唯一性
          hasSecondImage: 1 # 1代表同一个镜像存在第二个不同tag，此参数为可选参数，不填写时默认值为0
          secondImageName: $[ dependencies.DockerJobX86_CodeRunner_ImageBuild.outputs['getAgentName.CURRENT_IMAGE'] ] # 此参数为可选参数，hasSecondImage为1时需要填写此字段，为镜像包含第二个tag的全名
          exitCode: ${{ parameters.TRIVY_EXIT_CODE }}

      - template: scan-and-push-image.yml@templatesAlias # 保持一致
        parameters:
          arch: arm64 # 可选值 amd64,arm64
          pool: $(poolNameARM64) # 代理池
          dependsOnName: DockerJobARM_CodeRunner_ImageBuild # 构建docker镜像步骤所在job的名称，即getAgentName task所在job的名称，此示例中为BuildImage
          imageName: $[ dependencies.DockerJobARM_CodeRunner_ImageBuild.outputs['getAgentName.LATEST_IMAGE'] ] # 本地构建完镜像之后的全名
          registry: ACRDockerRegistry # 连接到harbor的服务连接名
          scanTimeout: 11m # trivy扫描的超时设置，默认值为5分钟(5m)
          templateNo: 2 # 若同一个yaml中多次引用此template，此字段需要以1,2,3...的形式区分开来。为了保证template yml中job id的唯一性
          hasSecondImage: 1 # 1代表同一个镜像存在第二个不同tag，此参数为可选参数，不填写时默认值为0
          secondImageName: $[ dependencies.DockerJobARM_CodeRunner_ImageBuild.outputs['getAgentName.CURRENT_IMAGE'] ] # 此参数为可选参数，hasSecondImage为1时需要填写此字段，为镜像包含第二个tag的全名
          exitCode: ${{ parameters.TRIVY_EXIT_CODE }}
      
      - template: scan-and-push-image.yml@templatesAlias # 保持一致
        parameters:
          arch: amd64 # 可选值 amd64,arm64
          pool: $(poolNameAMD64) # 代理池
          dependsOnName: DockerJobX86_DataFlowTools_ImageBuild # 构建docker镜像步骤所在job的名称，即getAgentName task所在job的名称，此示例中为BuildImage
          imageName: $[ dependencies.DockerJobX86_DataFlowTools_ImageBuild.outputs['getAgentName.LATEST_IMAGE'] ] # 本地构建完镜像之后的全名
          registry: ACRDockerRegistry # 连接到harbor的服务连接名
          scanTimeout: 11m # trivy扫描的超时设置，默认值为5分钟(5m)
          templateNo: 3 # 若同一个yaml中多次引用此template，此字段需要以1,2,3...的形式区分开来。为了保证template yml中job id的唯一性
          hasSecondImage: 1 # 1代表同一个镜像存在第二个不同tag，此参数为可选参数，不填写时默认值为0
          secondImageName: $[ dependencies.DockerJobX86_DataFlowTools_ImageBuild.outputs['getAgentName.CURRENT_IMAGE'] ] # 此参数为可选参数，hasSecondImage为1时需要填写此字段，为镜像包含第二个tag的全名
          exitCode: ${{ parameters.TRIVY_EXIT_CODE }}

      - template: scan-and-push-image.yml@templatesAlias # 保持一致
        parameters:
          arch: arm64 # 可选值 amd64,arm64
          pool: $(poolNameARM64) # 代理池
          dependsOnName: DockerJobARM_DataFlowTools_ImageBuild # 构建docker镜像步骤所在job的名称，即getAgentName task所在job的名称，此示例中为BuildImage
          imageName: $[ dependencies.DockerJobARM_DataFlowTools_ImageBuild.outputs['getAgentName.LATEST_IMAGE'] ] # 本地构建完镜像之后的全名
          registry: ACRDockerRegistry # 连接到harbor的服务连接名
          scanTimeout: 11m # trivy扫描的超时设置，默认值为5分钟(5m)
          templateNo: 4 # 若同一个yaml中多次引用此template，此字段需要以1,2,3...的形式区分开来。为了保证template yml中job id的唯一性
          hasSecondImage: 1 # 1代表同一个镜像存在第二个不同tag，此参数为可选参数，不填写时默认值为0
          secondImageName: $[ dependencies.DockerJobARM_DataFlowTools_ImageBuild.outputs['getAgentName.CURRENT_IMAGE'] ] # 此参数为可选参数，hasSecondImage为1时需要填写此字段，为镜像包含第二个tag的全名
          exitCode: ${{ parameters.TRIVY_EXIT_CODE }}
  
  - stage: MakeManifest
    displayName: 制作多架构镜像
    dependsOn: 
      - InitVariable
      - BuildImage
    condition: succeeded()
    variables:
      CURRENT_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.CURRENT_TAG']]
      LATEST_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.LATEST_TAG']]

      CR_LATEST_IMAGE_AMD64: $[ stageDependencies.BuildImage.DockerJobX86_CodeRunner_ImageBuild.outputs['getAgentName.LATEST_IMAGE'] ]
      CR_LATEST_IMAGE_ARM64: $[ stageDependencies.BuildImage.DockerJobARM_CodeRunner_ImageBuild.outputs['getAgentName.LATEST_IMAGE'] ]
      CR_CURRENT_IMAGE_AMD64: $[ stageDependencies.BuildImage.DockerJobX86_CodeRunner_ImageBuild.outputs['getAgentName.CURRENT_IMAGE'] ]
      CR_CURRENT_IMAGE_ARM64: $[ stageDependencies.BuildImage.DockerJobARM_CodeRunner_ImageBuild.outputs['getAgentName.CURRENT_IMAGE'] ]

      DTF_LATEST_IMAGE_AMD64: $[ stageDependencies.BuildImage.DockerJobX86_DataFlowTools_ImageBuild.outputs['getAgentName.LATEST_IMAGE'] ]
      DTF_LATEST_IMAGE_ARM64: $[ stageDependencies.BuildImage.DockerJobARM_DataFlowTools_ImageBuild.outputs['getAgentName.LATEST_IMAGE'] ]
      DTF_CURRENT_IMAGE_AMD64: $[ stageDependencies.BuildImage.DockerJobX86_DataFlowTools_ImageBuild.outputs['getAgentName.CURRENT_IMAGE'] ]
      DTF_CURRENT_IMAGE_ARM64: $[ stageDependencies.BuildImage.DockerJobARM_DataFlowTools_ImageBuild.outputs['getAgentName.CURRENT_IMAGE'] ]
    jobs:
      - job: MakeManifest
        displayName: 制作多架构镜像
        workspace:
          clean: all
        pool: $(poolNameAMD64)
        steps:
          - checkout: none
          - task: Docker@2
            inputs:
              command: login
              containerRegistry: ACRDockerRegistry
          - script: |
              set -e
              CR_CURRENT_IMAGE="$(imageRegistry)/$(imageCRRepository):$(CURRENT_TAG)"
              CR_LATEST_IMAGE="$(imageRegistry)/$(imageCRRepository):$(LATEST_TAG)"
              DTF_CURRENT_IMAGE="$(imageRegistry)/$(imageDFTRepository):$(CURRENT_TAG)"
              DTF_LATEST_IMAGE="$(imageRegistry)/$(imageDFTRepository):$(LATEST_TAG)"

              docker manifest create --amend $CR_LATEST_IMAGE $(CR_LATEST_IMAGE_AMD64) $(CR_LATEST_IMAGE_ARM64)
              docker manifest push --purge $CR_LATEST_IMAGE
              docker manifest create --amend $CR_CURRENT_IMAGE $(CR_CURRENT_IMAGE_AMD64) $(CR_CURRENT_IMAGE_ARM64)
              docker manifest push --purge $CR_CURRENT_IMAGE

              docker manifest create --amend $DTF_LATEST_IMAGE $(DTF_LATEST_IMAGE_AMD64) $(DTF_LATEST_IMAGE_ARM64)
              docker manifest push --purge $DTF_LATEST_IMAGE
              docker manifest create --amend $DTF_CURRENT_IMAGE $(DTF_CURRENT_IMAGE_AMD64) $(DTF_CURRENT_IMAGE_ARM64)
              docker manifest push --purge $DTF_CURRENT_IMAGE
  
  - stage: ChartPush
    displayName: Chart构建
    dependsOn:
      - InitVariable
    variables:
        CURRENT_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.CURRENT_TAG']]
        LATEST_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.LATEST_TAG']]
        COMMIT_ID: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.COMMIT_ID']]

    jobs:
      - job: ChartPush
        displayName: Chart构建
        workspace:
          clean: all
        pool:
          name: anydata-centos7.7-x86_64
          demands:
            - Agent.OSArchitecture -equals X64
            - Agent.OS -equals Linux
            - docker
        steps:
          - checkout: self
          - task: Bash@3
            displayName: Chart构建
            inputs:
              targetType: inline
              script: |
                #!/usr/bin/env
                set -ex

                chartCurrentTag=$(echo '$(CURRENT_TAG)' | sed 's/$(COMMIT_ID)/git+$(COMMIT_ID)/g')
                chartLatestTag=$(echo '$(LATEST_TAG)' | sed 's/$(COMMIT_ID)/git+$(COMMIT_ID)/g')

                chmod 777 -R $(pwd)/helm
                docker run --rm \
                      -v $(pwd)/helm:/chart \
                      --entrypoint='' \
                      $(yqImage) sh -c "
                  set -ex

                  yq eval -i '.image.registry = \"$(imageRegistry)\"' /chart/$(chartName)/values.yaml
                  yq eval -i '.image.repository = \"$(imageCRRepository)\"' /chart/$(chartName)/values.yaml
                  yq eval -i '.image.tag = \"$(LATEST_TAG)\"' /chart/$(chartName)/values.yaml
                  yq eval -i '.image.dataflowtools.repository = \"$(imageDFTRepository)\"' /chart/$(chartName)/values.yaml
                  yq eval -i '.image.dataflowtools.tag = \"$(LATEST_TAG)\"' /chart/$(chartName)/values.yaml

                  yq eval -i '.name = \"$(chartName)\"' /chart/$(chartName)/Chart.yaml
                  yq eval -i '.appVersion = \"$(CURRENT_TAG)\"' /chart/$(chartName)/Chart.yaml
                  sed -i 's/\"version\": .*/\"version\": \"$chartCurrentTag\",/g' /chart/$(chartName)/_componentMeta.json

                  yq eval -i '.version = \"$chartCurrentTag\"' /chart/$(chartName)/Chart.yaml
                  cd /chart && tar -czf $(chartName)-$chartCurrentTag.tar.gz $(chartName)

                  yq eval -i '.version = \"$chartLatestTag\"' /chart/$(chartName)/Chart.yaml
                  cd /chart && tar -czf $(chartName)-$chartLatestTag.tar.gz $(chartName)
                  "

                cd helm
                curlOptions="-s -u $(registry.username):$(registry.password) -H \"Content-Type:multipart/form-data\""
                curl ${curlOptions} -F "chart=@$(chartName)-$chartCurrentTag.tar.gz;type=application/x-compressed-tar" -X POST "$(chartRepo)"
                curl ${curlOptions} -F "chart=@$(chartName)-$chartLatestTag.tar.gz;type=application/x-compressed-tar" -X POST "$(chartRepo)"

          - task: Post-Bash@3
            inputs:
              targetType: inline
              script: |
                rm -rf $(Build.SourcesDirectory)/**
                ls -lah $(Agent.BuildDirectory)